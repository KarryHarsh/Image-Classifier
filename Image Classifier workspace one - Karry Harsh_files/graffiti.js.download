

// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
// https://github.com/pieroxy/lz-string/blob/master/libs/lz-string.js
//
// LZ-based compression algorithm, version 1.4.4
var LZString = function () {

  // private property
  var f = String.fromCharCode;
  var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
  var baseReverseDic = {};

  function getBaseValue(alphabet, character) {
    if (!baseReverseDic[alphabet]) {
      baseReverseDic[alphabet] = {};
      for (var i = 0; i < alphabet.length; i++) {
        baseReverseDic[alphabet][alphabet.charAt(i)] = i;
      }
    }
    return baseReverseDic[alphabet][character];
  }

  var LZString = {
    compressToBase64: function compressToBase64(input) {
      if (input == null) return "";
      var res = LZString._compress(input, 6, function (a) {
        return keyStrBase64.charAt(a);
      });
      switch (res.length % 4) {// To produce valid Base64
        default: // When could this happen ?
        case 0:
          return res;
        case 1:
          return res + "===";
        case 2:
          return res + "==";
        case 3:
          return res + "=";
      }
    },

    decompressFromBase64: function decompressFromBase64(input) {
      if (input == null) return "";
      if (input == "") return null;
      return LZString._decompress(input.length, 32, function (index) {
        return getBaseValue(keyStrBase64, input.charAt(index));
      });
    },

    compressToUTF16: function compressToUTF16(input) {
      if (input == null) return "";
      return LZString._compress(input, 15, function (a) {
        return f(a + 32);
      }) + " ";
    },

    decompressFromUTF16: function decompressFromUTF16(compressed) {
      if (compressed == null) return "";
      if (compressed == "") return null;
      return LZString._decompress(compressed.length, 16384, function (index) {
        return compressed.charCodeAt(index) - 32;
      });
    },

    //compress into uint8array (UCS-2 big endian format)
    compressToUint8Array: function compressToUint8Array(uncompressed) {
      var compressed = LZString.compress(uncompressed);
      var buf = new Uint8Array(compressed.length * 2); // 2 bytes per character

      for (var i = 0, TotalLen = compressed.length; i < TotalLen; i++) {
        var current_value = compressed.charCodeAt(i);
        buf[i * 2] = current_value >>> 8;
        buf[i * 2 + 1] = current_value % 256;
      }
      return buf;
    },

    //decompress from uint8array (UCS-2 big endian format)
    decompressFromUint8Array: function decompressFromUint8Array(compressed) {
      if (compressed === null || compressed === undefined) {
        return LZString.decompress(compressed);
      } else {
        var buf = new Array(compressed.length / 2); // 2 bytes per character
        for (var i = 0, TotalLen = buf.length; i < TotalLen; i++) {
          buf[i] = compressed[i * 2] * 256 + compressed[i * 2 + 1];
        }

        var result = [];
        buf.forEach(function (c) {
          result.push(f(c));
        });
        return LZString.decompress(result.join(''));
      }
    },

    //compress into a string that is already URI encoded
    compressToEncodedURIComponent: function compressToEncodedURIComponent(input) {
      if (input == null) return "";
      return LZString._compress(input, 6, function (a) {
        return keyStrUriSafe.charAt(a);
      });
    },

    //decompress from an output of compressToEncodedURIComponent
    decompressFromEncodedURIComponent: function decompressFromEncodedURIComponent(input) {
      if (input == null) return "";
      if (input == "") return null;
      input = input.replace(/ /g, "+");
      return LZString._decompress(input.length, 32, function (index) {
        return getBaseValue(keyStrUriSafe, input.charAt(index));
      });
    },

    compress: function compress(uncompressed) {
      return LZString._compress(uncompressed, 16, function (a) {
        return f(a);
      });
    },
    _compress: function _compress(uncompressed, bitsPerChar, getCharFromInt) {
      if (uncompressed == null) return "";
      var i,
          value,
          context_dictionary = {},
          context_dictionaryToCreate = {},
          context_c = "",
          context_wc = "",
          context_w = "",
          context_enlargeIn = 2,
          // Compensate for the first entry which should not count
      context_dictSize = 3,
          context_numBits = 2,
          context_data = [],
          context_data_val = 0,
          context_data_position = 0,
          ii;

      for (ii = 0; ii < uncompressed.length; ii += 1) {
        context_c = uncompressed.charAt(ii);
        if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
          context_dictionary[context_c] = context_dictSize++;
          context_dictionaryToCreate[context_c] = true;
        }

        context_wc = context_w + context_c;
        if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
          context_w = context_wc;
        } else {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = context_data_val << 1 | value;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = context_data_val << 1 | value & 1;
                if (context_data_position == bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn == 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          // Add wc to the dictionary.
          context_dictionary[context_wc] = context_dictSize++;
          context_w = String(context_c);
        }
      }

      // Output the code for w.
      if (context_w !== "") {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i = 0; i < 8; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i = 0; i < 16; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
      }

      // Mark the end of the stream
      value = 2;
      for (i = 0; i < context_numBits; i++) {
        context_data_val = context_data_val << 1 | value & 1;
        if (context_data_position == bitsPerChar - 1) {
          context_data_position = 0;
          context_data.push(getCharFromInt(context_data_val));
          context_data_val = 0;
        } else {
          context_data_position++;
        }
        value = value >> 1;
      }

      // Flush the last char
      while (true) {
        context_data_val = context_data_val << 1;
        if (context_data_position == bitsPerChar - 1) {
          context_data.push(getCharFromInt(context_data_val));
          break;
        } else context_data_position++;
      }
      return context_data.join('');
    },

    decompress: function decompress(compressed) {
      if (compressed == null) return "";
      if (compressed == "") return null;
      return LZString._decompress(compressed.length, 32768, function (index) {
        return compressed.charCodeAt(index);
      });
    },

    _decompress: function _decompress(length, resetValue, getNextValue) {
      var dictionary = [],
          next,
          enlargeIn = 4,
          dictSize = 4,
          numBits = 3,
          entry = "",
          result = [],
          i,
          w,
          bits,
          resb,
          maxpower,
          power,
          c,
          data = { val: getNextValue(0), position: resetValue, index: 1 };

      for (i = 0; i < 3; i += 1) {
        dictionary[i] = i;
      }

      bits = 0;
      maxpower = Math.pow(2, 2);
      power = 1;
      while (power != maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb > 0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (next = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2, 8);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          c = f(bits);
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2, 16);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          c = f(bits);
          break;
        case 2:
          return "";
      }
      dictionary[3] = c;
      w = c;
      result.push(c);
      while (true) {
        if (data.index > length) {
          return "";
        }

        bits = 0;
        maxpower = Math.pow(2, numBits);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }

        switch (c = bits) {
          case 0:
            bits = 0;
            maxpower = Math.pow(2, 8);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }

            dictionary[dictSize++] = f(bits);
            c = dictSize - 1;
            enlargeIn--;
            break;
          case 1:
            bits = 0;
            maxpower = Math.pow(2, 16);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            dictionary[dictSize++] = f(bits);
            c = dictSize - 1;
            enlargeIn--;
            break;
          case 2:
            return result.join('');
        }

        if (enlargeIn == 0) {
          enlargeIn = Math.pow(2, numBits);
          numBits++;
        }

        if (dictionary[c]) {
          entry = dictionary[c];
        } else {
          if (c === dictSize) {
            entry = w + w.charAt(0);
          } else {
            return null;
          }
        }
        result.push(entry);

        // Add w+entry[0] to the dictionary.
        dictionary[dictSize++] = w + entry.charAt(0);
        enlargeIn--;

        w = entry;

        if (enlargeIn == 0) {
          enlargeIn = Math.pow(2, numBits);
          numBits++;
        }
      }
    }
  };
  return LZString;
}();

if (typeof define === 'function' && define.amd) {
  define('js/LZString.js',[],function () {
    return LZString;
  });
} else if (typeof module !== 'undefined' && module != null) {
  module.exports = LZString;
} else if (typeof angular !== 'undefined' && angular != null) {
  angular.module('LZString', []).factory('LZString', function () {
    return LZString;
  });
};


define('js/utils.js',['components/marked/lib/marked'], function (marked) {

  var utils = {
    cellMaps: {},
    cplusplusKernel11: 'xeus-cling-cpp11',
    cplusplusKernel14: 'xeus-cling-cpp14',
    cplusplusKernel17: 'xeus-cling-cpp17',
    pythonKernel: 'python3',
    rKernel: 'ir',

    addCR: function addCR(str) {
      return str + "\n";
    },

    generateUniqueId: function generateUniqueId() {
      return 'id_' + Math.random().toString(36).substr(2, 7);
    },

    getNow: function getNow() {
      return new Date().getTime();
    },

    createPermanentStringFromFlag: function createPermanentStringFromFlag(flag) {
      return flag ? 'permanent' : 'temporary';
    },

    getCodeCommentString: function getCodeCommentString() {
      var currentKernelName = Jupyter.notebook.kernel.name;
      var codeCommentString = void 0;
      switch (currentKernelName) {
        case utils.cplusplusKernel11:
        case utils.cplusplusKernel14:
        case utils.cplusplusKernel17:
          codeCommentString = '//';
          break;
        case utils.pythonKernel:
        case utils.rKernel:
          codeCommentString = '#';
          break;
      }
      return codeCommentString;
    },

    // These two functions help us translate between what we store in the notebook json itself ('graffitiCellId') and how we use it in the code, just as 'cellId'.
    // This was done to make our tags less likely to collide with other Jupyter plugins, but we wanted to keep the field name short in the Graffiti code.
    getMetadataCellId: function getMetadataCellId(metadata) {
      return metadata.graffitiCellId;
    },

    setMetadataCellId: function setMetadataCellId(metadata, cellId) {
      metadata.graffitiCellId = cellId;
      return cellId;
    },

    parseRecordingFullId: function parseRecordingFullId(recordingFullId) {
      var parts = recordingFullId.split('_');
      var recordingCellId = 'id_' + parts[0];
      var recordingKey = 'id_' + parts[1];
      return {
        recordingCellId: recordingCellId,
        recordingKey: recordingKey
      };
    },

    computeArrayAverage: function computeArrayAverage(array) {
      var average = 0;
      for (var i = 0; i < array.length; ++i) {
        average += array[i];
      }
      average = average / array.length;
      return average;
    },

    subtractCoords: function subtractCoords(c1, c2) {
      var x1 = c1.x !== undefined ? c1.x : c1.left;
      var y1 = c1.y !== undefined ? c1.y : c1.top;
      var x2 = c2.x !== undefined ? c2.x : c2.left;
      var y2 = c2.y !== undefined ? c2.y : c2.top;
      return {
        x: x2 - x1,
        y: y2 - y1
      };
    },

    refreshCodeMirrorSelection: function refreshCodeMirrorSelection(cell) {
      if (cell.cell_type === 'code' && cell.selected) {
        cm = cell.code_mirror;
        selections = cm.listSelections();
        cell.focus_cell();
        cm.getInputField().focus();
        cm.setSelections(selections);
      }
    },

    refreshCodeMirrorSelections: function refreshCodeMirrorSelections() {
      var cells = Jupyter.notebook.get_cells();
      var cm = void 0,
          selections = void 0;
      for (var i = 0; i < cells.length; ++i) {
        cell = cells[i];
        utils.refreshCodeMirrorSelection(cell);
      }
    },

    clearSelectedCellOutput: function clearSelectedCellOutput() {
      var selectedCell = Jupyter.notebook.get_selected_cell();
      if (selectedCell !== undefined) {
        selectedCell.clear_output();
      }
    },

    composeGraffitiId: function composeGraffitiId(cellId, recordingKey, activeTakeId) {
      var combinedIds = [cellId.replace('id_', ''), recordingKey.replace('id_', '')];
      if (activeTakeId !== undefined) {
        combinedIds.push(activeTakeId.replace('id_', ''));
      }
      var combinedIdStr = combinedIds.join('_');
      return combinedIdStr;
    },

    // Assign cellIds to any cells that don't have them yet.
    assignCellIds: function assignCellIds() {
      var cells = Jupyter.notebook.get_cells();
      var cell = void 0,
          cellId = void 0,
          i = void 0;
      for (var _i = 0; _i < cells.length; ++_i) {
        cell = cells[_i];
        cellId = utils.generateUniqueId();
        if (!cell.metadata.hasOwnProperty('graffitiCellId')) {
          utils.setMetadataCellId(cell.metadata, cellId);
        }
      }
    },

    assignCellGraffitiConfig: function assignCellGraffitiConfig(cell, graffitiConfig) {
      cell.metadata['graffitiConfig'] = graffitiConfig;
    },

    setCellGraffitiConfigEntry: function setCellGraffitiConfigEntry(cell, key, val) {
      if (!cell.metadata.hasOwnProperty('graffitiConfig')) {
        cell.metadata['graffitiConfig'] = {};
      }
      cell.metadata.graffitiConfig[key] = val;
    },

    getCellGraffitiConfig: function getCellGraffitiConfig(cell) {
      if (cell.metadata.hasOwnProperty('graffitiConfig')) {
        return cell.metadata['graffitiConfig'];
      }
      return undefined;
    },

    getNotebookGraffitiConfigEntry: function getNotebookGraffitiConfigEntry(key) {
      if (Jupyter.notebook.metadata.hasOwnProperty('graffiti')) {
        return Jupyter.notebook.metadata['graffiti'][key];
      }
      return undefined;
    },

    setNotebookGraffitiConfigEntry: function setNotebookGraffitiConfigEntry(key, val) {
      if (Jupyter.notebook.metadata.hasOwnProperty('graffiti')) {
        Jupyter.notebook.metadata['graffiti'][key] = val;
      }
    },

    refreshCellMaps: function refreshCellMaps() {
      utils.cellMaps = {
        cells: Jupyter.notebook.get_cells(),
        maps: {}
      };
      var cell = void 0,
          cellDOM = void 0,
          cellKeys = Object.keys(utils.cellMaps.cells);
      for (var cellIndex = 0; cellIndex < cellKeys.length; ++cellIndex) {
        cell = utils.cellMaps.cells[cellIndex];
        // supports lookups by cellId
        utils.cellMaps.maps[utils.getMetadataCellId(cell.metadata)] = cellIndex;
        // Dress up the DOM  cellId so we can track selections in them (pretty much only markdown, selections in code_mirror are done through its API
        if (cell.hasOwnProperty('inner_cell')) {
          cellDOM = $(cell.inner_cell).parents('.cell');
        } else if (cell.hasOwnProperty('element')) {
          cellDOM = $(cell.element);
        }
        if (cellDOM !== undefined) {
          cellDOM.attr({ 'graffiti-cell-id': utils.getMetadataCellId(cell.metadata) });
        }
      }
    },

    findCellIndexByCellId: function findCellIndexByCellId(cellId) {
      if (utils.cellMaps !== undefined && utils.cellMaps.maps !== undefined && utils.cellMaps.maps.hasOwnProperty(cellId)) {
        return utils.cellMaps.maps[cellId];
      }
      return undefined;
    },

    findCellByCellId: function findCellByCellId(cellId) {
      var index = utils.findCellIndexByCellId(cellId);
      if (index !== undefined) {
        return utils.cellMaps.cells[index];
      }
      return undefined;
    },

    findCellByCodeMirror: function findCellByCodeMirror(cm) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = utils.cellMaps.cells[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _cell = _step.value;

          if (_cell.code_mirror === cm) {
            return _cell;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return undefined;
    },

    getCellRects: function getCellRects(cell) {
      var cellElement = $(cell.element[0]);
      var cellRect = cellElement[0].getBoundingClientRect();
      var innerCell = cellElement.find('.inner_cell')[0];
      var innerCellRect = innerCell.getBoundingClientRect();
      var prompt = cellElement.find('.prompt')[0];
      var promptRect = prompt.getBoundingClientRect();

      return {
        cellRect: cellRect,
        innerCell: innerCell,
        innerCellRect: innerCellRect,
        promptRect: promptRect
      };
    },

    renderMarkdown: function renderMarkdown(contents) {
      // Strip out special commands eg. headline commands and make all hrefs pop new tabs
      var cleanedContents = contents.replace(/^\s*%%(.*)$/mg, '');
      return marked(cleanedContents).replace(/(href=".*")>/g, "$1 target=\"_blank\">");
    },

    collectViewInfo: function collectViewInfo(clientX, clientY, notebookPanelHeight, scrollDiff) {
      var cellElement = void 0,
          cellElementJq = void 0,
          cellRect = void 0,
          outerCellRect = void 0,
          cellIndex = void 0,
          cellIndexStr = void 0,
          cell = void 0,
          innerCell = void 0,
          innerCellRect = void 0,
          innerCellRectRaw = void 0,
          prompt = void 0,
          pointerPosition = void 0,
          pointerInsidePromptArea = void 0,
          cellPosition = void 0,
          lineNumbersVisible = void 0,
          cm = void 0;
      var inputCells = Jupyter.notebook.get_cells();
      var selectedCell = Jupyter.notebook.get_selected_cell();
      var selectedCellId = utils.getMetadataCellId(selectedCell.metadata);
      // handle case where pointer is above all cells or below all cells
      var promptBbox = undefined;
      for (cellIndexStr in inputCells) {
        cellIndex = parseInt(cellIndexStr);
        cell = inputCells[cellIndex];
        cellElement = cell.element[0];
        cellElementJq = $(cellElement);
        cellRect = cellElement.getBoundingClientRect();
        prompt = cellElementJq.find('.prompt');
        pointerInsidePromptArea = false;
        if (prompt.length > 0 && prompt.is(':visible')) {
          promptBbox = prompt[0].getBoundingClientRect();
          pointerInsidePromptArea = clientX >= promptBbox.left && clientX < promptBbox.right && clientY >= promptBbox.top && clientY < promptBbox.bottom;
        }
        if (cellRect.top <= clientY && clientY <= cellRect.bottom ||
        // These are the cases where the pointer is above the first cell or below the last cell
        cellIndex === 0 && clientY < cellRect.top || cellIndex === inputCells.length - 1 && cellRect.bottom < clientY) {
          outerCellRect = {
            top: cellRect.top,
            left: cellRect.left
          };
          innerCell = cellElementJq.find('.inner_cell')[0];
          innerCellRectRaw = innerCell.getBoundingClientRect();
          innerCellRect = {
            top: innerCellRectRaw.top,
            left: innerCellRectRaw.left,
            width: innerCellRectRaw.width,
            height: innerCellRectRaw.height
          };
          lineNumbersVisible = cell.code_mirror.options.lineNumbers;
          cellPosition = cellElementJq.position();
          cm = cell.code_mirror;
          var innerScrollInfo = cm.getScrollInfo();
          var innerScroll = { left: innerScrollInfo.left, top: innerScrollInfo.top };
          return {
            cellId: utils.getMetadataCellId(cell.metadata), // The id of cell that the pointer is hovering over right now
            innerCellRect: innerCellRect,
            innerScroll: innerScroll,
            lineNumbersVisible: lineNumbersVisible,
            outerCellRect: outerCellRect,
            inMarkdownCell: cell.cell_type === 'markdown',
            inPromptArea: pointerInsidePromptArea,
            promptWidth: promptBbox === undefined ? 0 : promptBbox.width,
            selectedCellId: selectedCellId,
            notebookPanelHeight: notebookPanelHeight,
            scrollDiff: scrollDiff
          };
        }
      }
      return { cellId: undefined, cellRectTop: undefined, cellRectBottom: undefined, relativePointerPosition: undefined };
    },

    getActiveCellId: function getActiveCellId() {
      var activeCell = Jupyter.notebook.get_selected_cell();
      return utils.getMetadataCellId(activeCell.metadata);
    },

    getActiveCellLineNumber: function getActiveCellLineNumber() {
      var activeCell = Jupyter.notebook.get_selected_cell();
      var cm = activeCell.code_mirror;
      var selections = cm.listSelections();
      var activeLine = selections[0].anchor.line;
      return activeLine;
    },

    saveNotebook: function saveNotebook(cb) {
      Jupyter.notebook.save_notebook().then(function () {
        if (cb !== undefined) {
          cb();
        }
        console.log('Graffiti: Notebook saved.');
      });
    },

    // You can delete this, it's no longer needed now that we call cell.focus_cell() when we change selections
    shrinkAllCMSelections: function shrinkAllCMSelections() {
      var inputCells = Jupyter.notebook.get_cells();
      var cell = void 0,
          cm = void 0,
          selections = void 0;
      for (var i = 0; i < inputCells.length; ++i) {
        cell = inputCells[i];
        if (cell.cell_type === 'code') {
          cm = cell.code_mirror;
          selections = cm.listSelections();
          if (selections.length > 0) {
            console.log('Clearing selections before: selections:', selections);
            for (var j = 0; j < selections.length; ++j) {
              selections[j].head = $.extend({}, selections[j].anchor);
            }
            console.log('Clearing selections after: selections:', selections);
            cm.setSelections(selections);
          }
        }
      }
    },

    // Legacy
    /*
        collectTokenStrings: (allTokens, tokens) => {
          const subTokens = allTokens.slice(tokens.firstTokenOffset, tokens.firstTokenOffset + tokens.extraTokens + 1);
          return subTokens.reduce( (tokensString, token) => { tokensString + token.string } )
        },
    */

    // Find out whether the current selection intersections with any graffiti token ranges, or which tokens are in the selection if not.
    findSelectionTokens: function findSelectionTokens(recordingCell, tokenRanges, state) {
      //console.log('findSelectionTokens, tokenRanges:', tokenRanges);
      var range = void 0,
          startRange = void 0,
          endRange = void 0,
          recording = void 0,
          hasMovie = void 0,
          recordingKey = void 0,
          markdown = void 0,
          isIntersecting = false;
      var recordingCellId = utils.getMetadataCellId(recordingCell.metadata);
      var recordingCellType = recordingCell.cell_type;
      var cm = recordingCell.code_mirror;
      var selections = cm.listSelections();
      var firstSelection = selections[0];
      var anchorPos = cm.indexFromPos(firstSelection.anchor);
      var headPos = cm.indexFromPos(firstSelection.head);
      var startPos = Math.min(anchorPos, headPos);
      var endPos = Math.max(anchorPos, headPos);
      var minStartRange = 1000000000;
      var noResults = { isIntersecting: false, noTokensPresent: true };
      var results = noResults;

      if (recordingCellType === 'markdown') {
        // If in a markdown cell, the selection "tokens" are simply the selection, but only if the selection is 2 characters or more. We do not try to use
        // code mirror's tokenizer tools within markdown cells as there's other stuff like html in a markdown cell that could be confusing to it.
        var contents = recordingCell.get_text();
        var tagsRe = RegExp('<span class="graffiti-highlight (graffiti-[^"]+)">(.*?)</span>', 'gm');
        var tags = [],
            match = void 0,
            tag = void 0;
        var idMatch = void 0;
        while ((match = tagsRe.exec(contents)) !== null) {
          idMatch = match[1].match(/graffiti-(id_.[^\-]+)-(id_[^\s]+)/);
          tags.push({
            fullMatch: match[0],
            recordingCellId: idMatch[1],
            recordingKey: idMatch[2],
            innerText: match[2],
            startRange: match.index,
            endRange: match.index + match[0].length
          });
        }

        // Figure out if the startPs or endPos is inside an existing Graffiti in this markdown cell (intersecting).
        if (tags.length > 0) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = tags[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              tag = _step2.value;

              if (startPos >= tag.startRange && startPos <= tag.endRange || endPos >= tag.startRange && endPos <= tag.endRange) {
                isIntersecting = true;
                break;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
        if (isIntersecting) {
          recording = state.getManifestSingleRecording(tag.recordingCellId, tag.recordingKey);
          if (recording !== undefined) {
            hasMovie = recording.hasMovie;
            results = {
              isIntersecting: true,
              noTokensPresent: false,
              recordingCell: recordingCell,
              recordingCellId: recordingCellId,
              recordingKey: tag.recordingKey,
              hasMovie: hasMovie,
              allTokensString: tag.innerText,
              markdown: tag.innerText,
              range: {
                start: tag.startRange,
                end: tag.endRange
              }
            };
          }
        } else {
          // Now check for a selection in the markdown cm cell.
          if (endPos > startPos + 1) {
            // 2 or more chars is in the selection; this way we disallow Graffitis applied to just CR's
            // Move startPos forward past markdown-significant characters, because if we put a graffiti around the markdown indicators, they will lose their markdown significance.
            var skipped = false;
            var checkChar = contents[startPos];
            var skipChars = '#_*'; // note: we do not include backticks, even though they are significant to markdown, as we want them inside our selected text for the graffiti spans.
            while (skipChars.indexOf(checkChar) !== -1 && startPos < endPos) {
              skipped = true;
              startPos++;
              checkChar = contents[startPos];
            }
            if (skipped && contents[startPos] === ' ') {
              // skip past the space after hashtags
              ++startPos;
            }
            // expand the range to include surrounding backticks
            if (startPos > 0) {
              if (contents[startPos - 1] === '`') {
                startPos--;
              }
            }
            if (endPos < contents.length - 1) {
              if (contents[endPos + 1] === '`') {
                endPos++;
              }
            }
            // Backup from a cr. this may happen if the user triple clicked on a line and absorbed the cr. we don't want that.
            //console.log('Check for backing up:-->', contents.substring(startPos,endPos), '<--');
            //console.log('code:', contents[endPos].charCodeAt(0), 'code-1:', contents[endPos-1].charCodeAt(0));
            while (contents[endPos - 1].charCodeAt(0) === 10) {
              //console.log('backing up, -->', contents[endPos], '<--,', contents[endPos-1].charCodeAt(0) );
              endPos--;
              if (endPos === startPos + 2) {
                break;
              }
            }
            //console.log('selection will be:', contents.substring(startPos,endPos), '<--', contents[endPos].charCodeAt(0));
            results = {
              isIntersecting: false,
              noTokensPresent: false,
              range: {
                start: startPos,
                end: endPos
              },
              allTokensString: cm.getSelection()
            };
          }
        }
        //console.log('final results:',results);
      } else if (recordingCellType === 'code') {
        // If in a code cell, try to find tokens in and around the selection.
        if (tokenRanges[recordingCellId] !== undefined) {
          var tokenRangesThisCell = tokenRanges[recordingCellId];
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = Object.keys(tokenRangesThisCell)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              recordingKey = _step3.value;

              range = tokenRangesThisCell[recordingKey];
              startRange = cm.indexFromPos(range.start);
              endRange = cm.indexFromPos(range.end);
              // console.log('startPos:', startPos, 'endPos:', endPos, '| startRange:', startRange, 'endRange:', endRange, 'range:', range);
              if (startPos <= startRange && endPos >= endRange || // selection surrounds or equals the range
              startPos >= startRange && startPos < endRange || endPos > startRange && endPos <= endRange) {
                // selection is inside the range
                if (startRange < minStartRange) {
                  minStartRange = startRange;
                  recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
                  if (recording) {
                    markdown = recording.markdown;
                    hasMovie = recording.hasMovie;
                    //console.log('found range:', range);
                    isIntersecting = true;
                    results = {
                      isIntersecting: true,
                      noTokensPresent: false,
                      recordingCell: recordingCell,
                      recordingCellId: recordingCellId,
                      recordingKey: recordingKey,
                      markdown: markdown,
                      hasMovie: hasMovie,
                      range: {
                        start: startRange,
                        end: endRange
                      }
                    };
                  };
                }
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        }
        if (!isIntersecting) {
          // we didn't find a match within existing recordings. See what tokens are selected overall in that case.
          // console.log('not intersecting, now checking for new graffiti creation');
          var allTokens = utils.collectCMTokens(cm);
          var startCheck = void 0,
              endCheck = void 0,
              token = void 0,
              startToken = void 0,
              endToken = void 0,
              lastToken = void 0,
              startTokenIndex = void 0,
              startTokenStringTrimmed = void 0,
              tokenCount = 0,
              tokensString = '';
          if (allTokens.length === 0) {
            // degnerate case 1: no tokens present at all in the cell
            results = noResults;
          } else {
            token = allTokens[allTokens.length - 1];
            endCheck = cm.indexFromPos({ line: token.line, ch: token.end });
            if (startPos > endCheck) {
              // degenerate case 2: selection caret is past the last token present
              results = noResults;
            } else {
              for (var i = 0; i < allTokens.length; ++i) {
                lastToken = token;
                token = allTokens[i];
                startCheck = cm.indexFromPos({ line: token.line, ch: token.start });
                endCheck = cm.indexFromPos({ line: token.line, ch: token.end });
                //console.log('startPos, endPos:', startPos, endPos, 'checking token:', token.string, startCheck, endCheck);
                if (startToken === undefined) {
                  startTokenStringTrimmed = $.trim(token.string);
                  if (startTokenStringTrimmed.length > 0 && (startPos >= startCheck && startPos <= endCheck || endPos >= startCheck && endPos <= endCheck)) {
                    startToken = token;
                    startTokenIndex = i;
                    tokenCount = 1;
                    tokensString = startToken.string;
                    //console.log('start token:', startToken);
                    if (startPos === endPos) {
                      endToken = token; // the selection is zero characters long so the startToken and the endToken are the same
                    }
                  }
                } else if (!(startCheck >= endPos)) {
                  // scan forward for the ending token
                  endToken = token;
                  tokenCount++;
                  tokensString += token.string;
                  //console.log('end token:', endToken);
                }
                if (startCheck > endPos) {
                  if (startToken === undefined && lastToken !== undefined) {
                    console.log('Graffiti: between tokens, so cannot create a Graffiti.');
                    results = noResults;
                  }
                  break;
                }
              }

              // Find the occurence count of the first token in the code cell, e.g. if the token is the second "hello" in "hello there, mr. hello dude"
              if (startToken === undefined) {
                results = noResults;
                console.log('Graffiti: degenerate case 3, startToken not found despite everything. Falling to safe route.');
              } else {
                //console.log('Graffiti: startPos, endPos:', startPos, endPos, 'startToken,endToken:', startToken,endToken);
                startToken.offset = 0;
                for (var _i2 = 0; _i2 < allTokens.length; ++_i2) {
                  token = allTokens[_i2];
                  if (token.type === startToken.type && token.string === startToken.string) {
                    if (_i2 < startTokenIndex) {
                      ++startToken.offset;
                    } else {
                      break;
                    }
                  }
                }

                if (endToken === undefined) {
                  console.log('Graffiti: degenerate case 4, endToken not found. Falling to safe route.');
                  endToken = startToken; // degenerate case 4: never found an end token, assume just one token. not sure why this happens yet 8/20/18
                }

                results = {
                  isIntersecting: false,
                  noTokensPresent: false,
                  tokens: {
                    start: {
                      type: startToken.type,
                      string: startToken.string,
                      offset: startToken.offset
                    },
                    count: tokenCount
                  },
                  allTokensString: tokensString,
                  range: {
                    start: cm.indexFromPos({ line: startToken.line, ch: startToken.ch }),
                    end: cm.indexFromPos({ line: endToken.line, ch: endToken.ch }),
                    selectionStart: startPos,
                    selectionEnd: endPos
                  }
                };
              }
            }
          }
        }
      }

      //console.log('findIntersectingRange results:', results);
      return results;
    },

    // Collect all tokens in code-mirror into an array and tag each with which line it's found on. We use this 
    // in refreshGraffitiHighlights() as we mark up a cell with existing recorded graffitis.
    collectCMTokens: function collectCMTokens(cm) {
      var allTokens = [];
      var lineCount = cm.lineCount();
      for (var i = 0; i < lineCount; ++i) {
        lineTokens = cm.getLineTokens(i);
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = Object.keys(lineTokens)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var j = _step4.value;

            lineTokens[j].line = i;
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        allTokens = allTokens.concat(lineTokens);
      }
      return allTokens;
    },

    // Given a start token string and a tokenOffset, and how many subsequent tokens are needed, pull the line and character ranges
    // out of the given code mirror instance (since those ranges might have changed since the graffiti was first created).
    getCMTokenRange: function getCMTokenRange(cm, tokens, allTokens) {
      var startToken = tokens.start;
      if (startToken === undefined) {
        return undefined; // couldn't find start token, degenerate case, can only happen if a graffiti has a corrupted startToken.
      }
      var allTokensLength = allTokens.length;
      var i = void 0,
          tokenCounter = 0,
          lineTokens = void 0,
          token = void 0,
          firstTokenPosition = void 0;
      for (i = 0; i < allTokensLength; ++i) {
        token = allTokens[i];
        if (token.string === startToken.string && token.type === startToken.type) {
          if (tokenCounter === startToken.offset) {
            firstTokenPosition = i;
            break;
          } else {
            ++tokenCounter;
          }
        }
      }
      if (firstTokenPosition === undefined) {
        return undefined; // couldn't find first token
      }
      var lastTokenPosition = Math.min(allTokensLength - 1, firstTokenPosition + tokens.count - 1);
      var firstToken = allTokens[firstTokenPosition];
      var lastToken = allTokens[lastTokenPosition];

      return {
        start: {
          line: firstToken.line, ch: firstToken.start
        },
        end: {
          line: lastToken.line, ch: lastToken.end
        }
      };
    },

    cleanSelectionRecord: function cleanSelectionRecord(rec) {
      return {
        anchor: {
          ch: rec.anchor.ch,
          line: rec.anchor.line
        },
        head: {
          ch: rec.head.ch,
          line: rec.head.line
        }
      };
    },

    cleanSelectionRecords: function cleanSelectionRecords(recs) {
      var cleanedRecs = [];
      if (recs.length === 0) {
        return cleanedRecs;
      }
      for (var i = 0; i < recs.length; ++i) {
        cleanedRecs.push(utils.cleanSelectionRecord(recs[i]));
      }
      return cleanedRecs;
    },

    //
    // Time formatting functions
    //
    timeZeroPad: function timeZeroPad(num) {
      var strNum = num.toString();
      return strNum.length < 2 ? '0' + strNum : strNum;
    },

    formatTime: function formatTime(currentTimeMilliseconds, opts) {
      var currentTimeSeconds = currentTimeMilliseconds / 1000;
      var computedHour = Math.floor(currentTimeSeconds / 3600);
      var computedMinutes = Math.floor((currentTimeSeconds - computedHour * 3600) / 60);
      var computedSeconds = Math.floor(currentTimeSeconds - (computedMinutes * 60 + computedHour * 3600));
      var computedMilliseconds = Math.min(99, (Math.floor(currentTimeMilliseconds - (computedSeconds + computedMinutes * 60 + computedHour * 3600) * 1000) / 10).toFixed(0));
      var displayMilliseconds = utils.timeZeroPad(computedMilliseconds);
      var displaySeconds = utils.timeZeroPad(computedSeconds);
      var displayMinutes = utils.timeZeroPad(computedMinutes);
      var displayHour = utils.timeZeroPad(computedHour);
      var currentTimeFormatted = void 0;
      if (opts.includeMillis) {
        currentTimeFormatted = displayMinutes + ':' + displaySeconds + ':' + displayMilliseconds;
      } else {
        currentTimeFormatted = displayMinutes + ':' + displaySeconds;
      }
      return currentTimeFormatted;
    },

    loadCss: function loadCss(cssPaths) {
      for (var i in cssPaths) {
        var path = cssPaths[i];
        var previousCssTag = $('#recorder-css-tag-' + i);
        if (previousCssTag.length === 0) {
          // https://stackoverflow.com/questions/18510347/dynamically-load-stylesheets
          var styles = document.createElement('link');
          styles.rel = 'stylesheet';
          styles.id = 'recorder-css-tag-' + i;
          styles.type = 'text/css';
          styles.media = 'screen';
          styles.href = path;
          document.getElementsByTagName('head')[0].appendChild(styles);
        }
      }
    },

    // Thanks for this goes to : https://hackernoon.com/copying-text-to-clipboard-with-javascript-df4d4988697f
    copyToClipboard: function copyToClipboard(str) {
      var el = document.createElement('textarea'); // Create a <textarea> element
      el.value = str; // Set its value to the string that you want copied
      el.setAttribute('readonly', ''); // Make it readonly to be tamper-proof
      el.style.position = 'absolute';
      el.style.left = '-9999px'; // Move outside the screen to make it invisible
      document.body.appendChild(el); // Append the <textarea> element to the HTML document
      var selected = document.getSelection().rangeCount > 0 // Check if there is any content selected previously
      ? document.getSelection().getRangeAt(0) // Store selection if found
      : false; // Mark as false to know no selection existed before
      el.select(); // Select the <textarea> content
      document.execCommand('copy'); // Copy - only works as a result of a user action (e.g. click events)
      document.body.removeChild(el); // Remove the <textarea> element
      if (selected) {
        // If a selection existed before copying
        document.getSelection().removeAllRanges(); // Unselect everything on the HTML document
        document.getSelection().addRange(selected); // Restore the original selection
      }
    },

    createApiSymlink: function createApiSymlink() {
      // Create a symlink to get 'import jupytergraffiti' working
      var createSymlinkCmd = 'ln -sf /opt/jupytergraffiti jupytergraffiti';

      // Create a python file and execute the file 
      var importApiScript = '';
      // Adding /opt/jupytergraffiti to system path allows us to import it as a python module
      importApiScript += 'import sys\\n';
      importApiScript += 'api_path="/opt/jupytergraffiti"\\n';
      importApiScript += 'if api_path not in sys.path:\\n';
      importApiScript += '  sys.path.insert(0,api_path)\\n';
      var executePythonScript = '!' + createSymlinkCmd + ' && echo \'' + importApiScript + '\' > /tmp/graffiti-symlink.py && python /tmp/graffiti-symlink.py';
      var scriptOptions = {
        silent: false,
        store_history: false,
        stop_on_error: true
      };

      Jupyter.notebook.kernel.execute(executePythonScript, undefined, scriptOptions);
    }

  };

  return utils;
});


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (f) {
    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define('js/xterm/xterm.js',[], f);
    } else {
        var g;if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }g.Terminal = f();
    }
})(function () {
    var define, module, exports;return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }return n[o].exports;
        }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
            s(r[o]);
        }return s;
    }({ 1: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var CircularList_1 = require("./utils/CircularList");
            exports.CHAR_DATA_ATTR_INDEX = 0;
            exports.CHAR_DATA_CHAR_INDEX = 1;
            exports.CHAR_DATA_WIDTH_INDEX = 2;
            exports.CHAR_DATA_CODE_INDEX = 3;
            exports.MAX_BUFFER_SIZE = 4294967295;
            var Buffer = function () {
                function Buffer(_terminal, _hasScrollback) {
                    this._terminal = _terminal;
                    this._hasScrollback = _hasScrollback;
                    this.clear();
                }
                Object.defineProperty(Buffer.prototype, "lines", {
                    get: function get() {
                        return this._lines;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Buffer.prototype, "hasScrollback", {
                    get: function get() {
                        return this._hasScrollback && this.lines.maxLength > this._terminal.rows;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Buffer.prototype, "isCursorInViewport", {
                    get: function get() {
                        var absoluteY = this.ybase + this.y;
                        var relativeY = absoluteY - this.ydisp;
                        return relativeY >= 0 && relativeY < this._terminal.rows;
                    },
                    enumerable: true,
                    configurable: true
                });
                Buffer.prototype._getCorrectBufferLength = function (rows) {
                    if (!this._hasScrollback) {
                        return rows;
                    }
                    var correctBufferLength = rows + this._terminal.options.scrollback;
                    return correctBufferLength > exports.MAX_BUFFER_SIZE ? exports.MAX_BUFFER_SIZE : correctBufferLength;
                };
                Buffer.prototype.fillViewportRows = function () {
                    if (this._lines.length === 0) {
                        var i = this._terminal.rows;
                        while (i--) {
                            this.lines.push(this._terminal.blankLine());
                        }
                    }
                };
                Buffer.prototype.clear = function () {
                    this.ydisp = 0;
                    this.ybase = 0;
                    this.y = 0;
                    this.x = 0;
                    this._lines = new CircularList_1.CircularList(this._getCorrectBufferLength(this._terminal.rows));
                    this.scrollTop = 0;
                    this.scrollBottom = this._terminal.rows - 1;
                    this.setupTabStops();
                };
                Buffer.prototype.resize = function (newCols, newRows) {
                    var newMaxLength = this._getCorrectBufferLength(newRows);
                    if (newMaxLength > this._lines.maxLength) {
                        this._lines.maxLength = newMaxLength;
                    }
                    if (this._lines.length > 0) {
                        if (this._terminal.cols < newCols) {
                            var ch = [this._terminal.defAttr, ' ', 1, 32];
                            for (var i = 0; i < this._lines.length; i++) {
                                while (this._lines.get(i).length < newCols) {
                                    this._lines.get(i).push(ch);
                                }
                            }
                        }
                        var addToY = 0;
                        if (this._terminal.rows < newRows) {
                            for (var y = this._terminal.rows; y < newRows; y++) {
                                if (this._lines.length < newRows + this.ybase) {
                                    if (this.ybase > 0 && this._lines.length <= this.ybase + this.y + addToY + 1) {
                                        this.ybase--;
                                        addToY++;
                                        if (this.ydisp > 0) {
                                            this.ydisp--;
                                        }
                                    } else {
                                        this._lines.push(this._terminal.blankLine(undefined, undefined, newCols));
                                    }
                                }
                            }
                        } else {
                            for (var y = this._terminal.rows; y > newRows; y--) {
                                if (this._lines.length > newRows + this.ybase) {
                                    if (this._lines.length > this.ybase + this.y + 1) {
                                        this._lines.pop();
                                    } else {
                                        this.ybase++;
                                        this.ydisp++;
                                    }
                                }
                            }
                        }
                        if (newMaxLength < this._lines.maxLength) {
                            var amountToTrim = this._lines.length - newMaxLength;
                            if (amountToTrim > 0) {
                                this._lines.trimStart(amountToTrim);
                                this.ybase = Math.max(this.ybase - amountToTrim, 0);
                                this.ydisp = Math.max(this.ydisp - amountToTrim, 0);
                            }
                            this._lines.maxLength = newMaxLength;
                        }
                        this.x = Math.min(this.x, newCols - 1);
                        this.y = Math.min(this.y, newRows - 1);
                        if (addToY) {
                            this.y += addToY;
                        }
                        this.savedY = Math.min(this.savedY, newRows - 1);
                        this.savedX = Math.min(this.savedX, newCols - 1);
                        this.scrollTop = 0;
                    }
                    this.scrollBottom = newRows - 1;
                };
                Buffer.prototype.translateBufferLineToString = function (lineIndex, trimRight, startCol, endCol) {
                    if (startCol === void 0) {
                        startCol = 0;
                    }
                    if (endCol === void 0) {
                        endCol = null;
                    }
                    var lineString = '';
                    var line = this.lines.get(lineIndex);
                    if (!line) {
                        return '';
                    }
                    var startIndex = startCol;
                    if (endCol === null) {
                        endCol = line.length;
                    }
                    var endIndex = endCol;
                    for (var i = 0; i < line.length; i++) {
                        var char = line[i];
                        lineString += char[exports.CHAR_DATA_CHAR_INDEX];
                        if (char[exports.CHAR_DATA_WIDTH_INDEX] === 0) {
                            if (startCol >= i) {
                                startIndex--;
                            }
                            if (endCol >= i) {
                                endIndex--;
                            }
                        } else {
                            if (char[exports.CHAR_DATA_CHAR_INDEX].length > 1) {
                                if (startCol > i) {
                                    startIndex += char[exports.CHAR_DATA_CHAR_INDEX].length - 1;
                                }
                                if (endCol > i) {
                                    endIndex += char[exports.CHAR_DATA_CHAR_INDEX].length - 1;
                                }
                            }
                        }
                    }
                    if (trimRight) {
                        var rightWhitespaceIndex = lineString.search(/\s+$/);
                        if (rightWhitespaceIndex !== -1) {
                            endIndex = Math.min(endIndex, rightWhitespaceIndex);
                        }
                        if (endIndex <= startIndex) {
                            return '';
                        }
                    }
                    return lineString.substring(startIndex, endIndex);
                };
                Buffer.prototype.setupTabStops = function (i) {
                    if (i != null) {
                        if (!this.tabs[i]) {
                            i = this.prevStop(i);
                        }
                    } else {
                        this.tabs = {};
                        i = 0;
                    }
                    for (; i < this._terminal.cols; i += this._terminal.options.tabStopWidth) {
                        this.tabs[i] = true;
                    }
                };
                Buffer.prototype.prevStop = function (x) {
                    if (x == null) {
                        x = this.x;
                    }
                    while (!this.tabs[--x] && x > 0) {}
                    return x >= this._terminal.cols ? this._terminal.cols - 1 : x < 0 ? 0 : x;
                };
                Buffer.prototype.nextStop = function (x) {
                    if (x == null) {
                        x = this.x;
                    }
                    while (!this.tabs[++x] && x < this._terminal.cols) {}
                    return x >= this._terminal.cols ? this._terminal.cols - 1 : x < 0 ? 0 : x;
                };
                return Buffer;
            }();
            exports.Buffer = Buffer;
        }, { "./utils/CircularList": 32 }], 2: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var Buffer_1 = require("./Buffer");
            var EventEmitter_1 = require("./EventEmitter");
            var BufferSet = function (_super) {
                __extends(BufferSet, _super);
                function BufferSet(_terminal) {
                    var _this = _super.call(this) || this;
                    _this._terminal = _terminal;
                    _this._normal = new Buffer_1.Buffer(_this._terminal, true);
                    _this._normal.fillViewportRows();
                    _this._alt = new Buffer_1.Buffer(_this._terminal, false);
                    _this._activeBuffer = _this._normal;
                    _this.setupTabStops();
                    return _this;
                }
                Object.defineProperty(BufferSet.prototype, "alt", {
                    get: function get() {
                        return this._alt;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BufferSet.prototype, "active", {
                    get: function get() {
                        return this._activeBuffer;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BufferSet.prototype, "normal", {
                    get: function get() {
                        return this._normal;
                    },
                    enumerable: true,
                    configurable: true
                });
                BufferSet.prototype.activateNormalBuffer = function () {
                    if (this._activeBuffer === this._normal) {
                        return;
                    }
                    this._alt.clear();
                    this._activeBuffer = this._normal;
                    this.emit('activate', {
                        activeBuffer: this._normal,
                        inactiveBuffer: this._alt
                    });
                };
                BufferSet.prototype.activateAltBuffer = function () {
                    if (this._activeBuffer === this._alt) {
                        return;
                    }
                    this._alt.fillViewportRows();
                    this._activeBuffer = this._alt;
                    this.emit('activate', {
                        activeBuffer: this._alt,
                        inactiveBuffer: this._normal
                    });
                };
                BufferSet.prototype.resize = function (newCols, newRows) {
                    this._normal.resize(newCols, newRows);
                    this._alt.resize(newCols, newRows);
                };
                BufferSet.prototype.setupTabStops = function (i) {
                    this._normal.setupTabStops(i);
                    this._alt.setupTabStops(i);
                };
                return BufferSet;
            }(EventEmitter_1.EventEmitter);
            exports.BufferSet = BufferSet;
        }, { "./Buffer": 1, "./EventEmitter": 7 }], 3: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.wcwidth = function (opts) {
                var COMBINING_BMP = [[0x0300, 0x036F], [0x0483, 0x0486], [0x0488, 0x0489], [0x0591, 0x05BD], [0x05BF, 0x05BF], [0x05C1, 0x05C2], [0x05C4, 0x05C5], [0x05C7, 0x05C7], [0x0600, 0x0603], [0x0610, 0x0615], [0x064B, 0x065E], [0x0670, 0x0670], [0x06D6, 0x06E4], [0x06E7, 0x06E8], [0x06EA, 0x06ED], [0x070F, 0x070F], [0x0711, 0x0711], [0x0730, 0x074A], [0x07A6, 0x07B0], [0x07EB, 0x07F3], [0x0901, 0x0902], [0x093C, 0x093C], [0x0941, 0x0948], [0x094D, 0x094D], [0x0951, 0x0954], [0x0962, 0x0963], [0x0981, 0x0981], [0x09BC, 0x09BC], [0x09C1, 0x09C4], [0x09CD, 0x09CD], [0x09E2, 0x09E3], [0x0A01, 0x0A02], [0x0A3C, 0x0A3C], [0x0A41, 0x0A42], [0x0A47, 0x0A48], [0x0A4B, 0x0A4D], [0x0A70, 0x0A71], [0x0A81, 0x0A82], [0x0ABC, 0x0ABC], [0x0AC1, 0x0AC5], [0x0AC7, 0x0AC8], [0x0ACD, 0x0ACD], [0x0AE2, 0x0AE3], [0x0B01, 0x0B01], [0x0B3C, 0x0B3C], [0x0B3F, 0x0B3F], [0x0B41, 0x0B43], [0x0B4D, 0x0B4D], [0x0B56, 0x0B56], [0x0B82, 0x0B82], [0x0BC0, 0x0BC0], [0x0BCD, 0x0BCD], [0x0C3E, 0x0C40], [0x0C46, 0x0C48], [0x0C4A, 0x0C4D], [0x0C55, 0x0C56], [0x0CBC, 0x0CBC], [0x0CBF, 0x0CBF], [0x0CC6, 0x0CC6], [0x0CCC, 0x0CCD], [0x0CE2, 0x0CE3], [0x0D41, 0x0D43], [0x0D4D, 0x0D4D], [0x0DCA, 0x0DCA], [0x0DD2, 0x0DD4], [0x0DD6, 0x0DD6], [0x0E31, 0x0E31], [0x0E34, 0x0E3A], [0x0E47, 0x0E4E], [0x0EB1, 0x0EB1], [0x0EB4, 0x0EB9], [0x0EBB, 0x0EBC], [0x0EC8, 0x0ECD], [0x0F18, 0x0F19], [0x0F35, 0x0F35], [0x0F37, 0x0F37], [0x0F39, 0x0F39], [0x0F71, 0x0F7E], [0x0F80, 0x0F84], [0x0F86, 0x0F87], [0x0F90, 0x0F97], [0x0F99, 0x0FBC], [0x0FC6, 0x0FC6], [0x102D, 0x1030], [0x1032, 0x1032], [0x1036, 0x1037], [0x1039, 0x1039], [0x1058, 0x1059], [0x1160, 0x11FF], [0x135F, 0x135F], [0x1712, 0x1714], [0x1732, 0x1734], [0x1752, 0x1753], [0x1772, 0x1773], [0x17B4, 0x17B5], [0x17B7, 0x17BD], [0x17C6, 0x17C6], [0x17C9, 0x17D3], [0x17DD, 0x17DD], [0x180B, 0x180D], [0x18A9, 0x18A9], [0x1920, 0x1922], [0x1927, 0x1928], [0x1932, 0x1932], [0x1939, 0x193B], [0x1A17, 0x1A18], [0x1B00, 0x1B03], [0x1B34, 0x1B34], [0x1B36, 0x1B3A], [0x1B3C, 0x1B3C], [0x1B42, 0x1B42], [0x1B6B, 0x1B73], [0x1DC0, 0x1DCA], [0x1DFE, 0x1DFF], [0x200B, 0x200F], [0x202A, 0x202E], [0x2060, 0x2063], [0x206A, 0x206F], [0x20D0, 0x20EF], [0x302A, 0x302F], [0x3099, 0x309A], [0xA806, 0xA806], [0xA80B, 0xA80B], [0xA825, 0xA826], [0xFB1E, 0xFB1E], [0xFE00, 0xFE0F], [0xFE20, 0xFE23], [0xFEFF, 0xFEFF], [0xFFF9, 0xFFFB]];
                var COMBINING_HIGH = [[0x10A01, 0x10A03], [0x10A05, 0x10A06], [0x10A0C, 0x10A0F], [0x10A38, 0x10A3A], [0x10A3F, 0x10A3F], [0x1D167, 0x1D169], [0x1D173, 0x1D182], [0x1D185, 0x1D18B], [0x1D1AA, 0x1D1AD], [0x1D242, 0x1D244], [0xE0001, 0xE0001], [0xE0020, 0xE007F], [0xE0100, 0xE01EF]];
                function bisearch(ucs, data) {
                    var min = 0;
                    var max = data.length - 1;
                    var mid;
                    if (ucs < data[0][0] || ucs > data[max][1]) {
                        return false;
                    }
                    while (max >= min) {
                        mid = min + max >> 1;
                        if (ucs > data[mid][1]) {
                            min = mid + 1;
                        } else if (ucs < data[mid][0]) {
                            max = mid - 1;
                        } else {
                            return true;
                        }
                    }
                    return false;
                }
                function wcwidthBMP(ucs) {
                    if (ucs === 0) {
                        return opts.nul;
                    }
                    if (ucs < 32 || ucs >= 0x7f && ucs < 0xa0) {
                        return opts.control;
                    }
                    if (bisearch(ucs, COMBINING_BMP)) {
                        return 0;
                    }
                    if (isWideBMP(ucs)) {
                        return 2;
                    }
                    return 1;
                }
                function isWideBMP(ucs) {
                    return ucs >= 0x1100 && (ucs <= 0x115f || ucs === 0x2329 || ucs === 0x232a || ucs >= 0x2e80 && ucs <= 0xa4cf && ucs !== 0x303f || ucs >= 0xac00 && ucs <= 0xd7a3 || ucs >= 0xf900 && ucs <= 0xfaff || ucs >= 0xfe10 && ucs <= 0xfe19 || ucs >= 0xfe30 && ucs <= 0xfe6f || ucs >= 0xff00 && ucs <= 0xff60 || ucs >= 0xffe0 && ucs <= 0xffe6);
                }
                function wcwidthHigh(ucs) {
                    if (bisearch(ucs, COMBINING_HIGH)) {
                        return 0;
                    }
                    if (ucs >= 0x20000 && ucs <= 0x2fffd || ucs >= 0x30000 && ucs <= 0x3fffd) {
                        return 2;
                    }
                    return 1;
                }
                var control = opts.control | 0;
                var table = null;
                function init_table() {
                    var CODEPOINTS = 65536;
                    var BITWIDTH = 2;
                    var ITEMSIZE = 32;
                    var CONTAINERSIZE = CODEPOINTS * BITWIDTH / ITEMSIZE;
                    var CODEPOINTS_PER_ITEM = ITEMSIZE / BITWIDTH;
                    table = typeof Uint32Array === 'undefined' ? new Array(CONTAINERSIZE) : new Uint32Array(CONTAINERSIZE);
                    for (var i = 0; i < CONTAINERSIZE; ++i) {
                        var num = 0;
                        var pos = CODEPOINTS_PER_ITEM;
                        while (pos--) {
                            num = num << 2 | wcwidthBMP(CODEPOINTS_PER_ITEM * i + pos);
                        }
                        table[i] = num;
                    }
                    return table;
                }
                return function (num) {
                    num = num | 0;
                    if (num < 32) {
                        return control | 0;
                    }
                    if (num < 127) {
                        return 1;
                    }
                    var t = table || init_table();
                    if (num < 65536) {
                        return t[num >> 4] >> ((num & 15) << 1) & 3;
                    }
                    return wcwidthHigh(num);
                };
            }({ nul: 0, control: 0 });
        }, {}], 4: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.CHARSETS = {};
            exports.DEFAULT_CHARSET = exports.CHARSETS['B'];
            exports.CHARSETS['0'] = {
                '`': "\u25C6",
                'a': "\u2592",
                'b': "\t",
                'c': "\f",
                'd': "\r",
                'e': "\n",
                'f': "\xB0",
                'g': "\xB1",
                'h': "\u2424",
                'i': "\x0B",
                'j': "\u2518",
                'k': "\u2510",
                'l': "\u250C",
                'm': "\u2514",
                'n': "\u253C",
                'o': "\u23BA",
                'p': "\u23BB",
                'q': "\u2500",
                'r': "\u23BC",
                's': "\u23BD",
                't': "\u251C",
                'u': "\u2524",
                'v': "\u2534",
                'w': "\u252C",
                'x': "\u2502",
                'y': "\u2264",
                'z': "\u2265",
                '{': "\u03C0",
                '|': "\u2260",
                '}': "\xA3",
                '~': "\xB7"
            };
            exports.CHARSETS['A'] = {
                '#': '£'
            };
            exports.CHARSETS['B'] = null;
            exports.CHARSETS['4'] = {
                '#': '£',
                '@': '¾',
                '[': 'ij',
                '\\': '½',
                ']': '|',
                '{': '¨',
                '|': 'f',
                '}': '¼',
                '~': '´'
            };
            exports.CHARSETS['C'] = exports.CHARSETS['5'] = {
                '[': 'Ä',
                '\\': 'Ö',
                ']': 'Å',
                '^': 'Ü',
                '`': 'é',
                '{': 'ä',
                '|': 'ö',
                '}': 'å',
                '~': 'ü'
            };
            exports.CHARSETS['R'] = {
                '#': '£',
                '@': 'à',
                '[': '°',
                '\\': 'ç',
                ']': '§',
                '{': 'é',
                '|': 'ù',
                '}': 'è',
                '~': '¨'
            };
            exports.CHARSETS['Q'] = {
                '@': 'à',
                '[': 'â',
                '\\': 'ç',
                ']': 'ê',
                '^': 'î',
                '`': 'ô',
                '{': 'é',
                '|': 'ù',
                '}': 'è',
                '~': 'û'
            };
            exports.CHARSETS['K'] = {
                '@': '§',
                '[': 'Ä',
                '\\': 'Ö',
                ']': 'Ü',
                '{': 'ä',
                '|': 'ö',
                '}': 'ü',
                '~': 'ß'
            };
            exports.CHARSETS['Y'] = {
                '#': '£',
                '@': '§',
                '[': '°',
                '\\': 'ç',
                ']': 'é',
                '`': 'ù',
                '{': 'à',
                '|': 'ò',
                '}': 'è',
                '~': 'ì'
            };
            exports.CHARSETS['E'] = exports.CHARSETS['6'] = {
                '@': 'Ä',
                '[': 'Æ',
                '\\': 'Ø',
                ']': 'Å',
                '^': 'Ü',
                '`': 'ä',
                '{': 'æ',
                '|': 'ø',
                '}': 'å',
                '~': 'ü'
            };
            exports.CHARSETS['Z'] = {
                '#': '£',
                '@': '§',
                '[': '¡',
                '\\': 'Ñ',
                ']': '¿',
                '{': '°',
                '|': 'ñ',
                '}': 'ç'
            };
            exports.CHARSETS['H'] = exports.CHARSETS['7'] = {
                '@': 'É',
                '[': 'Ä',
                '\\': 'Ö',
                ']': 'Å',
                '^': 'Ü',
                '`': 'é',
                '{': 'ä',
                '|': 'ö',
                '}': 'å',
                '~': 'ü'
            };
            exports.CHARSETS['='] = {
                '#': 'ù',
                '@': 'à',
                '[': 'é',
                '\\': 'ç',
                ']': 'ê',
                '^': 'î',
                '_': 'è',
                '`': 'ô',
                '{': 'ä',
                '|': 'ö',
                '}': 'ü',
                '~': 'û'
            };
        }, {}], 5: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var CompositionHelper = function () {
                function CompositionHelper(textarea, compositionView, terminal) {
                    this.textarea = textarea;
                    this.compositionView = compositionView;
                    this.terminal = terminal;
                    this.isComposing = false;
                    this.isSendingComposition = false;
                    this.compositionPosition = { start: null, end: null };
                }
                CompositionHelper.prototype.compositionstart = function () {
                    this.isComposing = true;
                    this.compositionPosition.start = this.textarea.value.length;
                    this.compositionView.textContent = '';
                    this.compositionView.classList.add('active');
                };
                CompositionHelper.prototype.compositionupdate = function (ev) {
                    var _this = this;
                    this.compositionView.textContent = ev.data;
                    this.updateCompositionElements();
                    setTimeout(function () {
                        _this.compositionPosition.end = _this.textarea.value.length;
                    }, 0);
                };
                CompositionHelper.prototype.compositionend = function () {
                    this.finalizeComposition(true);
                };
                CompositionHelper.prototype.keydown = function (ev) {
                    if (this.isComposing || this.isSendingComposition) {
                        if (ev.keyCode === 229) {
                            return false;
                        } else if (ev.keyCode === 16 || ev.keyCode === 17 || ev.keyCode === 18) {
                            return false;
                        } else {
                            this.finalizeComposition(false);
                        }
                    }
                    if (ev.keyCode === 229) {
                        this.handleAnyTextareaChanges();
                        return false;
                    }
                    return true;
                };
                CompositionHelper.prototype.finalizeComposition = function (waitForPropogation) {
                    var _this = this;
                    this.compositionView.classList.remove('active');
                    this.isComposing = false;
                    this.clearTextareaPosition();
                    if (!waitForPropogation) {
                        this.isSendingComposition = false;
                        var input = this.textarea.value.substring(this.compositionPosition.start, this.compositionPosition.end);
                        this.terminal.handler(input);
                    } else {
                        var currentCompositionPosition_1 = {
                            start: this.compositionPosition.start,
                            end: this.compositionPosition.end
                        };
                        this.isSendingComposition = true;
                        setTimeout(function () {
                            if (_this.isSendingComposition) {
                                _this.isSendingComposition = false;
                                var input = void 0;
                                if (_this.isComposing) {
                                    input = _this.textarea.value.substring(currentCompositionPosition_1.start, currentCompositionPosition_1.end);
                                } else {
                                    input = _this.textarea.value.substring(currentCompositionPosition_1.start);
                                }
                                _this.terminal.handler(input);
                            }
                        }, 0);
                    }
                };
                CompositionHelper.prototype.handleAnyTextareaChanges = function () {
                    var _this = this;
                    var oldValue = this.textarea.value;
                    setTimeout(function () {
                        if (!_this.isComposing) {
                            var newValue = _this.textarea.value;
                            var diff = newValue.replace(oldValue, '');
                            if (diff.length > 0) {
                                _this.terminal.handler(diff);
                            }
                        }
                    }, 0);
                };
                CompositionHelper.prototype.updateCompositionElements = function (dontRecurse) {
                    var _this = this;
                    if (!this.isComposing) {
                        return;
                    }
                    if (this.terminal.buffer.isCursorInViewport) {
                        var cellHeight = Math.ceil(this.terminal.charMeasure.height * this.terminal.options.lineHeight);
                        var cursorTop = this.terminal.buffer.y * cellHeight;
                        var cursorLeft = this.terminal.buffer.x * this.terminal.charMeasure.width;
                        this.compositionView.style.left = cursorLeft + 'px';
                        this.compositionView.style.top = cursorTop + 'px';
                        this.compositionView.style.height = cellHeight + 'px';
                        this.compositionView.style.lineHeight = cellHeight + 'px';
                        var compositionViewBounds = this.compositionView.getBoundingClientRect();
                        this.textarea.style.left = cursorLeft + 'px';
                        this.textarea.style.top = cursorTop + 'px';
                        this.textarea.style.width = compositionViewBounds.width + 'px';
                        this.textarea.style.height = compositionViewBounds.height + 'px';
                        this.textarea.style.lineHeight = compositionViewBounds.height + 'px';
                    }
                    if (!dontRecurse) {
                        setTimeout(function () {
                            return _this.updateCompositionElements(true);
                        }, 0);
                    }
                };
                CompositionHelper.prototype.clearTextareaPosition = function () {
                    this.textarea.style.left = '';
                    this.textarea.style.top = '';
                };
                return CompositionHelper;
            }();
            exports.CompositionHelper = CompositionHelper;
        }, {}], 6: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var C0;
            (function (C0) {
                C0.NUL = '\x00';
                C0.SOH = '\x01';
                C0.STX = '\x02';
                C0.ETX = '\x03';
                C0.EOT = '\x04';
                C0.ENQ = '\x05';
                C0.ACK = '\x06';
                C0.BEL = '\x07';
                C0.BS = '\x08';
                C0.HT = '\x09';
                C0.LF = '\x0a';
                C0.VT = '\x0b';
                C0.FF = '\x0c';
                C0.CR = '\x0d';
                C0.SO = '\x0e';
                C0.SI = '\x0f';
                C0.DLE = '\x10';
                C0.DC1 = '\x11';
                C0.DC2 = '\x12';
                C0.DC3 = '\x13';
                C0.DC4 = '\x14';
                C0.NAK = '\x15';
                C0.SYN = '\x16';
                C0.ETB = '\x17';
                C0.CAN = '\x18';
                C0.EM = '\x19';
                C0.SUB = '\x1a';
                C0.ESC = '\x1b';
                C0.FS = '\x1c';
                C0.GS = '\x1d';
                C0.RS = '\x1e';
                C0.US = '\x1f';
                C0.SP = '\x20';
                C0.DEL = '\x7f';
            })(C0 = exports.C0 || (exports.C0 = {}));
        }, {}], 7: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var EventEmitter = function () {
                function EventEmitter() {
                    this._events = this._events || {};
                }
                EventEmitter.prototype.on = function (type, listener) {
                    this._events[type] = this._events[type] || [];
                    this._events[type].push(listener);
                };
                EventEmitter.prototype.off = function (type, listener) {
                    if (!this._events[type]) {
                        return;
                    }
                    var obj = this._events[type];
                    var i = obj.length;
                    while (i--) {
                        if (obj[i] === listener) {
                            obj.splice(i, 1);
                            return;
                        }
                    }
                };
                EventEmitter.prototype.removeAllListeners = function (type) {
                    if (this._events[type]) {
                        delete this._events[type];
                    }
                };
                EventEmitter.prototype.emit = function (type) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    if (!this._events[type]) {
                        return;
                    }
                    var obj = this._events[type];
                    for (var i = 0; i < obj.length; i++) {
                        obj[i].apply(this, args);
                    }
                };
                EventEmitter.prototype.listeners = function (type) {
                    return this._events[type] || [];
                };
                EventEmitter.prototype.destroy = function () {
                    this._events = {};
                };
                return EventEmitter;
            }();
            exports.EventEmitter = EventEmitter;
        }, {}], 8: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var EscapeSequences_1 = require("./EscapeSequences");
            var Charsets_1 = require("./Charsets");
            var Buffer_1 = require("./Buffer");
            var Types_1 = require("./renderer/Types");
            var CharWidth_1 = require("./CharWidth");
            var InputHandler = function () {
                function InputHandler(_terminal) {
                    this._terminal = _terminal;
                }
                InputHandler.prototype.addChar = function (char, code) {
                    if (char >= ' ') {
                        var chWidth = CharWidth_1.wcwidth(code);
                        if (this._terminal.charset && this._terminal.charset[char]) {
                            char = this._terminal.charset[char];
                        }
                        var row = this._terminal.buffer.y + this._terminal.buffer.ybase;
                        if (!chWidth && this._terminal.buffer.x) {
                            if (this._terminal.buffer.lines.get(row)[this._terminal.buffer.x - 1]) {
                                if (!this._terminal.buffer.lines.get(row)[this._terminal.buffer.x - 1][Buffer_1.CHAR_DATA_WIDTH_INDEX]) {
                                    if (this._terminal.buffer.lines.get(row)[this._terminal.buffer.x - 2]) {
                                        this._terminal.buffer.lines.get(row)[this._terminal.buffer.x - 2][Buffer_1.CHAR_DATA_CHAR_INDEX] += char;
                                        this._terminal.buffer.lines.get(row)[this._terminal.buffer.x - 2][3] = char.charCodeAt(0);
                                    }
                                } else {
                                    this._terminal.buffer.lines.get(row)[this._terminal.buffer.x - 1][Buffer_1.CHAR_DATA_CHAR_INDEX] += char;
                                    this._terminal.buffer.lines.get(row)[this._terminal.buffer.x - 1][3] = char.charCodeAt(0);
                                }
                                this._terminal.updateRange(this._terminal.buffer.y);
                            }
                            return;
                        }
                        if (this._terminal.buffer.x + chWidth - 1 >= this._terminal.cols) {
                            if (this._terminal.wraparoundMode) {
                                this._terminal.buffer.x = 0;
                                this._terminal.buffer.y++;
                                if (this._terminal.buffer.y > this._terminal.buffer.scrollBottom) {
                                    this._terminal.buffer.y--;
                                    this._terminal.scroll(true);
                                } else {
                                    this._terminal.buffer.lines.get(this._terminal.buffer.y).isWrapped = true;
                                }
                            } else {
                                if (chWidth === 2) {
                                    return;
                                }
                            }
                        }
                        row = this._terminal.buffer.y + this._terminal.buffer.ybase;
                        if (this._terminal.insertMode) {
                            for (var moves = 0; moves < chWidth; ++moves) {
                                var removed = this._terminal.buffer.lines.get(this._terminal.buffer.y + this._terminal.buffer.ybase).pop();
                                if (removed[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0 && this._terminal.buffer.lines.get(row)[this._terminal.cols - 2] && this._terminal.buffer.lines.get(row)[this._terminal.cols - 2][Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                                    this._terminal.buffer.lines.get(row)[this._terminal.cols - 2] = [this._terminal.curAttr, ' ', 1, ' '.charCodeAt(0)];
                                }
                                this._terminal.buffer.lines.get(row).splice(this._terminal.buffer.x, 0, [this._terminal.curAttr, ' ', 1, ' '.charCodeAt(0)]);
                            }
                        }
                        this._terminal.buffer.lines.get(row)[this._terminal.buffer.x] = [this._terminal.curAttr, char, chWidth, char.charCodeAt(0)];
                        this._terminal.buffer.x++;
                        this._terminal.updateRange(this._terminal.buffer.y);
                        if (chWidth === 2) {
                            this._terminal.buffer.lines.get(row)[this._terminal.buffer.x] = [this._terminal.curAttr, '', 0, undefined];
                            this._terminal.buffer.x++;
                        }
                    }
                };
                InputHandler.prototype.bell = function () {
                    this._terminal.bell();
                };
                InputHandler.prototype.lineFeed = function () {
                    if (this._terminal.convertEol) {
                        this._terminal.buffer.x = 0;
                    }
                    this._terminal.buffer.y++;
                    if (this._terminal.buffer.y > this._terminal.buffer.scrollBottom) {
                        this._terminal.buffer.y--;
                        this._terminal.scroll();
                    }
                    if (this._terminal.buffer.x >= this._terminal.cols) {
                        this._terminal.buffer.x--;
                    }
                    this._terminal.emit('linefeed');
                };
                InputHandler.prototype.carriageReturn = function () {
                    this._terminal.buffer.x = 0;
                };
                InputHandler.prototype.backspace = function () {
                    if (this._terminal.buffer.x > 0) {
                        this._terminal.buffer.x--;
                    }
                };
                InputHandler.prototype.tab = function () {
                    this._terminal.buffer.x = this._terminal.buffer.nextStop();
                };
                InputHandler.prototype.shiftOut = function () {
                    this._terminal.setgLevel(1);
                };
                InputHandler.prototype.shiftIn = function () {
                    this._terminal.setgLevel(0);
                };
                InputHandler.prototype.insertChars = function (params) {
                    var param = params[0];
                    if (param < 1) param = 1;
                    var row = this._terminal.buffer.y + this._terminal.buffer.ybase;
                    var j = this._terminal.buffer.x;
                    var ch = [this._terminal.eraseAttr(), ' ', 1, 32];
                    while (param-- && j < this._terminal.cols) {
                        this._terminal.buffer.lines.get(row).splice(j++, 0, ch);
                        this._terminal.buffer.lines.get(row).pop();
                    }
                };
                InputHandler.prototype.cursorUp = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.y -= param;
                    if (this._terminal.buffer.y < 0) {
                        this._terminal.buffer.y = 0;
                    }
                };
                InputHandler.prototype.cursorDown = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.y += param;
                    if (this._terminal.buffer.y >= this._terminal.rows) {
                        this._terminal.buffer.y = this._terminal.rows - 1;
                    }
                    if (this._terminal.buffer.x >= this._terminal.cols) {
                        this._terminal.buffer.x--;
                    }
                };
                InputHandler.prototype.cursorForward = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.x += param;
                    if (this._terminal.buffer.x >= this._terminal.cols) {
                        this._terminal.buffer.x = this._terminal.cols - 1;
                    }
                };
                InputHandler.prototype.cursorBackward = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    if (this._terminal.buffer.x >= this._terminal.cols) {
                        this._terminal.buffer.x--;
                    }
                    this._terminal.buffer.x -= param;
                    if (this._terminal.buffer.x < 0) {
                        this._terminal.buffer.x = 0;
                    }
                };
                InputHandler.prototype.cursorNextLine = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.y += param;
                    if (this._terminal.buffer.y >= this._terminal.rows) {
                        this._terminal.buffer.y = this._terminal.rows - 1;
                    }
                    this._terminal.buffer.x = 0;
                };
                InputHandler.prototype.cursorPrecedingLine = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.y -= param;
                    if (this._terminal.buffer.y < 0) {
                        this._terminal.buffer.y = 0;
                    }
                    this._terminal.buffer.x = 0;
                };
                InputHandler.prototype.cursorCharAbsolute = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.x = param - 1;
                };
                InputHandler.prototype.cursorPosition = function (params) {
                    var col;
                    var row = params[0] - 1;
                    if (params.length >= 2) {
                        col = params[1] - 1;
                    } else {
                        col = 0;
                    }
                    if (row < 0) {
                        row = 0;
                    } else if (row >= this._terminal.rows) {
                        row = this._terminal.rows - 1;
                    }
                    if (col < 0) {
                        col = 0;
                    } else if (col >= this._terminal.cols) {
                        col = this._terminal.cols - 1;
                    }
                    this._terminal.buffer.x = col;
                    this._terminal.buffer.y = row;
                };
                InputHandler.prototype.cursorForwardTab = function (params) {
                    var param = params[0] || 1;
                    while (param--) {
                        this._terminal.buffer.x = this._terminal.buffer.nextStop();
                    }
                };
                InputHandler.prototype.eraseInDisplay = function (params) {
                    var j;
                    switch (params[0]) {
                        case 0:
                            this._terminal.eraseRight(this._terminal.buffer.x, this._terminal.buffer.y);
                            j = this._terminal.buffer.y + 1;
                            for (; j < this._terminal.rows; j++) {
                                this._terminal.eraseLine(j);
                            }
                            break;
                        case 1:
                            this._terminal.eraseLeft(this._terminal.buffer.x, this._terminal.buffer.y);
                            j = this._terminal.buffer.y;
                            while (j--) {
                                this._terminal.eraseLine(j);
                            }
                            break;
                        case 2:
                            j = this._terminal.rows;
                            while (j--) {
                                this._terminal.eraseLine(j);
                            }break;
                        case 3:
                            var scrollBackSize = this._terminal.buffer.lines.length - this._terminal.rows;
                            if (scrollBackSize > 0) {
                                this._terminal.buffer.lines.trimStart(scrollBackSize);
                                this._terminal.buffer.ybase = Math.max(this._terminal.buffer.ybase - scrollBackSize, 0);
                                this._terminal.buffer.ydisp = Math.max(this._terminal.buffer.ydisp - scrollBackSize, 0);
                                this._terminal.emit('scroll', 0);
                            }
                            break;
                    }
                };
                InputHandler.prototype.eraseInLine = function (params) {
                    switch (params[0]) {
                        case 0:
                            this._terminal.eraseRight(this._terminal.buffer.x, this._terminal.buffer.y);
                            break;
                        case 1:
                            this._terminal.eraseLeft(this._terminal.buffer.x, this._terminal.buffer.y);
                            break;
                        case 2:
                            this._terminal.eraseLine(this._terminal.buffer.y);
                            break;
                    }
                };
                InputHandler.prototype.insertLines = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    var row = this._terminal.buffer.y + this._terminal.buffer.ybase;
                    var scrollBottomRowsOffset = this._terminal.rows - 1 - this._terminal.buffer.scrollBottom;
                    var scrollBottomAbsolute = this._terminal.rows - 1 + this._terminal.buffer.ybase - scrollBottomRowsOffset + 1;
                    while (param--) {
                        this._terminal.buffer.lines.splice(scrollBottomAbsolute - 1, 1);
                        this._terminal.buffer.lines.splice(row, 0, this._terminal.blankLine(true));
                    }
                    this._terminal.updateRange(this._terminal.buffer.y);
                    this._terminal.updateRange(this._terminal.buffer.scrollBottom);
                };
                InputHandler.prototype.deleteLines = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    var row = this._terminal.buffer.y + this._terminal.buffer.ybase;
                    var j;
                    j = this._terminal.rows - 1 - this._terminal.buffer.scrollBottom;
                    j = this._terminal.rows - 1 + this._terminal.buffer.ybase - j;
                    while (param--) {
                        this._terminal.buffer.lines.splice(row, 1);
                        this._terminal.buffer.lines.splice(j, 0, this._terminal.blankLine(true));
                    }
                    this._terminal.updateRange(this._terminal.buffer.y);
                    this._terminal.updateRange(this._terminal.buffer.scrollBottom);
                };
                InputHandler.prototype.deleteChars = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    var row = this._terminal.buffer.y + this._terminal.buffer.ybase;
                    var ch = [this._terminal.eraseAttr(), ' ', 1, 32];
                    while (param--) {
                        this._terminal.buffer.lines.get(row).splice(this._terminal.buffer.x, 1);
                        this._terminal.buffer.lines.get(row).push(ch);
                    }
                    this._terminal.updateRange(this._terminal.buffer.y);
                };
                InputHandler.prototype.scrollUp = function (params) {
                    var param = params[0] || 1;
                    while (param--) {
                        this._terminal.buffer.lines.splice(this._terminal.buffer.ybase + this._terminal.buffer.scrollTop, 1);
                        this._terminal.buffer.lines.splice(this._terminal.buffer.ybase + this._terminal.buffer.scrollBottom, 0, this._terminal.blankLine());
                    }
                    this._terminal.updateRange(this._terminal.buffer.scrollTop);
                    this._terminal.updateRange(this._terminal.buffer.scrollBottom);
                };
                InputHandler.prototype.scrollDown = function (params) {
                    var param = params[0] || 1;
                    while (param--) {
                        this._terminal.buffer.lines.splice(this._terminal.buffer.ybase + this._terminal.buffer.scrollBottom, 1);
                        this._terminal.buffer.lines.splice(this._terminal.buffer.ybase + this._terminal.buffer.scrollTop, 0, this._terminal.blankLine());
                    }
                    this._terminal.updateRange(this._terminal.buffer.scrollTop);
                    this._terminal.updateRange(this._terminal.buffer.scrollBottom);
                };
                InputHandler.prototype.eraseChars = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    var row = this._terminal.buffer.y + this._terminal.buffer.ybase;
                    var j = this._terminal.buffer.x;
                    var ch = [this._terminal.eraseAttr(), ' ', 1, 32];
                    while (param-- && j < this._terminal.cols) {
                        this._terminal.buffer.lines.get(row)[j++] = ch;
                    }
                };
                InputHandler.prototype.cursorBackwardTab = function (params) {
                    var param = params[0] || 1;
                    while (param--) {
                        this._terminal.buffer.x = this._terminal.buffer.prevStop();
                    }
                };
                InputHandler.prototype.charPosAbsolute = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.x = param - 1;
                    if (this._terminal.buffer.x >= this._terminal.cols) {
                        this._terminal.buffer.x = this._terminal.cols - 1;
                    }
                };
                InputHandler.prototype.HPositionRelative = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.x += param;
                    if (this._terminal.buffer.x >= this._terminal.cols) {
                        this._terminal.buffer.x = this._terminal.cols - 1;
                    }
                };
                InputHandler.prototype.repeatPrecedingCharacter = function (params) {
                    var param = params[0] || 1;
                    var line = this._terminal.buffer.lines.get(this._terminal.buffer.ybase + this._terminal.buffer.y);
                    var ch = line[this._terminal.buffer.x - 1] || [this._terminal.defAttr, ' ', 1, 32];
                    while (param--) {
                        line[this._terminal.buffer.x++] = ch;
                    }
                };
                InputHandler.prototype.sendDeviceAttributes = function (params) {
                    if (params[0] > 0) {
                        return;
                    }
                    if (!this._terminal.prefix) {
                        if (this._terminal.is('xterm') || this._terminal.is('rxvt-unicode') || this._terminal.is('screen')) {
                            this._terminal.send(EscapeSequences_1.C0.ESC + '[?1;2c');
                        } else if (this._terminal.is('linux')) {
                            this._terminal.send(EscapeSequences_1.C0.ESC + '[?6c');
                        }
                    } else if (this._terminal.prefix === '>') {
                        if (this._terminal.is('xterm')) {
                            this._terminal.send(EscapeSequences_1.C0.ESC + '[>0;276;0c');
                        } else if (this._terminal.is('rxvt-unicode')) {
                            this._terminal.send(EscapeSequences_1.C0.ESC + '[>85;95;0c');
                        } else if (this._terminal.is('linux')) {
                            this._terminal.send(params[0] + 'c');
                        } else if (this._terminal.is('screen')) {
                            this._terminal.send(EscapeSequences_1.C0.ESC + '[>83;40003;0c');
                        }
                    }
                };
                InputHandler.prototype.linePosAbsolute = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.y = param - 1;
                    if (this._terminal.buffer.y >= this._terminal.rows) {
                        this._terminal.buffer.y = this._terminal.rows - 1;
                    }
                };
                InputHandler.prototype.VPositionRelative = function (params) {
                    var param = params[0];
                    if (param < 1) {
                        param = 1;
                    }
                    this._terminal.buffer.y += param;
                    if (this._terminal.buffer.y >= this._terminal.rows) {
                        this._terminal.buffer.y = this._terminal.rows - 1;
                    }
                    if (this._terminal.buffer.x >= this._terminal.cols) {
                        this._terminal.buffer.x--;
                    }
                };
                InputHandler.prototype.HVPosition = function (params) {
                    if (params[0] < 1) params[0] = 1;
                    if (params[1] < 1) params[1] = 1;
                    this._terminal.buffer.y = params[0] - 1;
                    if (this._terminal.buffer.y >= this._terminal.rows) {
                        this._terminal.buffer.y = this._terminal.rows - 1;
                    }
                    this._terminal.buffer.x = params[1] - 1;
                    if (this._terminal.buffer.x >= this._terminal.cols) {
                        this._terminal.buffer.x = this._terminal.cols - 1;
                    }
                };
                InputHandler.prototype.tabClear = function (params) {
                    var param = params[0];
                    if (param <= 0) {
                        delete this._terminal.buffer.tabs[this._terminal.buffer.x];
                    } else if (param === 3) {
                        this._terminal.buffer.tabs = {};
                    }
                };
                InputHandler.prototype.setMode = function (params) {
                    if (params.length > 1) {
                        for (var i = 0; i < params.length; i++) {
                            this.setMode([params[i]]);
                        }
                        return;
                    }
                    if (!this._terminal.prefix) {
                        switch (params[0]) {
                            case 4:
                                this._terminal.insertMode = true;
                                break;
                            case 20:
                                break;
                        }
                    } else if (this._terminal.prefix === '?') {
                        switch (params[0]) {
                            case 1:
                                this._terminal.applicationCursor = true;
                                break;
                            case 2:
                                this._terminal.setgCharset(0, Charsets_1.DEFAULT_CHARSET);
                                this._terminal.setgCharset(1, Charsets_1.DEFAULT_CHARSET);
                                this._terminal.setgCharset(2, Charsets_1.DEFAULT_CHARSET);
                                this._terminal.setgCharset(3, Charsets_1.DEFAULT_CHARSET);
                                break;
                            case 3:
                                this._terminal.savedCols = this._terminal.cols;
                                this._terminal.resize(132, this._terminal.rows);
                                break;
                            case 6:
                                this._terminal.originMode = true;
                                break;
                            case 7:
                                this._terminal.wraparoundMode = true;
                                break;
                            case 12:
                                break;
                            case 66:
                                this._terminal.log('Serial port requested application keypad.');
                                this._terminal.applicationKeypad = true;
                                this._terminal.viewport.syncScrollArea();
                                break;
                            case 9:
                            case 1000:
                            case 1002:
                            case 1003:
                                this._terminal.x10Mouse = params[0] === 9;
                                this._terminal.vt200Mouse = params[0] === 1000;
                                this._terminal.normalMouse = params[0] > 1000;
                                this._terminal.mouseEvents = true;
                                this._terminal.element.classList.add('enable-mouse-events');
                                this._terminal.selectionManager.disable();
                                this._terminal.log('Binding to mouse events.');
                                break;
                            case 1004:
                                this._terminal.sendFocus = true;
                                break;
                            case 1005:
                                this._terminal.utfMouse = true;
                                break;
                            case 1006:
                                this._terminal.sgrMouse = true;
                                break;
                            case 1015:
                                this._terminal.urxvtMouse = true;
                                break;
                            case 25:
                                this._terminal.cursorHidden = false;
                                break;
                            case 1049:
                            case 47:
                            case 1047:
                                this._terminal.buffers.activateAltBuffer();
                                this._terminal.viewport.syncScrollArea();
                                this._terminal.showCursor();
                                break;
                            case 2004:
                                this._terminal.bracketedPasteMode = true;
                                break;
                        }
                    }
                };
                InputHandler.prototype.resetMode = function (params) {
                    if (params.length > 1) {
                        for (var i = 0; i < params.length; i++) {
                            this.resetMode([params[i]]);
                        }
                        return;
                    }
                    if (!this._terminal.prefix) {
                        switch (params[0]) {
                            case 4:
                                this._terminal.insertMode = false;
                                break;
                            case 20:
                                break;
                        }
                    } else if (this._terminal.prefix === '?') {
                        switch (params[0]) {
                            case 1:
                                this._terminal.applicationCursor = false;
                                break;
                            case 3:
                                if (this._terminal.cols === 132 && this._terminal.savedCols) {
                                    this._terminal.resize(this._terminal.savedCols, this._terminal.rows);
                                }
                                delete this._terminal.savedCols;
                                break;
                            case 6:
                                this._terminal.originMode = false;
                                break;
                            case 7:
                                this._terminal.wraparoundMode = false;
                                break;
                            case 12:
                                break;
                            case 66:
                                this._terminal.log('Switching back to normal keypad.');
                                this._terminal.applicationKeypad = false;
                                this._terminal.viewport.syncScrollArea();
                                break;
                            case 9:
                            case 1000:
                            case 1002:
                            case 1003:
                                this._terminal.x10Mouse = false;
                                this._terminal.vt200Mouse = false;
                                this._terminal.normalMouse = false;
                                this._terminal.mouseEvents = false;
                                this._terminal.element.classList.remove('enable-mouse-events');
                                this._terminal.selectionManager.enable();
                                break;
                            case 1004:
                                this._terminal.sendFocus = false;
                                break;
                            case 1005:
                                this._terminal.utfMouse = false;
                                break;
                            case 1006:
                                this._terminal.sgrMouse = false;
                                break;
                            case 1015:
                                this._terminal.urxvtMouse = false;
                                break;
                            case 25:
                                this._terminal.cursorHidden = true;
                                break;
                            case 1049:
                            case 47:
                            case 1047:
                                this._terminal.buffers.activateNormalBuffer();
                                this._terminal.refresh(0, this._terminal.rows - 1);
                                this._terminal.viewport.syncScrollArea();
                                this._terminal.showCursor();
                                break;
                            case 2004:
                                this._terminal.bracketedPasteMode = false;
                                break;
                        }
                    }
                };
                InputHandler.prototype.charAttributes = function (params) {
                    if (params.length === 1 && params[0] === 0) {
                        this._terminal.curAttr = this._terminal.defAttr;
                        return;
                    }
                    var l = params.length;
                    var flags = this._terminal.curAttr >> 18;
                    var fg = this._terminal.curAttr >> 9 & 0x1ff;
                    var bg = this._terminal.curAttr & 0x1ff;
                    var p;
                    for (var i = 0; i < l; i++) {
                        p = params[i];
                        if (p >= 30 && p <= 37) {
                            fg = p - 30;
                        } else if (p >= 40 && p <= 47) {
                            bg = p - 40;
                        } else if (p >= 90 && p <= 97) {
                            p += 8;
                            fg = p - 90;
                        } else if (p >= 100 && p <= 107) {
                            p += 8;
                            bg = p - 100;
                        } else if (p === 0) {
                            flags = this._terminal.defAttr >> 18;
                            fg = this._terminal.defAttr >> 9 & 0x1ff;
                            bg = this._terminal.defAttr & 0x1ff;
                        } else if (p === 1) {
                            flags |= Types_1.FLAGS.BOLD;
                        } else if (p === 4) {
                            flags |= Types_1.FLAGS.UNDERLINE;
                        } else if (p === 5) {
                            flags |= Types_1.FLAGS.BLINK;
                        } else if (p === 7) {
                            flags |= Types_1.FLAGS.INVERSE;
                        } else if (p === 8) {
                            flags |= Types_1.FLAGS.INVISIBLE;
                        } else if (p === 2) {
                            flags |= Types_1.FLAGS.DIM;
                        } else if (p === 22) {
                            flags &= ~Types_1.FLAGS.BOLD;
                            flags &= ~Types_1.FLAGS.DIM;
                        } else if (p === 24) {
                            flags &= ~Types_1.FLAGS.UNDERLINE;
                        } else if (p === 25) {
                            flags &= ~Types_1.FLAGS.BLINK;
                        } else if (p === 27) {
                            flags &= ~Types_1.FLAGS.INVERSE;
                        } else if (p === 28) {
                            flags &= ~Types_1.FLAGS.INVISIBLE;
                        } else if (p === 39) {
                            fg = this._terminal.defAttr >> 9 & 0x1ff;
                        } else if (p === 49) {
                            bg = this._terminal.defAttr & 0x1ff;
                        } else if (p === 38) {
                            if (params[i + 1] === 2) {
                                i += 2;
                                fg = this._terminal.matchColor(params[i] & 0xff, params[i + 1] & 0xff, params[i + 2] & 0xff);
                                if (fg === -1) fg = 0x1ff;
                                i += 2;
                            } else if (params[i + 1] === 5) {
                                i += 2;
                                p = params[i] & 0xff;
                                fg = p;
                            }
                        } else if (p === 48) {
                            if (params[i + 1] === 2) {
                                i += 2;
                                bg = this._terminal.matchColor(params[i] & 0xff, params[i + 1] & 0xff, params[i + 2] & 0xff);
                                if (bg === -1) bg = 0x1ff;
                                i += 2;
                            } else if (params[i + 1] === 5) {
                                i += 2;
                                p = params[i] & 0xff;
                                bg = p;
                            }
                        } else if (p === 100) {
                            fg = this._terminal.defAttr >> 9 & 0x1ff;
                            bg = this._terminal.defAttr & 0x1ff;
                        } else {
                            this._terminal.error('Unknown SGR attribute: %d.', p);
                        }
                    }
                    this._terminal.curAttr = flags << 18 | fg << 9 | bg;
                };
                InputHandler.prototype.deviceStatus = function (params) {
                    if (!this._terminal.prefix) {
                        switch (params[0]) {
                            case 5:
                                this._terminal.send(EscapeSequences_1.C0.ESC + '[0n');
                                break;
                            case 6:
                                this._terminal.send(EscapeSequences_1.C0.ESC + '[' + (this._terminal.buffer.y + 1) + ';' + (this._terminal.buffer.x + 1) + 'R');
                                break;
                        }
                    } else if (this._terminal.prefix === '?') {
                        switch (params[0]) {
                            case 6:
                                this._terminal.send(EscapeSequences_1.C0.ESC + '[?' + (this._terminal.buffer.y + 1) + ';' + (this._terminal.buffer.x + 1) + 'R');
                                break;
                            case 15:
                                break;
                            case 25:
                                break;
                            case 26:
                                break;
                            case 53:
                                break;
                        }
                    }
                };
                InputHandler.prototype.softReset = function (params) {
                    this._terminal.cursorHidden = false;
                    this._terminal.insertMode = false;
                    this._terminal.originMode = false;
                    this._terminal.wraparoundMode = true;
                    this._terminal.applicationKeypad = false;
                    this._terminal.viewport.syncScrollArea();
                    this._terminal.applicationCursor = false;
                    this._terminal.buffer.scrollTop = 0;
                    this._terminal.buffer.scrollBottom = this._terminal.rows - 1;
                    this._terminal.curAttr = this._terminal.defAttr;
                    this._terminal.buffer.x = this._terminal.buffer.y = 0;
                    this._terminal.charset = null;
                    this._terminal.glevel = 0;
                    this._terminal.charsets = [null];
                };
                InputHandler.prototype.setCursorStyle = function (params) {
                    var param = params[0] < 1 ? 1 : params[0];
                    switch (param) {
                        case 1:
                        case 2:
                            this._terminal.setOption('cursorStyle', 'block');
                            break;
                        case 3:
                        case 4:
                            this._terminal.setOption('cursorStyle', 'underline');
                            break;
                        case 5:
                        case 6:
                            this._terminal.setOption('cursorStyle', 'bar');
                            break;
                    }
                    var isBlinking = param % 2 === 1;
                    this._terminal.setOption('cursorBlink', isBlinking);
                };
                InputHandler.prototype.setScrollRegion = function (params) {
                    if (this._terminal.prefix) return;
                    this._terminal.buffer.scrollTop = (params[0] || 1) - 1;
                    this._terminal.buffer.scrollBottom = (params[1] && params[1] <= this._terminal.rows ? params[1] : this._terminal.rows) - 1;
                    this._terminal.buffer.x = 0;
                    this._terminal.buffer.y = 0;
                };
                InputHandler.prototype.saveCursor = function (params) {
                    this._terminal.buffer.savedX = this._terminal.buffer.x;
                    this._terminal.buffer.savedY = this._terminal.buffer.y;
                };
                InputHandler.prototype.restoreCursor = function (params) {
                    this._terminal.buffer.x = this._terminal.buffer.savedX || 0;
                    this._terminal.buffer.y = this._terminal.buffer.savedY || 0;
                };
                return InputHandler;
            }();
            exports.InputHandler = InputHandler;
        }, { "./Buffer": 1, "./CharWidth": 3, "./Charsets": 4, "./EscapeSequences": 6, "./renderer/Types": 28 }], 9: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var Types_1 = require("./Types");
            var MouseZoneManager_1 = require("./input/MouseZoneManager");
            var EventEmitter_1 = require("./EventEmitter");
            var protocolClause = '(https?:\\/\\/)';
            var domainCharacterSet = '[\\da-z\\.-]+';
            var negatedDomainCharacterSet = '[^\\da-z\\.-]+';
            var domainBodyClause = '(' + domainCharacterSet + ')';
            var tldClause = '([a-z\\.]{2,6})';
            var ipClause = '((\\d{1,3}\\.){3}\\d{1,3})';
            var localHostClause = '(localhost)';
            var portClause = '(:\\d{1,5})';
            var hostClause = '((' + domainBodyClause + '\\.' + tldClause + ')|' + ipClause + '|' + localHostClause + ')' + portClause + '?';
            var pathClause = '(\\/[\\/\\w\\.\\-%~]*)*';
            var queryStringHashFragmentCharacterSet = '[0-9\\w\\[\\]\\(\\)\\/\\?\\!#@$%&\'*+,:;~\\=\\.\\-]*';
            var queryStringClause = '(\\?' + queryStringHashFragmentCharacterSet + ')?';
            var hashFragmentClause = '(#' + queryStringHashFragmentCharacterSet + ')?';
            var negatedPathCharacterSet = '[^\\/\\w\\.\\-%]+';
            var bodyClause = hostClause + pathClause + queryStringClause + hashFragmentClause;
            var start = '(?:^|' + negatedDomainCharacterSet + ')(';
            var end = ')($|' + negatedPathCharacterSet + ')';
            var strictUrlRegex = new RegExp(start + protocolClause + bodyClause + end);
            var HYPERTEXT_LINK_MATCHER_ID = 0;
            var Linkifier = function (_super) {
                __extends(Linkifier, _super);
                function Linkifier(_terminal) {
                    var _this = _super.call(this) || this;
                    _this._terminal = _terminal;
                    _this._linkMatchers = [];
                    _this._nextLinkMatcherId = HYPERTEXT_LINK_MATCHER_ID;
                    _this._rowsToLinkify = {
                        start: null,
                        end: null
                    };
                    _this.registerLinkMatcher(strictUrlRegex, null, { matchIndex: 1 });
                    return _this;
                }
                Linkifier.prototype.attachToDom = function (mouseZoneManager) {
                    this._mouseZoneManager = mouseZoneManager;
                };
                Linkifier.prototype.linkifyRows = function (start, end) {
                    var _this = this;
                    if (!this._mouseZoneManager) {
                        return;
                    }
                    if (this._rowsToLinkify.start === null) {
                        this._rowsToLinkify.start = start;
                        this._rowsToLinkify.end = end;
                    } else {
                        this._rowsToLinkify.start = Math.min(this._rowsToLinkify.start, start);
                        this._rowsToLinkify.end = Math.max(this._rowsToLinkify.end, end);
                    }
                    this._mouseZoneManager.clearAll(start, end);
                    if (this._rowsTimeoutId) {
                        clearTimeout(this._rowsTimeoutId);
                    }
                    this._rowsTimeoutId = setTimeout(function () {
                        return _this._linkifyRows();
                    }, Linkifier.TIME_BEFORE_LINKIFY);
                };
                Linkifier.prototype._linkifyRows = function () {
                    this._rowsTimeoutId = null;
                    for (var i = this._rowsToLinkify.start; i <= this._rowsToLinkify.end; i++) {
                        this._linkifyRow(i);
                    }
                    this._rowsToLinkify.start = null;
                    this._rowsToLinkify.end = null;
                };
                Linkifier.prototype.setHypertextLinkHandler = function (handler) {
                    this._linkMatchers[HYPERTEXT_LINK_MATCHER_ID].handler = handler;
                };
                Linkifier.prototype.setHypertextValidationCallback = function (callback) {
                    this._linkMatchers[HYPERTEXT_LINK_MATCHER_ID].validationCallback = callback;
                };
                Linkifier.prototype.registerLinkMatcher = function (regex, handler, options) {
                    if (options === void 0) {
                        options = {};
                    }
                    if (this._nextLinkMatcherId !== HYPERTEXT_LINK_MATCHER_ID && !handler) {
                        throw new Error('handler must be defined');
                    }
                    var matcher = {
                        id: this._nextLinkMatcherId++,
                        regex: regex,
                        handler: handler,
                        matchIndex: options.matchIndex,
                        validationCallback: options.validationCallback,
                        hoverTooltipCallback: options.tooltipCallback,
                        hoverLeaveCallback: options.leaveCallback,
                        willLinkActivate: options.willLinkActivate,
                        priority: options.priority || 0
                    };
                    this._addLinkMatcherToList(matcher);
                    return matcher.id;
                };
                Linkifier.prototype._addLinkMatcherToList = function (matcher) {
                    if (this._linkMatchers.length === 0) {
                        this._linkMatchers.push(matcher);
                        return;
                    }
                    for (var i = this._linkMatchers.length - 1; i >= 0; i--) {
                        if (matcher.priority <= this._linkMatchers[i].priority) {
                            this._linkMatchers.splice(i + 1, 0, matcher);
                            return;
                        }
                    }
                    this._linkMatchers.splice(0, 0, matcher);
                };
                Linkifier.prototype.deregisterLinkMatcher = function (matcherId) {
                    for (var i = 1; i < this._linkMatchers.length; i++) {
                        if (this._linkMatchers[i].id === matcherId) {
                            this._linkMatchers.splice(i, 1);
                            return true;
                        }
                    }
                    return false;
                };
                Linkifier.prototype._linkifyRow = function (rowIndex) {
                    var absoluteRowIndex = this._terminal.buffer.ydisp + rowIndex;
                    if (absoluteRowIndex >= this._terminal.buffer.lines.length) {
                        return;
                    }
                    var text = this._terminal.buffer.translateBufferLineToString(absoluteRowIndex, false);
                    for (var i = 0; i < this._linkMatchers.length; i++) {
                        this._doLinkifyRow(rowIndex, text, this._linkMatchers[i]);
                    }
                };
                Linkifier.prototype._doLinkifyRow = function (rowIndex, text, matcher, offset) {
                    var _this = this;
                    if (offset === void 0) {
                        offset = 0;
                    }
                    var result = [];
                    var isHttpLinkMatcher = matcher.id === HYPERTEXT_LINK_MATCHER_ID;
                    var match = text.match(matcher.regex);
                    if (!match || match.length === 0) {
                        return;
                    }
                    var uri = match[typeof matcher.matchIndex !== 'number' ? 0 : matcher.matchIndex];
                    var index = text.indexOf(uri);
                    if (matcher.validationCallback) {
                        matcher.validationCallback(uri, function (isValid) {
                            if (_this._rowsTimeoutId) {
                                return;
                            }
                            if (isValid) {
                                _this._addLink(offset + index, rowIndex, uri, matcher);
                            }
                        });
                    } else {
                        this._addLink(offset + index, rowIndex, uri, matcher);
                    }
                    var remainingStartIndex = index + uri.length;
                    var remainingText = text.substr(remainingStartIndex);
                    if (remainingText.length > 0) {
                        this._doLinkifyRow(rowIndex, remainingText, matcher, offset + remainingStartIndex);
                    }
                };
                Linkifier.prototype._addLink = function (x, y, uri, matcher) {
                    var _this = this;
                    this._mouseZoneManager.add(new MouseZoneManager_1.MouseZone(x + 1, x + 1 + uri.length, y + 1, function (e) {
                        if (matcher.handler) {
                            return matcher.handler(e, uri);
                        }
                        window.open(uri, '_blank');
                    }, function (e) {
                        _this.emit(Types_1.LinkHoverEventTypes.HOVER, { x: x, y: y, length: uri.length });
                        _this._terminal.element.style.cursor = 'pointer';
                    }, function (e) {
                        _this.emit(Types_1.LinkHoverEventTypes.TOOLTIP, { x: x, y: y, length: uri.length });
                        if (matcher.hoverTooltipCallback) {
                            matcher.hoverTooltipCallback(e, uri);
                        }
                    }, function () {
                        _this.emit(Types_1.LinkHoverEventTypes.LEAVE, { x: x, y: y, length: uri.length });
                        _this._terminal.element.style.cursor = '';
                        if (matcher.hoverLeaveCallback) {
                            matcher.hoverLeaveCallback();
                        }
                    }, function (e) {
                        if (matcher.willLinkActivate) {
                            return matcher.willLinkActivate(e, uri);
                        }
                        return true;
                    }));
                };
                Linkifier.TIME_BEFORE_LINKIFY = 200;
                return Linkifier;
            }(EventEmitter_1.EventEmitter);
            exports.Linkifier = Linkifier;
        }, { "./EventEmitter": 7, "./Types": 14, "./input/MouseZoneManager": 18 }], 10: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var EscapeSequences_1 = require("./EscapeSequences");
            var Charsets_1 = require("./Charsets");
            var normalStateHandler = {};
            normalStateHandler[EscapeSequences_1.C0.BEL] = function (parser, handler) {
                return handler.bell();
            };
            normalStateHandler[EscapeSequences_1.C0.LF] = function (parser, handler) {
                return handler.lineFeed();
            };
            normalStateHandler[EscapeSequences_1.C0.VT] = normalStateHandler[EscapeSequences_1.C0.LF];
            normalStateHandler[EscapeSequences_1.C0.FF] = normalStateHandler[EscapeSequences_1.C0.LF];
            normalStateHandler[EscapeSequences_1.C0.CR] = function (parser, handler) {
                return handler.carriageReturn();
            };
            normalStateHandler[EscapeSequences_1.C0.BS] = function (parser, handler) {
                return handler.backspace();
            };
            normalStateHandler[EscapeSequences_1.C0.HT] = function (parser, handler) {
                return handler.tab();
            };
            normalStateHandler[EscapeSequences_1.C0.SO] = function (parser, handler) {
                return handler.shiftOut();
            };
            normalStateHandler[EscapeSequences_1.C0.SI] = function (parser, handler) {
                return handler.shiftIn();
            };
            normalStateHandler[EscapeSequences_1.C0.ESC] = function (parser, handler) {
                return parser.setState(ParserState.ESCAPED);
            };
            var escapedStateHandler = {};
            escapedStateHandler['['] = function (parser, terminal) {
                terminal.params = [];
                terminal.currentParam = 0;
                parser.setState(ParserState.CSI_PARAM);
            };
            escapedStateHandler[']'] = function (parser, terminal) {
                terminal.params = [];
                terminal.currentParam = 0;
                parser.setState(ParserState.OSC);
            };
            escapedStateHandler['P'] = function (parser, terminal) {
                terminal.params = [];
                terminal.currentParam = 0;
                parser.setState(ParserState.DCS);
            };
            escapedStateHandler['_'] = function (parser, terminal) {
                parser.setState(ParserState.IGNORE);
            };
            escapedStateHandler['^'] = function (parser, terminal) {
                parser.setState(ParserState.IGNORE);
            };
            escapedStateHandler['c'] = function (parser, terminal) {
                terminal.reset();
            };
            escapedStateHandler['E'] = function (parser, terminal) {
                terminal.buffer.x = 0;
                terminal.index();
                parser.setState(ParserState.NORMAL);
            };
            escapedStateHandler['D'] = function (parser, terminal) {
                terminal.index();
                parser.setState(ParserState.NORMAL);
            };
            escapedStateHandler['M'] = function (parser, terminal) {
                terminal.reverseIndex();
                parser.setState(ParserState.NORMAL);
            };
            escapedStateHandler['%'] = function (parser, terminal) {
                terminal.setgLevel(0);
                terminal.setgCharset(0, Charsets_1.DEFAULT_CHARSET);
                parser.setState(ParserState.NORMAL);
                parser.skipNextChar();
            };
            escapedStateHandler[EscapeSequences_1.C0.CAN] = function (parser) {
                return parser.setState(ParserState.NORMAL);
            };
            var csiParamStateHandler = {};
            csiParamStateHandler['?'] = function (parser) {
                return parser.setPrefix('?');
            };
            csiParamStateHandler['>'] = function (parser) {
                return parser.setPrefix('>');
            };
            csiParamStateHandler['!'] = function (parser) {
                return parser.setPrefix('!');
            };
            csiParamStateHandler['0'] = function (parser) {
                return parser.setParam(parser.getParam() * 10);
            };
            csiParamStateHandler['1'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 1);
            };
            csiParamStateHandler['2'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 2);
            };
            csiParamStateHandler['3'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 3);
            };
            csiParamStateHandler['4'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 4);
            };
            csiParamStateHandler['5'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 5);
            };
            csiParamStateHandler['6'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 6);
            };
            csiParamStateHandler['7'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 7);
            };
            csiParamStateHandler['8'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 8);
            };
            csiParamStateHandler['9'] = function (parser) {
                return parser.setParam(parser.getParam() * 10 + 9);
            };
            csiParamStateHandler['$'] = function (parser) {
                return parser.setPostfix('$');
            };
            csiParamStateHandler['"'] = function (parser) {
                return parser.setPostfix('"');
            };
            csiParamStateHandler[' '] = function (parser) {
                return parser.setPostfix(' ');
            };
            csiParamStateHandler['\''] = function (parser) {
                return parser.setPostfix('\'');
            };
            csiParamStateHandler[';'] = function (parser) {
                return parser.finalizeParam();
            };
            csiParamStateHandler[EscapeSequences_1.C0.CAN] = function (parser) {
                return parser.setState(ParserState.NORMAL);
            };
            var csiStateHandler = {};
            csiStateHandler['@'] = function (handler, params, prefix) {
                return handler.insertChars(params);
            };
            csiStateHandler['A'] = function (handler, params, prefix) {
                return handler.cursorUp(params);
            };
            csiStateHandler['B'] = function (handler, params, prefix) {
                return handler.cursorDown(params);
            };
            csiStateHandler['C'] = function (handler, params, prefix) {
                return handler.cursorForward(params);
            };
            csiStateHandler['D'] = function (handler, params, prefix) {
                return handler.cursorBackward(params);
            };
            csiStateHandler['E'] = function (handler, params, prefix) {
                return handler.cursorNextLine(params);
            };
            csiStateHandler['F'] = function (handler, params, prefix) {
                return handler.cursorPrecedingLine(params);
            };
            csiStateHandler['G'] = function (handler, params, prefix) {
                return handler.cursorCharAbsolute(params);
            };
            csiStateHandler['H'] = function (handler, params, prefix) {
                return handler.cursorPosition(params);
            };
            csiStateHandler['I'] = function (handler, params, prefix) {
                return handler.cursorForwardTab(params);
            };
            csiStateHandler['J'] = function (handler, params, prefix) {
                return handler.eraseInDisplay(params);
            };
            csiStateHandler['K'] = function (handler, params, prefix) {
                return handler.eraseInLine(params);
            };
            csiStateHandler['L'] = function (handler, params, prefix) {
                return handler.insertLines(params);
            };
            csiStateHandler['M'] = function (handler, params, prefix) {
                return handler.deleteLines(params);
            };
            csiStateHandler['P'] = function (handler, params, prefix) {
                return handler.deleteChars(params);
            };
            csiStateHandler['S'] = function (handler, params, prefix) {
                return handler.scrollUp(params);
            };
            csiStateHandler['T'] = function (handler, params, prefix) {
                if (params.length < 2 && !prefix) {
                    handler.scrollDown(params);
                }
            };
            csiStateHandler['X'] = function (handler, params, prefix) {
                return handler.eraseChars(params);
            };
            csiStateHandler['Z'] = function (handler, params, prefix) {
                return handler.cursorBackwardTab(params);
            };
            csiStateHandler['`'] = function (handler, params, prefix) {
                return handler.charPosAbsolute(params);
            };
            csiStateHandler['a'] = function (handler, params, prefix) {
                return handler.HPositionRelative(params);
            };
            csiStateHandler['b'] = function (handler, params, prefix) {
                return handler.repeatPrecedingCharacter(params);
            };
            csiStateHandler['c'] = function (handler, params, prefix) {
                return handler.sendDeviceAttributes(params);
            };
            csiStateHandler['d'] = function (handler, params, prefix) {
                return handler.linePosAbsolute(params);
            };
            csiStateHandler['e'] = function (handler, params, prefix) {
                return handler.VPositionRelative(params);
            };
            csiStateHandler['f'] = function (handler, params, prefix) {
                return handler.HVPosition(params);
            };
            csiStateHandler['g'] = function (handler, params, prefix) {
                return handler.tabClear(params);
            };
            csiStateHandler['h'] = function (handler, params, prefix) {
                return handler.setMode(params);
            };
            csiStateHandler['l'] = function (handler, params, prefix) {
                return handler.resetMode(params);
            };
            csiStateHandler['m'] = function (handler, params, prefix) {
                return handler.charAttributes(params);
            };
            csiStateHandler['n'] = function (handler, params, prefix) {
                return handler.deviceStatus(params);
            };
            csiStateHandler['p'] = function (handler, params, prefix) {
                switch (prefix) {
                    case '!':
                        handler.softReset(params);
                        break;
                }
            };
            csiStateHandler['q'] = function (handler, params, prefix, postfix) {
                if (postfix === ' ') {
                    handler.setCursorStyle(params);
                }
            };
            csiStateHandler['r'] = function (handler, params) {
                return handler.setScrollRegion(params);
            };
            csiStateHandler['s'] = function (handler, params) {
                return handler.saveCursor(params);
            };
            csiStateHandler['u'] = function (handler, params) {
                return handler.restoreCursor(params);
            };
            csiStateHandler[EscapeSequences_1.C0.CAN] = function (handler, params, prefix, postfix, parser) {
                return parser.setState(ParserState.NORMAL);
            };
            var ParserState;
            (function (ParserState) {
                ParserState[ParserState["NORMAL"] = 0] = "NORMAL";
                ParserState[ParserState["ESCAPED"] = 1] = "ESCAPED";
                ParserState[ParserState["CSI_PARAM"] = 2] = "CSI_PARAM";
                ParserState[ParserState["CSI"] = 3] = "CSI";
                ParserState[ParserState["OSC"] = 4] = "OSC";
                ParserState[ParserState["CHARSET"] = 5] = "CHARSET";
                ParserState[ParserState["DCS"] = 6] = "DCS";
                ParserState[ParserState["IGNORE"] = 7] = "IGNORE";
            })(ParserState = exports.ParserState || (exports.ParserState = {}));
            var Parser = function () {
                function Parser(_inputHandler, _terminal) {
                    this._inputHandler = _inputHandler;
                    this._terminal = _terminal;
                    this._state = ParserState.NORMAL;
                }
                Parser.prototype.parse = function (data) {
                    var l = data.length;
                    var j;
                    var cs;
                    var ch;
                    var code;
                    var low;
                    var cursorStartX = this._terminal.buffer.x;
                    var cursorStartY = this._terminal.buffer.y;
                    if (this._terminal.debug) {
                        this._terminal.log('data: ' + data);
                    }
                    this._position = 0;
                    if (this._terminal.surrogate_high) {
                        data = this._terminal.surrogate_high + data;
                        this._terminal.surrogate_high = '';
                    }
                    for (; this._position < l; this._position++) {
                        ch = data[this._position];
                        code = data.charCodeAt(this._position);
                        if (0xD800 <= code && code <= 0xDBFF) {
                            low = data.charCodeAt(this._position + 1);
                            if (isNaN(low)) {
                                this._terminal.surrogate_high = ch;
                                continue;
                            }
                            code = (code - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000;
                            ch += data.charAt(this._position + 1);
                        }
                        if (0xDC00 <= code && code <= 0xDFFF) {
                            continue;
                        }
                        switch (this._state) {
                            case ParserState.NORMAL:
                                if (ch in normalStateHandler) {
                                    normalStateHandler[ch](this, this._inputHandler);
                                } else {
                                    this._inputHandler.addChar(ch, code);
                                }
                                break;
                            case ParserState.ESCAPED:
                                if (ch in escapedStateHandler) {
                                    escapedStateHandler[ch](this, this._terminal);
                                    break;
                                }
                                switch (ch) {
                                    case '(':
                                    case ')':
                                    case '*':
                                    case '+':
                                    case '-':
                                    case '.':
                                        switch (ch) {
                                            case '(':
                                                this._terminal.gcharset = 0;
                                                break;
                                            case ')':
                                                this._terminal.gcharset = 1;
                                                break;
                                            case '*':
                                                this._terminal.gcharset = 2;
                                                break;
                                            case '+':
                                                this._terminal.gcharset = 3;
                                                break;
                                            case '-':
                                                this._terminal.gcharset = 1;
                                                break;
                                            case '.':
                                                this._terminal.gcharset = 2;
                                                break;
                                        }
                                        this._state = ParserState.CHARSET;
                                        break;
                                    case '/':
                                        this._terminal.gcharset = 3;
                                        this._state = ParserState.CHARSET;
                                        this._position--;
                                        break;
                                    case 'N':
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case 'O':
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case 'n':
                                        this._terminal.setgLevel(2);
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case 'o':
                                        this._terminal.setgLevel(3);
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case '|':
                                        this._terminal.setgLevel(3);
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case '}':
                                        this._terminal.setgLevel(2);
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case '~':
                                        this._terminal.setgLevel(1);
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case '7':
                                        this._inputHandler.saveCursor();
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case '8':
                                        this._inputHandler.restoreCursor();
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case '#':
                                        this._state = ParserState.NORMAL;
                                        this._position++;
                                        break;
                                    case 'H':
                                        this._terminal.tabSet();
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case '=':
                                        this._terminal.log('Serial port requested application keypad.');
                                        this._terminal.applicationKeypad = true;
                                        if (this._terminal.viewport) {
                                            this._terminal.viewport.syncScrollArea();
                                        }
                                        this._state = ParserState.NORMAL;
                                        break;
                                    case '>':
                                        this._terminal.log('Switching back to normal keypad.');
                                        this._terminal.applicationKeypad = false;
                                        if (this._terminal.viewport) {
                                            this._terminal.viewport.syncScrollArea();
                                        }
                                        this._state = ParserState.NORMAL;
                                        break;
                                    default:
                                        this._state = ParserState.NORMAL;
                                        this._terminal.error('Unknown ESC control: %s.', ch);
                                        break;
                                }
                                break;
                            case ParserState.CHARSET:
                                if (ch in Charsets_1.CHARSETS) {
                                    cs = Charsets_1.CHARSETS[ch];
                                    if (ch === '/') {
                                        this.skipNextChar();
                                    }
                                } else {
                                    cs = Charsets_1.DEFAULT_CHARSET;
                                }
                                this._terminal.setgCharset(this._terminal.gcharset, cs);
                                this._terminal.gcharset = null;
                                this._state = ParserState.NORMAL;
                                break;
                            case ParserState.OSC:
                                if (ch === EscapeSequences_1.C0.ESC || ch === EscapeSequences_1.C0.BEL) {
                                    if (ch === EscapeSequences_1.C0.ESC) this._position++;
                                    this._terminal.params.push(this._terminal.currentParam);
                                    switch (this._terminal.params[0]) {
                                        case 0:
                                        case 1:
                                        case 2:
                                            if (this._terminal.params[1]) {
                                                this._terminal.title = this._terminal.params[1];
                                                this._terminal.handleTitle(this._terminal.title);
                                            }
                                            break;
                                        case 3:
                                            break;
                                        case 4:
                                        case 5:
                                            break;
                                        case 10:
                                        case 11:
                                        case 12:
                                        case 13:
                                        case 14:
                                        case 15:
                                        case 16:
                                        case 17:
                                        case 18:
                                        case 19:
                                            break;
                                        case 46:
                                            break;
                                        case 50:
                                            break;
                                        case 51:
                                            break;
                                        case 52:
                                            break;
                                        case 104:
                                        case 105:
                                        case 110:
                                        case 111:
                                        case 112:
                                        case 113:
                                        case 114:
                                        case 115:
                                        case 116:
                                        case 117:
                                        case 118:
                                            break;
                                    }
                                    this._terminal.params = [];
                                    this._terminal.currentParam = 0;
                                    this._state = ParserState.NORMAL;
                                } else {
                                    if (!this._terminal.params.length) {
                                        if (ch >= '0' && ch <= '9') {
                                            this._terminal.currentParam = this._terminal.currentParam * 10 + ch.charCodeAt(0) - 48;
                                        } else if (ch === ';') {
                                            this._terminal.params.push(this._terminal.currentParam);
                                            this._terminal.currentParam = '';
                                        }
                                    } else {
                                        this._terminal.currentParam += ch;
                                    }
                                }
                                break;
                            case ParserState.CSI_PARAM:
                                if (ch in csiParamStateHandler) {
                                    csiParamStateHandler[ch](this);
                                    break;
                                }
                                this.finalizeParam();
                                this._state = ParserState.CSI;
                            case ParserState.CSI:
                                if (ch in csiStateHandler) {
                                    if (this._terminal.debug) {
                                        this._terminal.log("CSI " + (this._terminal.prefix ? this._terminal.prefix : '') + " " + (this._terminal.params ? this._terminal.params.join(';') : '') + " " + (this._terminal.postfix ? this._terminal.postfix : '') + " " + ch);
                                    }
                                    csiStateHandler[ch](this._inputHandler, this._terminal.params, this._terminal.prefix, this._terminal.postfix, this);
                                } else {
                                    this._terminal.error('Unknown CSI code: %s.', ch);
                                }
                                this._state = ParserState.NORMAL;
                                this._terminal.prefix = '';
                                this._terminal.postfix = '';
                                break;
                            case ParserState.DCS:
                                if (ch === EscapeSequences_1.C0.ESC || ch === EscapeSequences_1.C0.BEL) {
                                    if (ch === EscapeSequences_1.C0.ESC) this._position++;
                                    var pt = void 0;
                                    var valid = void 0;
                                    switch (this._terminal.prefix) {
                                        case '':
                                            break;
                                        case '$q':
                                            pt = this._terminal.currentParam;
                                            valid = false;
                                            switch (pt) {
                                                case '"q':
                                                    pt = '0"q';
                                                    break;
                                                case '"p':
                                                    pt = '61"p';
                                                    break;
                                                case 'r':
                                                    pt = '' + (this._terminal.buffer.scrollTop + 1) + ';' + (this._terminal.buffer.scrollBottom + 1) + 'r';
                                                    break;
                                                case 'm':
                                                    pt = '0m';
                                                    break;
                                                default:
                                                    this._terminal.error('Unknown DCS Pt: %s.', pt);
                                                    pt = '';
                                                    break;
                                            }
                                            this._terminal.send(EscapeSequences_1.C0.ESC + 'P' + +valid + '$r' + pt + EscapeSequences_1.C0.ESC + '\\');
                                            break;
                                        case '+p':
                                            break;
                                        case '+q':
                                            pt = this._terminal.currentParam;
                                            valid = false;
                                            this._terminal.send(EscapeSequences_1.C0.ESC + 'P' + +valid + '+r' + pt + EscapeSequences_1.C0.ESC + '\\');
                                            break;
                                        default:
                                            this._terminal.error('Unknown DCS prefix: %s.', this._terminal.prefix);
                                            break;
                                    }
                                    this._terminal.currentParam = 0;
                                    this._terminal.prefix = '';
                                    this._state = ParserState.NORMAL;
                                } else if (!this._terminal.currentParam) {
                                    if (!this._terminal.prefix && ch !== '$' && ch !== '+') {
                                        this._terminal.currentParam = ch;
                                    } else if (this._terminal.prefix.length === 2) {
                                        this._terminal.currentParam = ch;
                                    } else {
                                        this._terminal.prefix += ch;
                                    }
                                } else {
                                    this._terminal.currentParam += ch;
                                }
                                break;
                            case ParserState.IGNORE:
                                if (ch === EscapeSequences_1.C0.ESC || ch === EscapeSequences_1.C0.BEL) {
                                    if (ch === EscapeSequences_1.C0.ESC) this._position++;
                                    this._state = ParserState.NORMAL;
                                }
                                break;
                        }
                    }
                    if (this._terminal.buffer.x !== cursorStartX || this._terminal.buffer.y !== cursorStartY) {
                        this._terminal.emit('cursormove');
                    }
                    return this._state;
                };
                Parser.prototype.setState = function (state) {
                    this._state = state;
                };
                Parser.prototype.setPrefix = function (prefix) {
                    this._terminal.prefix = prefix;
                };
                Parser.prototype.setPostfix = function (postfix) {
                    this._terminal.postfix = postfix;
                };
                Parser.prototype.setParam = function (param) {
                    this._terminal.currentParam = param;
                };
                Parser.prototype.getParam = function () {
                    return this._terminal.currentParam;
                };
                Parser.prototype.finalizeParam = function () {
                    this._terminal.params.push(this._terminal.currentParam);
                    this._terminal.currentParam = 0;
                };
                Parser.prototype.skipNextChar = function () {
                    this._position++;
                };
                return Parser;
            }();
            exports.Parser = Parser;
        }, { "./Charsets": 4, "./EscapeSequences": 6 }], 11: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var MouseHelper_1 = require("./utils/MouseHelper");
            var Browser = require("./shared/utils/Browser");
            var EventEmitter_1 = require("./EventEmitter");
            var SelectionModel_1 = require("./SelectionModel");
            var Buffer_1 = require("./Buffer");
            var AltClickHandler_1 = require("./handlers/AltClickHandler");
            var DRAG_SCROLL_MAX_THRESHOLD = 50;
            var DRAG_SCROLL_MAX_SPEED = 15;
            var DRAG_SCROLL_INTERVAL = 50;
            var ALT_CLICK_MOVE_CURSOR_TIME = 500;
            var WORD_SEPARATORS = ' ()[]{}\'"';
            var NON_BREAKING_SPACE_CHAR = String.fromCharCode(160);
            var ALL_NON_BREAKING_SPACE_REGEX = new RegExp(NON_BREAKING_SPACE_CHAR, 'g');
            var SelectionMode;
            (function (SelectionMode) {
                SelectionMode[SelectionMode["NORMAL"] = 0] = "NORMAL";
                SelectionMode[SelectionMode["WORD"] = 1] = "WORD";
                SelectionMode[SelectionMode["LINE"] = 2] = "LINE";
            })(SelectionMode || (SelectionMode = {}));
            var SelectionManager = function (_super) {
                __extends(SelectionManager, _super);
                function SelectionManager(_terminal, _charMeasure) {
                    var _this = _super.call(this) || this;
                    _this._terminal = _terminal;
                    _this._charMeasure = _charMeasure;
                    _this._enabled = true;
                    _this._initListeners();
                    _this.enable();
                    _this._model = new SelectionModel_1.SelectionModel(_terminal);
                    _this._activeSelectionMode = SelectionMode.NORMAL;
                    return _this;
                }
                Object.defineProperty(SelectionManager.prototype, "_buffer", {
                    get: function get() {
                        return this._terminal.buffers.active;
                    },
                    enumerable: true,
                    configurable: true
                });
                SelectionManager.prototype._initListeners = function () {
                    var _this = this;
                    this._mouseMoveListener = function (event) {
                        return _this._onMouseMove(event);
                    };
                    this._mouseUpListener = function (event) {
                        return _this._onMouseUp(event);
                    };
                    this._trimListener = function (amount) {
                        return _this._onTrim(amount);
                    };
                    this.initBuffersListeners();
                };
                SelectionManager.prototype.initBuffersListeners = function () {
                    var _this = this;
                    this._terminal.buffer.lines.on('trim', this._trimListener);
                    this._terminal.buffers.on('activate', function (e) {
                        return _this._onBufferActivate(e);
                    });
                };
                SelectionManager.prototype.disable = function () {
                    this.clearSelection();
                    this._enabled = false;
                };
                SelectionManager.prototype.enable = function () {
                    this._enabled = true;
                };
                Object.defineProperty(SelectionManager.prototype, "selectionStart", {
                    get: function get() {
                        return this._model.finalSelectionStart;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SelectionManager.prototype, "selectionEnd", {
                    get: function get() {
                        return this._model.finalSelectionEnd;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SelectionManager.prototype, "hasSelection", {
                    get: function get() {
                        var start = this._model.finalSelectionStart;
                        var end = this._model.finalSelectionEnd;
                        if (!start || !end) {
                            return false;
                        }
                        return start[0] !== end[0] || start[1] !== end[1];
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SelectionManager.prototype, "selectionText", {
                    get: function get() {
                        var start = this._model.finalSelectionStart;
                        var end = this._model.finalSelectionEnd;
                        if (!start || !end) {
                            return '';
                        }
                        var startRowEndCol = start[1] === end[1] ? end[0] : null;
                        var result = [];
                        result.push(this._buffer.translateBufferLineToString(start[1], true, start[0], startRowEndCol));
                        for (var i = start[1] + 1; i <= end[1] - 1; i++) {
                            var bufferLine = this._buffer.lines.get(i);
                            var lineText = this._buffer.translateBufferLineToString(i, true);
                            if (bufferLine.isWrapped) {
                                result[result.length - 1] += lineText;
                            } else {
                                result.push(lineText);
                            }
                        }
                        if (start[1] !== end[1]) {
                            var bufferLine = this._buffer.lines.get(end[1]);
                            var lineText = this._buffer.translateBufferLineToString(end[1], true, 0, end[0]);
                            if (bufferLine.isWrapped) {
                                result[result.length - 1] += lineText;
                            } else {
                                result.push(lineText);
                            }
                        }
                        var formattedResult = result.map(function (line) {
                            return line.replace(ALL_NON_BREAKING_SPACE_REGEX, ' ');
                        }).join(Browser.isMSWindows ? '\r\n' : '\n');
                        return formattedResult;
                    },
                    enumerable: true,
                    configurable: true
                });
                SelectionManager.prototype.clearSelection = function () {
                    this._model.clearSelection();
                    this._removeMouseDownListeners();
                    this.refresh();
                };
                SelectionManager.prototype.refresh = function (isNewSelection) {
                    var _this = this;
                    if (!this._refreshAnimationFrame) {
                        this._refreshAnimationFrame = window.requestAnimationFrame(function () {
                            return _this._refresh();
                        });
                    }
                    if (Browser.isLinux && isNewSelection) {
                        var selectionText = this.selectionText;
                        if (selectionText.length) {
                            this.emit('newselection', this.selectionText);
                        }
                    }
                };
                SelectionManager.prototype._refresh = function () {
                    this._refreshAnimationFrame = null;
                    this.emit('refresh', { start: this._model.finalSelectionStart, end: this._model.finalSelectionEnd });
                };
                SelectionManager.prototype.isClickInSelection = function (event) {
                    var coords = this._getMouseBufferCoords(event);
                    var start = this._model.finalSelectionStart;
                    var end = this._model.finalSelectionEnd;
                    if (!start || !end) {
                        return false;
                    }
                    return coords[1] > start[1] && coords[1] < end[1] || start[1] === end[1] && coords[1] === start[1] && coords[0] > start[0] && coords[0] < end[0] || start[1] < end[1] && coords[1] === end[1] && coords[0] < end[0];
                };
                SelectionManager.prototype.selectWordAtCursor = function (event) {
                    var coords = this._getMouseBufferCoords(event);
                    if (coords) {
                        this._selectWordAt(coords, false);
                        this._model.selectionEnd = null;
                        this.refresh(true);
                    }
                };
                SelectionManager.prototype.selectAll = function () {
                    this._model.isSelectAllActive = true;
                    this.refresh();
                    this._terminal.emit('selection');
                };
                SelectionManager.prototype._onTrim = function (amount) {
                    var needsRefresh = this._model.onTrim(amount);
                    if (needsRefresh) {
                        this.refresh();
                    }
                };
                SelectionManager.prototype._getMouseBufferCoords = function (event) {
                    var coords = this._terminal.mouseHelper.getCoords(event, this._terminal.screenElement, this._charMeasure, this._terminal.options.lineHeight, this._terminal.cols, this._terminal.rows, true);
                    if (!coords) {
                        return null;
                    }
                    coords[0]--;
                    coords[1]--;
                    coords[1] += this._terminal.buffer.ydisp;
                    return coords;
                };
                SelectionManager.prototype._getMouseEventScrollAmount = function (event) {
                    var offset = MouseHelper_1.MouseHelper.getCoordsRelativeToElement(event, this._terminal.screenElement)[1];
                    var terminalHeight = this._terminal.rows * Math.ceil(this._charMeasure.height * this._terminal.options.lineHeight);
                    if (offset >= 0 && offset <= terminalHeight) {
                        return 0;
                    }
                    if (offset > terminalHeight) {
                        offset -= terminalHeight;
                    }
                    offset = Math.min(Math.max(offset, -DRAG_SCROLL_MAX_THRESHOLD), DRAG_SCROLL_MAX_THRESHOLD);
                    offset /= DRAG_SCROLL_MAX_THRESHOLD;
                    return offset / Math.abs(offset) + Math.round(offset * (DRAG_SCROLL_MAX_SPEED - 1));
                };
                SelectionManager.prototype.shouldForceSelection = function (event) {
                    return Browser.isMac ? event.altKey : event.shiftKey;
                };
                SelectionManager.prototype.onMouseDown = function (event) {
                    this._mouseDownTimeStamp = event.timeStamp;
                    if (event.button === 2 && this.hasSelection) {
                        return;
                    }
                    if (event.button !== 0) {
                        return;
                    }
                    if (!this._enabled) {
                        if (!this.shouldForceSelection(event)) {
                            return;
                        }
                        event.stopPropagation();
                    }
                    event.preventDefault();
                    this._dragScrollAmount = 0;
                    if (this._enabled && event.shiftKey) {
                        this._onIncrementalClick(event);
                    } else {
                        if (event.detail === 1) {
                            this._onSingleClick(event);
                        } else if (event.detail === 2) {
                            this._onDoubleClick(event);
                        } else if (event.detail === 3) {
                            this._onTripleClick(event);
                        }
                    }
                    this._addMouseDownListeners();
                    this.refresh(true);
                };
                SelectionManager.prototype._addMouseDownListeners = function () {
                    var _this = this;
                    this._terminal.element.ownerDocument.addEventListener('mousemove', this._mouseMoveListener);
                    this._terminal.element.ownerDocument.addEventListener('mouseup', this._mouseUpListener);
                    this._dragScrollIntervalTimer = setInterval(function () {
                        return _this._dragScroll();
                    }, DRAG_SCROLL_INTERVAL);
                };
                SelectionManager.prototype._removeMouseDownListeners = function () {
                    this._terminal.element.ownerDocument.removeEventListener('mousemove', this._mouseMoveListener);
                    this._terminal.element.ownerDocument.removeEventListener('mouseup', this._mouseUpListener);
                    clearInterval(this._dragScrollIntervalTimer);
                    this._dragScrollIntervalTimer = null;
                };
                SelectionManager.prototype._onIncrementalClick = function (event) {
                    if (this._model.selectionStart) {
                        this._model.selectionEnd = this._getMouseBufferCoords(event);
                    }
                };
                SelectionManager.prototype._onSingleClick = function (event) {
                    this._model.selectionStartLength = 0;
                    this._model.isSelectAllActive = false;
                    this._activeSelectionMode = SelectionMode.NORMAL;
                    this._model.selectionStart = this._getMouseBufferCoords(event);
                    if (!this._model.selectionStart) {
                        return;
                    }
                    this._model.selectionEnd = null;
                    var line = this._buffer.lines.get(this._model.selectionStart[1]);
                    if (!line) {
                        return;
                    }
                    if (line.length >= this._model.selectionStart[0]) {
                        return;
                    }
                    var char = line[this._model.selectionStart[0]];
                    if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                        this._model.selectionStart[0]++;
                    }
                };
                SelectionManager.prototype._onDoubleClick = function (event) {
                    var coords = this._getMouseBufferCoords(event);
                    if (coords) {
                        this._activeSelectionMode = SelectionMode.WORD;
                        this._selectWordAt(coords, true);
                    }
                };
                SelectionManager.prototype._onTripleClick = function (event) {
                    var coords = this._getMouseBufferCoords(event);
                    if (coords) {
                        this._activeSelectionMode = SelectionMode.LINE;
                        this._selectLineAt(coords[1]);
                    }
                };
                SelectionManager.prototype._onMouseMove = function (event) {
                    event.stopImmediatePropagation();
                    var previousSelectionEnd = this._model.selectionEnd ? [this._model.selectionEnd[0], this._model.selectionEnd[1]] : null;
                    this._model.selectionEnd = this._getMouseBufferCoords(event);
                    if (!this._model.selectionEnd) {
                        this.refresh(true);
                        return;
                    }
                    if (this._activeSelectionMode === SelectionMode.LINE) {
                        if (this._model.selectionEnd[1] < this._model.selectionStart[1]) {
                            this._model.selectionEnd[0] = 0;
                        } else {
                            this._model.selectionEnd[0] = this._terminal.cols;
                        }
                    } else if (this._activeSelectionMode === SelectionMode.WORD) {
                        this._selectToWordAt(this._model.selectionEnd);
                    }
                    this._dragScrollAmount = this._getMouseEventScrollAmount(event);
                    if (this._dragScrollAmount > 0) {
                        this._model.selectionEnd[0] = this._terminal.cols;
                    } else if (this._dragScrollAmount < 0) {
                        this._model.selectionEnd[0] = 0;
                    }
                    if (this._model.selectionEnd[1] < this._buffer.lines.length) {
                        var char = this._buffer.lines.get(this._model.selectionEnd[1])[this._model.selectionEnd[0]];
                        if (char && char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                            this._model.selectionEnd[0]++;
                        }
                    }
                    if (!previousSelectionEnd || previousSelectionEnd[0] !== this._model.selectionEnd[0] || previousSelectionEnd[1] !== this._model.selectionEnd[1]) {
                        this.refresh(true);
                    }
                };
                SelectionManager.prototype._dragScroll = function () {
                    if (this._dragScrollAmount) {
                        this._terminal.scrollLines(this._dragScrollAmount, false);
                        if (this._dragScrollAmount > 0) {
                            this._model.selectionEnd = [this._terminal.cols - 1, Math.min(this._terminal.buffer.ydisp + this._terminal.rows, this._terminal.buffer.lines.length - 1)];
                        } else {
                            this._model.selectionEnd = [0, this._terminal.buffer.ydisp];
                        }
                        this.refresh();
                    }
                };
                SelectionManager.prototype._onMouseUp = function (event) {
                    var timeElapsed = event.timeStamp - this._mouseDownTimeStamp;
                    this._removeMouseDownListeners();
                    if (this.selectionText.length <= 1 && timeElapsed < ALT_CLICK_MOVE_CURSOR_TIME) {
                        new AltClickHandler_1.AltClickHandler(event, this._terminal).move();
                    } else if (this.hasSelection) {
                        this._terminal.emit('selection');
                    }
                };
                SelectionManager.prototype._onBufferActivate = function (e) {
                    this.clearSelection();
                    e.inactiveBuffer.lines.off('trim', this._trimListener);
                    e.activeBuffer.lines.on('trim', this._trimListener);
                };
                SelectionManager.prototype._convertViewportColToCharacterIndex = function (bufferLine, coords) {
                    var charIndex = coords[0];
                    for (var i = 0; coords[0] >= i; i++) {
                        var char = bufferLine[i];
                        if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                            charIndex--;
                        } else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1 && coords[0] !== i) {
                            charIndex += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                        }
                    }
                    return charIndex;
                };
                SelectionManager.prototype.setSelection = function (col, row, length) {
                    this._model.clearSelection();
                    this._removeMouseDownListeners();
                    this._model.selectionStart = [col, row];
                    this._model.selectionStartLength = length;
                    this.refresh();
                };
                SelectionManager.prototype._getWordAt = function (coords, allowWhitespaceOnlySelection) {
                    var bufferLine = this._buffer.lines.get(coords[1]);
                    if (!bufferLine) {
                        return null;
                    }
                    var line = this._buffer.translateBufferLineToString(coords[1], false);
                    var startIndex = this._convertViewportColToCharacterIndex(bufferLine, coords);
                    var endIndex = startIndex;
                    var charOffset = coords[0] - startIndex;
                    var leftWideCharCount = 0;
                    var rightWideCharCount = 0;
                    var leftLongCharOffset = 0;
                    var rightLongCharOffset = 0;
                    if (line.charAt(startIndex) === ' ') {
                        while (startIndex > 0 && line.charAt(startIndex - 1) === ' ') {
                            startIndex--;
                        }
                        while (endIndex < line.length && line.charAt(endIndex + 1) === ' ') {
                            endIndex++;
                        }
                    } else {
                        var startCol = coords[0];
                        var endCol = coords[0];
                        if (bufferLine[startCol][Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                            leftWideCharCount++;
                            startCol--;
                        }
                        if (bufferLine[endCol][Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                            rightWideCharCount++;
                            endCol++;
                        }
                        if (bufferLine[endCol][Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                            rightLongCharOffset += bufferLine[endCol][Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                            endIndex += bufferLine[endCol][Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                        }
                        while (startCol > 0 && startIndex > 0 && !this._isCharWordSeparator(bufferLine[startCol - 1])) {
                            var char = bufferLine[startCol - 1];
                            if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                                leftWideCharCount++;
                                startCol--;
                            } else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                                leftLongCharOffset += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                                startIndex -= char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                            }
                            startIndex--;
                            startCol--;
                        }
                        while (endCol < bufferLine.length && endIndex + 1 < line.length && !this._isCharWordSeparator(bufferLine[endCol + 1])) {
                            var char = bufferLine[endCol + 1];
                            if (char[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                                rightWideCharCount++;
                                endCol++;
                            } else if (char[Buffer_1.CHAR_DATA_CHAR_INDEX].length > 1) {
                                rightLongCharOffset += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                                endIndex += char[Buffer_1.CHAR_DATA_CHAR_INDEX].length - 1;
                            }
                            endIndex++;
                            endCol++;
                        }
                    }
                    endIndex++;
                    var start = startIndex + charOffset - leftWideCharCount + leftLongCharOffset;
                    var length = Math.min(this._terminal.cols, endIndex - startIndex + leftWideCharCount + rightWideCharCount - leftLongCharOffset - rightLongCharOffset);
                    if (!allowWhitespaceOnlySelection && line.slice(startIndex, endIndex).trim() === '') {
                        return null;
                    }
                    return { start: start, length: length };
                };
                SelectionManager.prototype._selectWordAt = function (coords, allowWhitespaceOnlySelection) {
                    var wordPosition = this._getWordAt(coords, allowWhitespaceOnlySelection);
                    if (wordPosition) {
                        this._model.selectionStart = [wordPosition.start, coords[1]];
                        this._model.selectionStartLength = wordPosition.length;
                    }
                };
                SelectionManager.prototype._selectToWordAt = function (coords) {
                    var wordPosition = this._getWordAt(coords, true);
                    if (wordPosition) {
                        this._model.selectionEnd = [this._model.areSelectionValuesReversed() ? wordPosition.start : wordPosition.start + wordPosition.length, coords[1]];
                    }
                };
                SelectionManager.prototype._isCharWordSeparator = function (charData) {
                    if (charData[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 0) {
                        return false;
                    }
                    return WORD_SEPARATORS.indexOf(charData[Buffer_1.CHAR_DATA_CHAR_INDEX]) >= 0;
                };
                SelectionManager.prototype._selectLineAt = function (line) {
                    this._model.selectionStart = [0, line];
                    this._model.selectionStartLength = this._terminal.cols;
                };
                return SelectionManager;
            }(EventEmitter_1.EventEmitter);
            exports.SelectionManager = SelectionManager;
        }, { "./Buffer": 1, "./EventEmitter": 7, "./SelectionModel": 12, "./handlers/AltClickHandler": 16, "./shared/utils/Browser": 30, "./utils/MouseHelper": 33 }], 12: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var SelectionModel = function () {
                function SelectionModel(_terminal) {
                    this._terminal = _terminal;
                    this.clearSelection();
                }
                SelectionModel.prototype.clearSelection = function () {
                    this.selectionStart = null;
                    this.selectionEnd = null;
                    this.isSelectAllActive = false;
                    this.selectionStartLength = 0;
                };
                Object.defineProperty(SelectionModel.prototype, "finalSelectionStart", {
                    get: function get() {
                        if (this.isSelectAllActive) {
                            return [0, 0];
                        }
                        if (!this.selectionEnd || !this.selectionStart) {
                            return this.selectionStart;
                        }
                        return this.areSelectionValuesReversed() ? this.selectionEnd : this.selectionStart;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(SelectionModel.prototype, "finalSelectionEnd", {
                    get: function get() {
                        if (this.isSelectAllActive) {
                            return [this._terminal.cols, this._terminal.buffer.ybase + this._terminal.rows - 1];
                        }
                        if (!this.selectionStart) {
                            return null;
                        }
                        if (!this.selectionEnd || this.areSelectionValuesReversed()) {
                            return [this.selectionStart[0] + this.selectionStartLength, this.selectionStart[1]];
                        }
                        if (this.selectionStartLength) {
                            if (this.selectionEnd[1] === this.selectionStart[1]) {
                                return [Math.max(this.selectionStart[0] + this.selectionStartLength, this.selectionEnd[0]), this.selectionEnd[1]];
                            }
                        }
                        return this.selectionEnd;
                    },
                    enumerable: true,
                    configurable: true
                });
                SelectionModel.prototype.areSelectionValuesReversed = function () {
                    var start = this.selectionStart;
                    var end = this.selectionEnd;
                    if (!start || !end) {
                        return false;
                    }
                    return start[1] > end[1] || start[1] === end[1] && start[0] > end[0];
                };
                SelectionModel.prototype.onTrim = function (amount) {
                    if (this.selectionStart) {
                        this.selectionStart[1] -= amount;
                    }
                    if (this.selectionEnd) {
                        this.selectionEnd[1] -= amount;
                    }
                    if (this.selectionEnd && this.selectionEnd[1] < 0) {
                        this.clearSelection();
                        return true;
                    }
                    if (this.selectionStart && this.selectionStart[1] < 0) {
                        this.selectionStart[1] = 0;
                    }
                    return false;
                };
                return SelectionModel;
            }();
            exports.SelectionModel = SelectionModel;
        }, {}], 13: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var BufferSet_1 = require("./BufferSet");
            var Buffer_1 = require("./Buffer");
            var CompositionHelper_1 = require("./CompositionHelper");
            var EventEmitter_1 = require("./EventEmitter");
            var Viewport_1 = require("./Viewport");
            var Clipboard_1 = require("./handlers/Clipboard");
            var EscapeSequences_1 = require("./EscapeSequences");
            var InputHandler_1 = require("./InputHandler");
            var Parser_1 = require("./Parser");
            var Renderer_1 = require("./renderer/Renderer");
            var Linkifier_1 = require("./Linkifier");
            var SelectionManager_1 = require("./SelectionManager");
            var CharMeasure_1 = require("./utils/CharMeasure");
            var Browser = require("./shared/utils/Browser");
            var MouseHelper_1 = require("./utils/MouseHelper");
            var Sounds_1 = require("./utils/Sounds");
            var ColorManager_1 = require("./renderer/ColorManager");
            var MouseZoneManager_1 = require("./input/MouseZoneManager");
            var document = typeof window !== 'undefined' ? window.document : null;
            var WRITE_BUFFER_PAUSE_THRESHOLD = 5;
            var WRITE_BATCH_SIZE = 300;
            var DEFAULT_OPTIONS = {
                cols: 80,
                rows: 24,
                convertEol: false,
                termName: 'xterm',
                cursorBlink: false,
                cursorStyle: 'block',
                bellSound: Sounds_1.BELL_SOUND,
                bellStyle: 'none',
                enableBold: true,
                fontFamily: 'courier-new, courier, monospace',
                fontSize: 15,
                fontWeight: 'normal',
                fontWeightBold: 'bold',
                lineHeight: 1.0,
                letterSpacing: 0,
                scrollback: 1000,
                screenKeys: false,
                debug: false,
                macOptionIsMeta: false,
                cancelEvents: false,
                disableStdin: false,
                useFlowControl: false,
                allowTransparency: false,
                tabStopWidth: 8,
                theme: null,
                rightClickSelectsWord: Browser.isMac
            };
            var Terminal = function (_super) {
                __extends(Terminal, _super);
                function Terminal(options) {
                    if (options === void 0) {
                        options = {};
                    }
                    var _this = _super.call(this) || this;
                    _this.browser = Browser;
                    _this.options = options;
                    _this.setup();
                    return _this;
                }
                Terminal.prototype.setup = function () {
                    var _this = this;
                    Object.keys(DEFAULT_OPTIONS).forEach(function (key) {
                        if (_this.options[key] == null) {
                            _this.options[key] = DEFAULT_OPTIONS[key];
                        }
                        _this[key] = _this.options[key];
                    });
                    this.parent = document ? document.body : null;
                    this.cols = this.options.cols;
                    this.rows = this.options.rows;
                    if (this.options.handler) {
                        this.on('data', this.options.handler);
                    }
                    this.cursorState = 0;
                    this.cursorHidden = false;
                    this.sendDataQueue = '';
                    this.customKeyEventHandler = null;
                    this.applicationKeypad = false;
                    this.applicationCursor = false;
                    this.originMode = false;
                    this.insertMode = false;
                    this.wraparoundMode = true;
                    this.bracketedPasteMode = false;
                    this.charset = null;
                    this.gcharset = null;
                    this.glevel = 0;
                    this.charsets = [null];
                    this.readable = true;
                    this.writable = true;
                    this.defAttr = 0 << 18 | 257 << 9 | 256 << 0;
                    this.curAttr = 0 << 18 | 257 << 9 | 256 << 0;
                    this.params = [];
                    this.currentParam = 0;
                    this.prefix = '';
                    this.postfix = '';
                    this.writeBuffer = [];
                    this.writeInProgress = false;
                    this.xoffSentToCatchUp = false;
                    this.writeStopped = false;
                    this.surrogateHigh = '';
                    this.userScrolling = false;
                    this.inputHandler = new InputHandler_1.InputHandler(this);
                    this.parser = new Parser_1.Parser(this.inputHandler, this);
                    this.renderer = this.renderer || null;
                    this.selectionManager = this.selectionManager || null;
                    this.linkifier = this.linkifier || new Linkifier_1.Linkifier(this);
                    this._mouseZoneManager = this._mouseZoneManager || null;
                    this.buffers = new BufferSet_1.BufferSet(this);
                    if (this.selectionManager) {
                        this.selectionManager.clearSelection();
                        this.selectionManager.initBuffersListeners();
                    }
                };
                Object.defineProperty(Terminal.prototype, "buffer", {
                    get: function get() {
                        return this.buffers.active;
                    },
                    enumerable: true,
                    configurable: true
                });
                Terminal.prototype.eraseAttr = function () {
                    return this.defAttr & ~0x1ff | this.curAttr & 0x1ff;
                };
                Terminal.prototype.focus = function () {
                    if (this.textarea) {
                        this.textarea.focus();
                    }
                };
                Object.defineProperty(Terminal.prototype, "isFocused", {
                    get: function get() {
                        return document.activeElement === this.textarea;
                    },
                    enumerable: true,
                    configurable: true
                });
                Terminal.prototype.getOption = function (key) {
                    if (!(key in DEFAULT_OPTIONS)) {
                        throw new Error('No option with key "' + key + '"');
                    }
                    if (typeof this.options[key] !== 'undefined') {
                        return this.options[key];
                    }
                    return this[key];
                };
                Terminal.prototype.setOption = function (key, value) {
                    if (!(key in DEFAULT_OPTIONS)) {
                        throw new Error('No option with key "' + key + '"');
                    }
                    switch (key) {
                        case 'bellStyle':
                            if (!value) {
                                value = 'none';
                            }
                            break;
                        case 'cursorStyle':
                            if (!value) {
                                value = 'block';
                            }
                            break;
                        case 'fontWeight':
                            if (!value) {
                                value = 'normal';
                            }
                            break;
                        case 'fontWeightBold':
                            if (!value) {
                                value = 'bold';
                            }
                            break;
                        case 'lineHeight':
                            if (value < 1) {
                                console.warn(key + " cannot be less than 1, value: " + value);
                                return;
                            }
                        case 'tabStopWidth':
                            if (value < 1) {
                                console.warn(key + " cannot be less than 1, value: " + value);
                                return;
                            }
                            break;
                        case 'theme':
                            if (this.renderer) {
                                this._setTheme(value);
                                return;
                            }
                            break;
                        case 'scrollback':
                            value = Math.min(value, Buffer_1.MAX_BUFFER_SIZE);
                            if (value < 0) {
                                console.warn(key + " cannot be less than 0, value: " + value);
                                return;
                            }
                            if (this.options[key] !== value) {
                                var newBufferLength = this.rows + value;
                                if (this.buffer.lines.length > newBufferLength) {
                                    var amountToTrim = this.buffer.lines.length - newBufferLength;
                                    var needsRefresh = this.buffer.ydisp - amountToTrim < 0;
                                    this.buffer.lines.trimStart(amountToTrim);
                                    this.buffer.ybase = Math.max(this.buffer.ybase - amountToTrim, 0);
                                    this.buffer.ydisp = Math.max(this.buffer.ydisp - amountToTrim, 0);
                                    if (needsRefresh) {
                                        this.refresh(0, this.rows - 1);
                                    }
                                }
                            }
                            break;
                    }
                    this[key] = value;
                    this.options[key] = value;
                    switch (key) {
                        case 'fontFamily':
                        case 'fontSize':
                            this.renderer.clear();
                            this.charMeasure.measure(this.options);
                            break;
                        case 'enableBold':
                        case 'letterSpacing':
                        case 'lineHeight':
                        case 'fontWeight':
                        case 'fontWeightBold':
                            var didCharSizeChange = key === 'fontWeight' || key === 'fontWeightBold' || key === 'enableBold';
                            this.renderer.clear();
                            this.renderer.onResize(this.cols, this.rows, didCharSizeChange);
                            this.refresh(0, this.rows - 1);
                        case 'scrollback':
                            this.buffers.resize(this.cols, this.rows);
                            this.viewport.syncScrollArea();
                            break;
                        case 'tabStopWidth':
                            this.buffers.setupTabStops();
                            break;
                        case 'bellSound':
                        case 'bellStyle':
                            this.syncBellSound();
                            break;
                    }
                    if (this.renderer) {
                        this.renderer.onOptionsChanged();
                    }
                };
                Terminal.prototype._onTextAreaFocus = function () {
                    if (this.sendFocus) {
                        this.send(EscapeSequences_1.C0.ESC + '[I');
                    }
                    this.element.classList.add('focus');
                    this.showCursor();
                    this.emit('focus');
                };
                Terminal.prototype.blur = function () {
                    return this.textarea.blur();
                };
                Terminal.prototype._onTextAreaBlur = function () {
                    this.refresh(this.buffer.y, this.buffer.y);
                    if (this.sendFocus) {
                        this.send(EscapeSequences_1.C0.ESC + '[O');
                    }
                    this.element.classList.remove('focus');
                    this.emit('blur');
                };
                Terminal.prototype.initGlobal = function () {
                    var _this = this;
                    this.bindKeys();
                    on(this.element, 'copy', function (event) {
                        if (!_this.hasSelection()) {
                            return;
                        }
                        Clipboard_1.copyHandler(event, _this, _this.selectionManager);
                    });
                    var pasteHandlerWrapper = function pasteHandlerWrapper(event) {
                        return Clipboard_1.pasteHandler(event, _this);
                    };
                    on(this.textarea, 'paste', pasteHandlerWrapper);
                    on(this.element, 'paste', pasteHandlerWrapper);
                    if (Browser.isFirefox) {
                        on(this.element, 'mousedown', function (event) {
                            if (event.button === 2) {
                                Clipboard_1.rightClickHandler(event, _this.textarea, _this.selectionManager, _this.options.rightClickSelectsWord);
                            }
                        });
                    } else {
                        on(this.element, 'contextmenu', function (event) {
                            Clipboard_1.rightClickHandler(event, _this.textarea, _this.selectionManager, _this.options.rightClickSelectsWord);
                        });
                    }
                    if (Browser.isLinux) {
                        on(this.element, 'auxclick', function (event) {
                            if (event.button === 1) {
                                Clipboard_1.moveTextAreaUnderMouseCursor(event, _this.textarea);
                            }
                        });
                    }
                };
                Terminal.prototype.bindKeys = function () {
                    var _this = this;
                    var self = this;
                    on(this.element, 'keydown', function (ev) {
                        if (document.activeElement !== this) {
                            return;
                        }
                        self._keyDown(ev);
                    }, true);
                    on(this.element, 'keypress', function (ev) {
                        if (document.activeElement !== this) {
                            return;
                        }
                        self._keyPress(ev);
                    }, true);
                    on(this.element, 'keyup', function (ev) {
                        if (!wasMondifierKeyOnlyEvent(ev)) {
                            _this.focus();
                        }
                    }, true);
                    on(this.textarea, 'keydown', function (ev) {
                        _this._keyDown(ev);
                    }, true);
                    on(this.textarea, 'keypress', function (ev) {
                        _this._keyPress(ev);
                        _this.textarea.value = '';
                    }, true);
                    on(this.textarea, 'compositionstart', function () {
                        return _this.compositionHelper.compositionstart();
                    });
                    on(this.textarea, 'compositionupdate', function (e) {
                        return _this.compositionHelper.compositionupdate(e);
                    });
                    on(this.textarea, 'compositionend', function () {
                        return _this.compositionHelper.compositionend();
                    });
                    this.on('refresh', function () {
                        return _this.compositionHelper.updateCompositionElements();
                    });
                    this.on('refresh', function (data) {
                        return _this.queueLinkification(data.start, data.end);
                    });
                };
                Terminal.prototype.open = function (parent) {
                    var _this = this;
                    var i = 0;
                    var div;
                    this.parent = parent || this.parent;
                    if (!this.parent) {
                        throw new Error('Terminal requires a parent element.');
                    }
                    this.context = this.parent.ownerDocument.defaultView;
                    this.document = this.parent.ownerDocument;
                    this.body = this.document.body;
                    this.element = this.document.createElement('div');
                    this.element.classList.add('terminal');
                    this.element.classList.add('xterm');
                    this.element.setAttribute('tabindex', '0');
                    this.parent.appendChild(this.element);
                    var fragment = document.createDocumentFragment();
                    this.viewportElement = document.createElement('div');
                    this.viewportElement.classList.add('xterm-viewport');
                    fragment.appendChild(this.viewportElement);
                    this.viewportScrollArea = document.createElement('div');
                    this.viewportScrollArea.classList.add('xterm-scroll-area');
                    this.viewportElement.appendChild(this.viewportScrollArea);
                    this.screenElement = document.createElement('div');
                    this.screenElement.classList.add('xterm-screen');
                    this.helperContainer = document.createElement('div');
                    this.helperContainer.classList.add('xterm-helpers');
                    this.screenElement.appendChild(this.helperContainer);
                    fragment.appendChild(this.screenElement);
                    this._mouseZoneManager = new MouseZoneManager_1.MouseZoneManager(this);
                    this.on('scroll', function () {
                        return _this._mouseZoneManager.clearAll();
                    });
                    this.linkifier.attachToDom(this._mouseZoneManager);
                    this.textarea = document.createElement('textarea');
                    this.textarea.classList.add('xterm-helper-textarea');
                    this.textarea.setAttribute('autocorrect', 'off');
                    this.textarea.setAttribute('autocapitalize', 'off');
                    this.textarea.setAttribute('spellcheck', 'false');
                    this.textarea.tabIndex = 0;
                    this.textarea.addEventListener('focus', function () {
                        return _this._onTextAreaFocus();
                    });
                    this.textarea.addEventListener('blur', function () {
                        return _this._onTextAreaBlur();
                    });
                    this.helperContainer.appendChild(this.textarea);
                    this.compositionView = document.createElement('div');
                    this.compositionView.classList.add('composition-view');
                    this.compositionHelper = new CompositionHelper_1.CompositionHelper(this.textarea, this.compositionView, this);
                    this.helperContainer.appendChild(this.compositionView);
                    this.charSizeStyleElement = document.createElement('style');
                    this.helperContainer.appendChild(this.charSizeStyleElement);
                    this.charMeasure = new CharMeasure_1.CharMeasure(document, this.helperContainer);
                    this.syncBellSound();
                    this.element.appendChild(fragment);
                    this.renderer = new Renderer_1.Renderer(this, this.options.theme);
                    this.options.theme = null;
                    this.viewport = new Viewport_1.Viewport(this, this.viewportElement, this.viewportScrollArea, this.charMeasure);
                    this.viewport.onThemeChanged(this.renderer.colorManager.colors);
                    this.on('cursormove', function () {
                        return _this.renderer.onCursorMove();
                    });
                    this.on('resize', function () {
                        return _this.renderer.onResize(_this.cols, _this.rows, false);
                    });
                    this.on('blur', function () {
                        return _this.renderer.onBlur();
                    });
                    this.on('focus', function () {
                        return _this.renderer.onFocus();
                    });
                    this.charMeasure.on('charsizechanged', function () {
                        return _this.renderer.onResize(_this.cols, _this.rows, true);
                    });
                    this.renderer.on('resize', function (dimensions) {
                        return _this.viewport.syncScrollArea();
                    });
                    this.selectionManager = new SelectionManager_1.SelectionManager(this, this.charMeasure);
                    this.element.addEventListener('mousedown', function (e) {
                        return _this.selectionManager.onMouseDown(e);
                    });
                    this.selectionManager.on('refresh', function (data) {
                        return _this.renderer.onSelectionChanged(data.start, data.end);
                    });
                    this.selectionManager.on('newselection', function (text) {
                        _this.textarea.value = text;
                        _this.textarea.focus();
                        _this.textarea.select();
                    });
                    this.on('scroll', function () {
                        _this.viewport.syncScrollArea();
                        _this.selectionManager.refresh();
                    });
                    this.viewportElement.addEventListener('scroll', function () {
                        return _this.selectionManager.refresh();
                    });
                    this.mouseHelper = new MouseHelper_1.MouseHelper(this.renderer);
                    this.charMeasure.measure(this.options);
                    this.refresh(0, this.rows - 1);
                    this.initGlobal();
                    this.bindMouse();
                };
                Terminal.prototype._setTheme = function (theme) {
                    var colors = this.renderer.setTheme(theme);
                    if (this.viewport) {
                        this.viewport.onThemeChanged(colors);
                    }
                };
                Terminal.applyAddon = function (addon) {
                    addon.apply(Terminal);
                };
                Terminal.prototype.bindMouse = function () {
                    var _this = this;
                    var el = this.element;
                    var self = this;
                    var pressed = 32;
                    function sendButton(ev) {
                        var button;
                        var pos;
                        button = getButton(ev);
                        pos = self.mouseHelper.getRawByteCoords(ev, self.screenElement, self.charMeasure, self.options.lineHeight, self.cols, self.rows);
                        if (!pos) return;
                        sendEvent(button, pos);
                        switch (ev.overrideType || ev.type) {
                            case 'mousedown':
                                pressed = button;
                                break;
                            case 'mouseup':
                                pressed = 32;
                                break;
                            case 'wheel':
                                break;
                        }
                    }
                    function sendMove(ev) {
                        var button = pressed;
                        var pos = self.mouseHelper.getRawByteCoords(ev, self.screenElement, self.charMeasure, self.options.lineHeight, self.cols, self.rows);
                        if (!pos) return;
                        button += 32;
                        sendEvent(button, pos);
                    }
                    function encode(data, ch) {
                        if (!self.utfMouse) {
                            if (ch === 255) {
                                data.push(0);
                                return;
                            }
                            if (ch > 127) ch = 127;
                            data.push(ch);
                        } else {
                            if (ch === 2047) {
                                data.push(0);
                                return;
                            }
                            if (ch < 127) {
                                data.push(ch);
                            } else {
                                if (ch > 2047) ch = 2047;
                                data.push(0xC0 | ch >> 6);
                                data.push(0x80 | ch & 0x3F);
                            }
                        }
                    }
                    function sendEvent(button, pos) {
                        if (self.vt300Mouse) {
                            button &= 3;
                            pos.x -= 32;
                            pos.y -= 32;
                            var data_1 = EscapeSequences_1.C0.ESC + '[24';
                            if (button === 0) data_1 += '1';else if (button === 1) data_1 += '3';else if (button === 2) data_1 += '5';else if (button === 3) return;else data_1 += '0';
                            data_1 += '~[' + pos.x + ',' + pos.y + ']\r';
                            self.send(data_1);
                            return;
                        }
                        if (self.decLocator) {
                            button &= 3;
                            pos.x -= 32;
                            pos.y -= 32;
                            if (button === 0) button = 2;else if (button === 1) button = 4;else if (button === 2) button = 6;else if (button === 3) button = 3;
                            self.send(EscapeSequences_1.C0.ESC + '[' + button + ';' + (button === 3 ? 4 : 0) + ';' + pos.y + ';' + pos.x + ';' + pos.page || 0 + '&w');
                            return;
                        }
                        if (self.urxvtMouse) {
                            pos.x -= 32;
                            pos.y -= 32;
                            pos.x++;
                            pos.y++;
                            self.send(EscapeSequences_1.C0.ESC + '[' + button + ';' + pos.x + ';' + pos.y + 'M');
                            return;
                        }
                        if (self.sgrMouse) {
                            pos.x -= 32;
                            pos.y -= 32;
                            self.send(EscapeSequences_1.C0.ESC + '[<' + (((button & 3) === 3 ? button & ~3 : button) - 32) + ';' + pos.x + ';' + pos.y + ((button & 3) === 3 ? 'm' : 'M'));
                            return;
                        }
                        var data = [];
                        encode(data, button);
                        encode(data, pos.x);
                        encode(data, pos.y);
                        self.send(EscapeSequences_1.C0.ESC + '[M' + String.fromCharCode.apply(String, data));
                    }
                    function getButton(ev) {
                        var button;
                        var shift;
                        var meta;
                        var ctrl;
                        var mod;
                        switch (ev.overrideType || ev.type) {
                            case 'mousedown':
                                button = ev.button != null ? +ev.button : ev.which != null ? ev.which - 1 : null;
                                if (Browser.isMSIE) {
                                    button = button === 1 ? 0 : button === 4 ? 1 : button;
                                }
                                break;
                            case 'mouseup':
                                button = 3;
                                break;
                            case 'DOMMouseScroll':
                                button = ev.detail < 0 ? 64 : 65;
                                break;
                            case 'wheel':
                                button = ev.wheelDeltaY > 0 ? 64 : 65;
                                break;
                        }
                        shift = ev.shiftKey ? 4 : 0;
                        meta = ev.metaKey ? 8 : 0;
                        ctrl = ev.ctrlKey ? 16 : 0;
                        mod = shift | meta | ctrl;
                        if (self.vt200Mouse) {
                            mod &= ctrl;
                        } else if (!self.normalMouse) {
                            mod = 0;
                        }
                        button = 32 + (mod << 2) + button;
                        return button;
                    }
                    on(el, 'mousedown', function (ev) {
                        ev.preventDefault();
                        _this.focus();
                        if (!_this.mouseEvents || _this.selectionManager.shouldForceSelection(ev)) {
                            return;
                        }
                        sendButton(ev);
                        if (_this.vt200Mouse) {
                            ev.overrideType = 'mouseup';
                            sendButton(ev);
                            return _this.cancel(ev);
                        }
                        if (_this.normalMouse) on(_this.document, 'mousemove', sendMove);
                        if (!_this.x10Mouse) {
                            var handler_1 = function handler_1(ev) {
                                sendButton(ev);
                                if (_this.normalMouse) off(_this.document, 'mousemove', sendMove);
                                off(_this.document, 'mouseup', handler_1);
                                return _this.cancel(ev);
                            };
                            on(_this.document, 'mouseup', handler_1);
                        }
                        return _this.cancel(ev);
                    });
                    on(el, 'wheel', function (ev) {
                        if (!_this.mouseEvents) return;
                        if (_this.x10Mouse || _this.vt300Mouse || _this.decLocator) return;
                        sendButton(ev);
                        ev.preventDefault();
                    });
                    on(el, 'wheel', function (ev) {
                        if (_this.mouseEvents) return;
                        _this.viewport.onWheel(ev);
                        return _this.cancel(ev);
                    });
                    on(el, 'touchstart', function (ev) {
                        if (_this.mouseEvents) return;
                        _this.viewport.onTouchStart(ev);
                        return _this.cancel(ev);
                    });
                    on(el, 'touchmove', function (ev) {
                        if (_this.mouseEvents) return;
                        _this.viewport.onTouchMove(ev);
                        return _this.cancel(ev);
                    });
                };
                Terminal.prototype.destroy = function () {
                    _super.prototype.destroy.call(this);
                    this.readable = false;
                    this.writable = false;
                    this.handler = function () {};
                    this.write = function () {};
                    if (this.element && this.element.parentNode) {
                        this.element.parentNode.removeChild(this.element);
                    }
                };
                Terminal.prototype.refresh = function (start, end) {
                    if (this.renderer) {
                        this.renderer.queueRefresh(start, end);
                    }
                };
                Terminal.prototype.queueLinkification = function (start, end) {
                    if (this.linkifier) {
                        this.linkifier.linkifyRows(start, end);
                    }
                };
                Terminal.prototype.showCursor = function () {
                    if (!this.cursorState) {
                        this.cursorState = 1;
                        this.refresh(this.buffer.y, this.buffer.y);
                    }
                };
                Terminal.prototype.scroll = function (isWrapped) {
                    var newLine = this.blankLine(undefined, isWrapped);
                    var topRow = this.buffer.ybase + this.buffer.scrollTop;
                    var bottomRow = this.buffer.ybase + this.buffer.scrollBottom;
                    if (this.buffer.scrollTop === 0) {
                        var willBufferBeTrimmed = this.buffer.lines.length === this.buffer.lines.maxLength;
                        if (bottomRow === this.buffer.lines.length - 1) {
                            this.buffer.lines.push(newLine);
                        } else {
                            this.buffer.lines.splice(bottomRow + 1, 0, newLine);
                        }
                        if (!willBufferBeTrimmed) {
                            this.buffer.ybase++;
                            if (!this.userScrolling) {
                                this.buffer.ydisp++;
                            }
                        } else {
                            if (this.userScrolling) {
                                this.buffer.ydisp = Math.max(this.buffer.ydisp - 1, 0);
                            }
                        }
                    } else {
                        var scrollRegionHeight = bottomRow - topRow + 1;
                        this.buffer.lines.shiftElements(topRow + 1, scrollRegionHeight - 1, -1);
                        this.buffer.lines.set(bottomRow, newLine);
                    }
                    if (!this.userScrolling) {
                        this.buffer.ydisp = this.buffer.ybase;
                    }
                    this.updateRange(this.buffer.scrollTop);
                    this.updateRange(this.buffer.scrollBottom);
                    this.emit('scroll', this.buffer.ydisp);
                };
                Terminal.prototype.scrollLines = function (disp, suppressScrollEvent) {
                    if (disp < 0) {
                        if (this.buffer.ydisp === 0) {
                            return;
                        }
                        this.userScrolling = true;
                    } else if (disp + this.buffer.ydisp >= this.buffer.ybase) {
                        this.userScrolling = false;
                    }
                    var oldYdisp = this.buffer.ydisp;
                    this.buffer.ydisp = Math.max(Math.min(this.buffer.ydisp + disp, this.buffer.ybase), 0);
                    if (oldYdisp === this.buffer.ydisp) {
                        return;
                    }
                    if (!suppressScrollEvent) {
                        this.emit('scroll', this.buffer.ydisp);
                    }
                    this.refresh(0, this.rows - 1);
                };
                Terminal.prototype.scrollPages = function (pageCount) {
                    this.scrollLines(pageCount * (this.rows - 1));
                };
                Terminal.prototype.scrollToTop = function () {
                    this.scrollLines(-this.buffer.ydisp);
                };
                Terminal.prototype.scrollToBottom = function () {
                    this.scrollLines(this.buffer.ybase - this.buffer.ydisp);
                };
                Terminal.prototype.write = function (data) {
                    var _this = this;
                    this.writeBuffer.push(data);
                    if (this.options.useFlowControl && !this.xoffSentToCatchUp && this.writeBuffer.length >= WRITE_BUFFER_PAUSE_THRESHOLD) {
                        this.send(EscapeSequences_1.C0.DC3);
                        this.xoffSentToCatchUp = true;
                    }
                    if (!this.writeInProgress && this.writeBuffer.length > 0) {
                        this.writeInProgress = true;
                        setTimeout(function () {
                            _this.innerWrite();
                        });
                    }
                };
                Terminal.prototype.innerWrite = function () {
                    var _this = this;
                    var writeBatch = this.writeBuffer.splice(0, WRITE_BATCH_SIZE);
                    while (writeBatch.length > 0) {
                        var data = writeBatch.shift();
                        if (this.xoffSentToCatchUp && writeBatch.length === 0 && this.writeBuffer.length === 0) {
                            this.send(EscapeSequences_1.C0.DC1);
                            this.xoffSentToCatchUp = false;
                        }
                        this.refreshStart = this.buffer.y;
                        this.refreshEnd = this.buffer.y;
                        var state = this.parser.parse(data);
                        this.parser.setState(state);
                        this.updateRange(this.buffer.y);
                        this.refresh(this.refreshStart, this.refreshEnd);
                    }
                    if (this.writeBuffer.length > 0) {
                        setTimeout(function () {
                            return _this.innerWrite();
                        }, 0);
                    } else {
                        this.writeInProgress = false;
                    }
                };
                Terminal.prototype.writeln = function (data) {
                    this.write(data + '\r\n');
                };
                Terminal.prototype.attachCustomKeyEventHandler = function (customKeyEventHandler) {
                    this.customKeyEventHandler = customKeyEventHandler;
                };
                Terminal.prototype.setHypertextLinkHandler = function (handler) {
                    if (!this.linkifier) {
                        throw new Error('Cannot attach a hypertext link handler before Terminal.open is called');
                    }
                    this.linkifier.setHypertextLinkHandler(handler);
                    this.refresh(0, this.rows - 1);
                };
                Terminal.prototype.setHypertextValidationCallback = function (callback) {
                    if (!this.linkifier) {
                        throw new Error('Cannot attach a hypertext validation callback before Terminal.open is called');
                    }
                    this.linkifier.setHypertextValidationCallback(callback);
                    this.refresh(0, this.rows - 1);
                };
                Terminal.prototype.registerLinkMatcher = function (regex, handler, options) {
                    if (this.linkifier) {
                        var matcherId = this.linkifier.registerLinkMatcher(regex, handler, options);
                        this.refresh(0, this.rows - 1);
                        return matcherId;
                    }
                    return 0;
                };
                Terminal.prototype.deregisterLinkMatcher = function (matcherId) {
                    if (this.linkifier) {
                        if (this.linkifier.deregisterLinkMatcher(matcherId)) {
                            this.refresh(0, this.rows - 1);
                        }
                    }
                };
                Terminal.prototype.hasSelection = function () {
                    return this.selectionManager ? this.selectionManager.hasSelection : false;
                };
                Terminal.prototype.getSelection = function () {
                    return this.selectionManager ? this.selectionManager.selectionText : '';
                };
                Terminal.prototype.clearSelection = function () {
                    if (this.selectionManager) {
                        this.selectionManager.clearSelection();
                    }
                };
                Terminal.prototype.selectAll = function () {
                    if (this.selectionManager) {
                        this.selectionManager.selectAll();
                    }
                };
                Terminal.prototype._keyDown = function (ev) {
                    if (this.customKeyEventHandler && this.customKeyEventHandler(ev) === false) {
                        return false;
                    }
                    if (!this.compositionHelper.keydown(ev)) {
                        if (this.buffer.ybase !== this.buffer.ydisp) {
                            this.scrollToBottom();
                        }
                        return false;
                    }
                    var result = this._evaluateKeyEscapeSequence(ev);
                    if (result.key === EscapeSequences_1.C0.DC3) {
                        this.writeStopped = true;
                    } else if (result.key === EscapeSequences_1.C0.DC1) {
                        this.writeStopped = false;
                    }
                    if (result.scrollLines) {
                        this.scrollLines(result.scrollLines);
                        return this.cancel(ev, true);
                    }
                    if (this._isThirdLevelShift(this.browser, ev)) {
                        return true;
                    }
                    if (result.cancel) {
                        this.cancel(ev, true);
                    }
                    if (!result.key) {
                        return true;
                    }
                    this.emit('keydown', ev);
                    this.emit('key', result.key, ev);
                    this.showCursor();
                    this.handler(result.key);
                    return this.cancel(ev, true);
                };
                Terminal.prototype._isThirdLevelShift = function (browser, ev) {
                    var thirdLevelKey = browser.isMac && !this.options.macOptionIsMeta && ev.altKey && !ev.ctrlKey && !ev.metaKey || browser.isMSWindows && ev.altKey && ev.ctrlKey && !ev.metaKey;
                    if (ev.type === 'keypress') {
                        return thirdLevelKey;
                    }
                    return thirdLevelKey && (!ev.keyCode || ev.keyCode > 47);
                };
                Terminal.prototype._evaluateKeyEscapeSequence = function (ev) {
                    var result = {
                        cancel: false,
                        key: undefined,
                        scrollLines: undefined
                    };
                    var modifiers = (ev.shiftKey ? 1 : 0) | (ev.altKey ? 2 : 0) | (ev.ctrlKey ? 4 : 0) | (ev.metaKey ? 8 : 0);
                    switch (ev.keyCode) {
                        case 0:
                            if (ev.key === 'UIKeyInputUpArrow') {
                                if (this.applicationCursor) {
                                    result.key = EscapeSequences_1.C0.ESC + 'OA';
                                } else {
                                    result.key = EscapeSequences_1.C0.ESC + '[A';
                                }
                            } else if (ev.key === 'UIKeyInputLeftArrow') {
                                if (this.applicationCursor) {
                                    result.key = EscapeSequences_1.C0.ESC + 'OD';
                                } else {
                                    result.key = EscapeSequences_1.C0.ESC + '[D';
                                }
                            } else if (ev.key === 'UIKeyInputRightArrow') {
                                if (this.applicationCursor) {
                                    result.key = EscapeSequences_1.C0.ESC + 'OC';
                                } else {
                                    result.key = EscapeSequences_1.C0.ESC + '[C';
                                }
                            } else if (ev.key === 'UIKeyInputDownArrow') {
                                if (this.applicationCursor) {
                                    result.key = EscapeSequences_1.C0.ESC + 'OB';
                                } else {
                                    result.key = EscapeSequences_1.C0.ESC + '[B';
                                }
                            }
                            break;
                        case 8:
                            if (ev.shiftKey) {
                                result.key = EscapeSequences_1.C0.BS;
                                break;
                            } else if (ev.altKey) {
                                result.key = EscapeSequences_1.C0.ESC + EscapeSequences_1.C0.DEL;
                                break;
                            }
                            result.key = EscapeSequences_1.C0.DEL;
                            break;
                        case 9:
                            if (ev.shiftKey) {
                                result.key = EscapeSequences_1.C0.ESC + '[Z';
                                break;
                            }
                            result.key = EscapeSequences_1.C0.HT;
                            result.cancel = true;
                            break;
                        case 13:
                            result.key = EscapeSequences_1.C0.CR;
                            result.cancel = true;
                            break;
                        case 27:
                            result.key = EscapeSequences_1.C0.ESC;
                            result.cancel = true;
                            break;
                        case 37:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'D';
                                if (result.key === EscapeSequences_1.C0.ESC + '[1;3D') {
                                    result.key = this.browser.isMac ? EscapeSequences_1.C0.ESC + 'b' : EscapeSequences_1.C0.ESC + '[1;5D';
                                }
                            } else if (this.applicationCursor) {
                                result.key = EscapeSequences_1.C0.ESC + 'OD';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[D';
                            }
                            break;
                        case 39:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'C';
                                if (result.key === EscapeSequences_1.C0.ESC + '[1;3C') {
                                    result.key = this.browser.isMac ? EscapeSequences_1.C0.ESC + 'f' : EscapeSequences_1.C0.ESC + '[1;5C';
                                }
                            } else if (this.applicationCursor) {
                                result.key = EscapeSequences_1.C0.ESC + 'OC';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[C';
                            }
                            break;
                        case 38:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'A';
                                if (result.key === EscapeSequences_1.C0.ESC + '[1;3A') {
                                    result.key = EscapeSequences_1.C0.ESC + '[1;5A';
                                }
                            } else if (this.applicationCursor) {
                                result.key = EscapeSequences_1.C0.ESC + 'OA';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[A';
                            }
                            break;
                        case 40:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'B';
                                if (result.key === EscapeSequences_1.C0.ESC + '[1;3B') {
                                    result.key = EscapeSequences_1.C0.ESC + '[1;5B';
                                }
                            } else if (this.applicationCursor) {
                                result.key = EscapeSequences_1.C0.ESC + 'OB';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[B';
                            }
                            break;
                        case 45:
                            if (!ev.shiftKey && !ev.ctrlKey) {
                                result.key = EscapeSequences_1.C0.ESC + '[2~';
                            }
                            break;
                        case 46:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[3;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[3~';
                            }
                            break;
                        case 36:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'H';
                            } else if (this.applicationCursor) {
                                result.key = EscapeSequences_1.C0.ESC + 'OH';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[H';
                            }
                            break;
                        case 35:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'F';
                            } else if (this.applicationCursor) {
                                result.key = EscapeSequences_1.C0.ESC + 'OF';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[F';
                            }
                            break;
                        case 33:
                            if (ev.shiftKey) {
                                result.scrollLines = -(this.rows - 1);
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[5~';
                            }
                            break;
                        case 34:
                            if (ev.shiftKey) {
                                result.scrollLines = this.rows - 1;
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[6~';
                            }
                            break;
                        case 112:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'P';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + 'OP';
                            }
                            break;
                        case 113:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'Q';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + 'OQ';
                            }
                            break;
                        case 114:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'R';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + 'OR';
                            }
                            break;
                        case 115:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[1;' + (modifiers + 1) + 'S';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + 'OS';
                            }
                            break;
                        case 116:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[15;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[15~';
                            }
                            break;
                        case 117:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[17;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[17~';
                            }
                            break;
                        case 118:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[18;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[18~';
                            }
                            break;
                        case 119:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[19;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[19~';
                            }
                            break;
                        case 120:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[20;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[20~';
                            }
                            break;
                        case 121:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[21;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[21~';
                            }
                            break;
                        case 122:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[23;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[23~';
                            }
                            break;
                        case 123:
                            if (modifiers) {
                                result.key = EscapeSequences_1.C0.ESC + '[24;' + (modifiers + 1) + '~';
                            } else {
                                result.key = EscapeSequences_1.C0.ESC + '[24~';
                            }
                            break;
                        default:
                            if (ev.ctrlKey && !ev.shiftKey && !ev.altKey && !ev.metaKey) {
                                if (ev.keyCode >= 65 && ev.keyCode <= 90) {
                                    result.key = String.fromCharCode(ev.keyCode - 64);
                                } else if (ev.keyCode === 32) {
                                    result.key = String.fromCharCode(0);
                                } else if (ev.keyCode >= 51 && ev.keyCode <= 55) {
                                    result.key = String.fromCharCode(ev.keyCode - 51 + 27);
                                } else if (ev.keyCode === 56) {
                                    result.key = String.fromCharCode(127);
                                } else if (ev.keyCode === 219) {
                                    result.key = String.fromCharCode(27);
                                } else if (ev.keyCode === 220) {
                                    result.key = String.fromCharCode(28);
                                } else if (ev.keyCode === 221) {
                                    result.key = String.fromCharCode(29);
                                }
                            } else if ((!this.browser.isMac || this.options.macOptionIsMeta) && ev.altKey && !ev.ctrlKey && !ev.metaKey) {
                                if (ev.keyCode >= 65 && ev.keyCode <= 90) {
                                    result.key = EscapeSequences_1.C0.ESC + String.fromCharCode(ev.keyCode + 32);
                                } else if (ev.keyCode === 192) {
                                    result.key = EscapeSequences_1.C0.ESC + '`';
                                } else if (ev.keyCode >= 48 && ev.keyCode <= 57) {
                                    result.key = EscapeSequences_1.C0.ESC + (ev.keyCode - 48);
                                }
                            } else if (this.browser.isMac && !ev.altKey && !ev.ctrlKey && ev.metaKey) {
                                if (ev.keyCode === 65) {
                                    this.selectAll();
                                }
                            }
                            break;
                    }
                    return result;
                };
                Terminal.prototype.setgLevel = function (g) {
                    this.glevel = g;
                    this.charset = this.charsets[g];
                };
                Terminal.prototype.setgCharset = function (g, charset) {
                    this.charsets[g] = charset;
                    if (this.glevel === g) {
                        this.charset = charset;
                    }
                };
                Terminal.prototype._keyPress = function (ev) {
                    var key;
                    if (this.customKeyEventHandler && this.customKeyEventHandler(ev) === false) {
                        return false;
                    }
                    this.cancel(ev);
                    if (ev.charCode) {
                        key = ev.charCode;
                    } else if (ev.which == null) {
                        key = ev.keyCode;
                    } else if (ev.which !== 0 && ev.charCode !== 0) {
                        key = ev.which;
                    } else {
                        return false;
                    }
                    if (!key || (ev.altKey || ev.ctrlKey || ev.metaKey) && !this._isThirdLevelShift(this.browser, ev)) {
                        return false;
                    }
                    key = String.fromCharCode(key);
                    this.emit('keypress', key, ev);
                    this.emit('key', key, ev);
                    this.showCursor();
                    this.handler(key);
                    return true;
                };
                Terminal.prototype.send = function (data) {
                    var _this = this;
                    if (!this.sendDataQueue) {
                        setTimeout(function () {
                            _this.handler(_this.sendDataQueue);
                            _this.sendDataQueue = '';
                        }, 1);
                    }
                    this.sendDataQueue += data;
                };
                Terminal.prototype.bell = function () {
                    var _this = this;
                    this.emit('bell');
                    if (this.soundBell()) this.bellAudioElement.play();
                    if (this.visualBell()) {
                        this.element.classList.add('visual-bell-active');
                        clearTimeout(this.visualBellTimer);
                        this.visualBellTimer = window.setTimeout(function () {
                            _this.element.classList.remove('visual-bell-active');
                        }, 200);
                    }
                };
                Terminal.prototype.log = function (text, data) {
                    if (!this.options.debug) return;
                    if (!this.context.console || !this.context.console.log) return;
                    this.context.console.log(text, data);
                };
                Terminal.prototype.error = function (text, data) {
                    if (!this.options.debug) return;
                    if (!this.context.console || !this.context.console.error) return;
                    this.context.console.error(text, data);
                };
                Terminal.prototype.resize = function (x, y) {
                    if (isNaN(x) || isNaN(y)) {
                        return;
                    }
                    if (x === this.cols && y === this.rows) {
                        if (!this.charMeasure.width || !this.charMeasure.height) {
                            this.charMeasure.measure(this.options);
                        }
                        return;
                    }
                    if (x < 1) x = 1;
                    if (y < 1) y = 1;
                    this.buffers.resize(x, y);
                    this.cols = x;
                    this.rows = y;
                    this.buffers.setupTabStops(this.cols);
                    this.charMeasure.measure(this.options);
                    this.refresh(0, this.rows - 1);
                    this.emit('resize', { cols: x, rows: y });
                };
                Terminal.prototype.updateRange = function (y) {
                    if (y < this.refreshStart) this.refreshStart = y;
                    if (y > this.refreshEnd) this.refreshEnd = y;
                };
                Terminal.prototype.maxRange = function () {
                    this.refreshStart = 0;
                    this.refreshEnd = this.rows - 1;
                };
                Terminal.prototype.eraseRight = function (x, y) {
                    var line = this.buffer.lines.get(this.buffer.ybase + y);
                    if (!line) {
                        return;
                    }
                    var ch = [this.eraseAttr(), ' ', 1, 32];
                    for (; x < this.cols; x++) {
                        line[x] = ch;
                    }
                    this.updateRange(y);
                };
                Terminal.prototype.eraseLeft = function (x, y) {
                    var line = this.buffer.lines.get(this.buffer.ybase + y);
                    if (!line) {
                        return;
                    }
                    var ch = [this.eraseAttr(), ' ', 1, 32];
                    x++;
                    while (x--) {
                        line[x] = ch;
                    }
                    this.updateRange(y);
                };
                Terminal.prototype.clear = function () {
                    if (this.buffer.ybase === 0 && this.buffer.y === 0) {
                        return;
                    }
                    this.buffer.lines.set(0, this.buffer.lines.get(this.buffer.ybase + this.buffer.y));
                    this.buffer.lines.length = 1;
                    this.buffer.ydisp = 0;
                    this.buffer.ybase = 0;
                    this.buffer.y = 0;
                    for (var i = 1; i < this.rows; i++) {
                        this.buffer.lines.push(this.blankLine());
                    }
                    this.refresh(0, this.rows - 1);
                    this.emit('scroll', this.buffer.ydisp);
                };
                Terminal.prototype.eraseLine = function (y) {
                    this.eraseRight(0, y);
                };
                Terminal.prototype.blankLine = function (cur, isWrapped, cols) {
                    var attr = cur ? this.eraseAttr() : this.defAttr;
                    var ch = [attr, ' ', 1, 32];
                    var line = [];
                    if (isWrapped) {
                        line.isWrapped = isWrapped;
                    }
                    cols = cols || this.cols;
                    for (var i = 0; i < cols; i++) {
                        line[i] = ch;
                    }
                    return line;
                };
                Terminal.prototype.ch = function (cur) {
                    if (cur) {
                        return [this.eraseAttr(), ' ', 1, 32];
                    }
                    return [this.defAttr, ' ', 1, 32];
                };
                Terminal.prototype.is = function (term) {
                    return (this.options.termName + '').indexOf(term) === 0;
                };
                Terminal.prototype.handler = function (data) {
                    if (this.options.disableStdin) {
                        return;
                    }
                    if (this.selectionManager && this.selectionManager.hasSelection) {
                        this.selectionManager.clearSelection();
                    }
                    if (this.buffer.ybase !== this.buffer.ydisp) {
                        this.scrollToBottom();
                    }
                    this.emit('data', data);
                };
                Terminal.prototype.handleTitle = function (title) {
                    this.emit('title', title);
                };
                Terminal.prototype.index = function () {
                    this.buffer.y++;
                    if (this.buffer.y > this.buffer.scrollBottom) {
                        this.buffer.y--;
                        this.scroll();
                    }
                    if (this.buffer.x >= this.cols) {
                        this.buffer.x--;
                    }
                };
                Terminal.prototype.reverseIndex = function () {
                    if (this.buffer.y === this.buffer.scrollTop) {
                        var scrollRegionHeight = this.buffer.scrollBottom - this.buffer.scrollTop;
                        this.buffer.lines.shiftElements(this.buffer.y + this.buffer.ybase, scrollRegionHeight, 1);
                        this.buffer.lines.set(this.buffer.y + this.buffer.ybase, this.blankLine(true));
                        this.updateRange(this.buffer.scrollTop);
                        this.updateRange(this.buffer.scrollBottom);
                    } else {
                        this.buffer.y--;
                    }
                };
                Terminal.prototype.reset = function () {
                    this.options.rows = this.rows;
                    this.options.cols = this.cols;
                    var customKeyEventHandler = this.customKeyEventHandler;
                    var inputHandler = this.inputHandler;
                    this.setup();
                    this.customKeyEventHandler = customKeyEventHandler;
                    this.inputHandler = inputHandler;
                    this.refresh(0, this.rows - 1);
                    this.viewport.syncScrollArea();
                };
                Terminal.prototype.tabSet = function () {
                    this.buffer.tabs[this.buffer.x] = true;
                };
                Terminal.prototype.cancel = function (ev, force) {
                    if (!this.options.cancelEvents && !force) {
                        return;
                    }
                    ev.preventDefault();
                    ev.stopPropagation();
                    return false;
                };
                Terminal.prototype.matchColor = function (r1, g1, b1) {
                    return matchColor_(r1, g1, b1);
                };
                Terminal.prototype.visualBell = function () {
                    return false;
                };
                Terminal.prototype.soundBell = function () {
                    return this.options.bellStyle === 'sound';
                };
                Terminal.prototype.syncBellSound = function () {
                    if (!this.element) {
                        return;
                    }
                    if (this.soundBell() && this.bellAudioElement) {
                        this.bellAudioElement.setAttribute('src', this.options.bellSound);
                    } else if (this.soundBell()) {
                        this.bellAudioElement = document.createElement('audio');
                        this.bellAudioElement.setAttribute('preload', 'auto');
                        this.bellAudioElement.setAttribute('src', this.options.bellSound);
                        this.helperContainer.appendChild(this.bellAudioElement);
                    } else if (this.bellAudioElement) {
                        this.helperContainer.removeChild(this.bellAudioElement);
                    }
                };
                return Terminal;
            }(EventEmitter_1.EventEmitter);
            exports.Terminal = Terminal;
            function globalOn(el, type, handler, capture) {
                if (!Array.isArray(el)) {
                    el = [el];
                }
                el.forEach(function (element) {
                    element.addEventListener(type, handler, capture || false);
                });
            }
            var on = globalOn;
            function off(el, type, handler, capture) {
                if (capture === void 0) {
                    capture = false;
                }
                el.removeEventListener(type, handler, capture);
            }
            function wasMondifierKeyOnlyEvent(ev) {
                return ev.keyCode === 16 || ev.keyCode === 17 || ev.keyCode === 18;
            }
            var vcolors = function () {
                var result = ColorManager_1.DEFAULT_ANSI_COLORS.map(function (c) {
                    c = c.substring(1);
                    return [parseInt(c.substring(0, 2), 16), parseInt(c.substring(2, 4), 16), parseInt(c.substring(4, 6), 16)];
                });
                var r = [0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff];
                for (var i = 0; i < 216; i++) {
                    result.push([r[i / 36 % 6 | 0], r[i / 6 % 6 | 0], r[i % 6]]);
                }
                var c;
                for (var i = 0; i < 24; i++) {
                    c = 8 + i * 10;
                    result.push([c, c, c]);
                }
                return result;
            }();
            var matchColorCache = {};
            function matchColorDistance(r1, g1, b1, r2, g2, b2) {
                return Math.pow(30 * (r1 - r2), 2) + Math.pow(59 * (g1 - g2), 2) + Math.pow(11 * (b1 - b2), 2);
            }
            function matchColor_(r1, g1, b1) {
                var hash = r1 << 16 | g1 << 8 | b1;
                if (matchColorCache[hash] != null) {
                    return matchColorCache[hash];
                }
                var ldiff = Infinity;
                var li = -1;
                var i = 0;
                var c;
                var r2;
                var g2;
                var b2;
                var diff;
                for (; i < vcolors.length; i++) {
                    c = vcolors[i];
                    r2 = c[0];
                    g2 = c[1];
                    b2 = c[2];
                    diff = matchColorDistance(r1, g1, b1, r2, g2, b2);
                    if (diff === 0) {
                        li = i;
                        break;
                    }
                    if (diff < ldiff) {
                        ldiff = diff;
                        li = i;
                    }
                }
                return matchColorCache[hash] = li;
            }
        }, { "./Buffer": 1, "./BufferSet": 2, "./CompositionHelper": 5, "./EscapeSequences": 6, "./EventEmitter": 7, "./InputHandler": 8, "./Linkifier": 9, "./Parser": 10, "./SelectionManager": 11, "./Viewport": 15, "./handlers/Clipboard": 17, "./input/MouseZoneManager": 18, "./renderer/ColorManager": 21, "./renderer/Renderer": 25, "./shared/utils/Browser": 30, "./utils/CharMeasure": 31, "./utils/MouseHelper": 33, "./utils/Sounds": 35 }], 14: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var LinkHoverEventTypes;
            (function (LinkHoverEventTypes) {
                LinkHoverEventTypes["HOVER"] = "linkhover";
                LinkHoverEventTypes["TOOLTIP"] = "linktooltip";
                LinkHoverEventTypes["LEAVE"] = "linkleave";
            })(LinkHoverEventTypes = exports.LinkHoverEventTypes || (exports.LinkHoverEventTypes = {}));
        }, {}], 15: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var FALLBACK_SCROLL_BAR_WIDTH = 15;
            var Viewport = function () {
                function Viewport(terminal, viewportElement, scrollArea, charMeasure) {
                    var _this = this;
                    this.terminal = terminal;
                    this.viewportElement = viewportElement;
                    this.scrollArea = scrollArea;
                    this.charMeasure = charMeasure;
                    this.scrollBarWidth = 0;
                    this.currentRowHeight = 0;
                    this.lastRecordedBufferLength = 0;
                    this.lastRecordedViewportHeight = 0;
                    this.lastRecordedBufferHeight = 0;
                    this.scrollBarWidth = this.viewportElement.offsetWidth - this.scrollArea.offsetWidth || FALLBACK_SCROLL_BAR_WIDTH;
                    this.viewportElement.addEventListener('scroll', this.onScroll.bind(this));
                    setTimeout(function () {
                        return _this.syncScrollArea();
                    }, 0);
                }
                Viewport.prototype.onThemeChanged = function (colors) {
                    this.viewportElement.style.backgroundColor = colors.background;
                };
                Viewport.prototype.refresh = function () {
                    if (this.charMeasure.height > 0) {
                        this.currentRowHeight = this.terminal.renderer.dimensions.scaledCellHeight / window.devicePixelRatio;
                        this.lastRecordedViewportHeight = this.viewportElement.offsetHeight;
                        var newBufferHeight = Math.round(this.currentRowHeight * this.lastRecordedBufferLength) + (this.lastRecordedViewportHeight - this.terminal.renderer.dimensions.canvasHeight);
                        if (this.lastRecordedBufferHeight !== newBufferHeight) {
                            this.lastRecordedBufferHeight = newBufferHeight;
                            this.scrollArea.style.height = this.lastRecordedBufferHeight + 'px';
                        }
                    }
                };
                Viewport.prototype.syncScrollArea = function () {
                    if (this.lastRecordedBufferLength !== this.terminal.buffer.lines.length) {
                        this.lastRecordedBufferLength = this.terminal.buffer.lines.length;
                        this.refresh();
                    } else if (this.lastRecordedViewportHeight !== this.terminal.renderer.dimensions.canvasHeight) {
                        this.refresh();
                    } else {
                        if (this.terminal.renderer.dimensions.scaledCellHeight / window.devicePixelRatio !== this.currentRowHeight) {
                            this.refresh();
                        }
                    }
                    var scrollTop = this.terminal.buffer.ydisp * this.currentRowHeight;
                    if (this.viewportElement.scrollTop !== scrollTop) {
                        this.viewportElement.scrollTop = scrollTop;
                    }
                };
                Viewport.prototype.onScroll = function (ev) {
                    if (!this.viewportElement.offsetParent) {
                        return;
                    }
                    var newRow = Math.round(this.viewportElement.scrollTop / this.currentRowHeight);
                    var diff = newRow - this.terminal.buffer.ydisp;
                    this.terminal.scrollLines(diff, true);
                };
                Viewport.prototype.onWheel = function (ev) {
                    if (ev.deltaY === 0) {
                        return;
                    }
                    var multiplier = 1;
                    if (ev.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                        multiplier = this.currentRowHeight;
                    } else if (ev.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
                        multiplier = this.currentRowHeight * this.terminal.rows;
                    }
                    this.viewportElement.scrollTop += ev.deltaY * multiplier;
                    ev.preventDefault();
                };
                Viewport.prototype.onTouchStart = function (ev) {
                    this.lastTouchY = ev.touches[0].pageY;
                };
                Viewport.prototype.onTouchMove = function (ev) {
                    var deltaY = this.lastTouchY - ev.touches[0].pageY;
                    this.lastTouchY = ev.touches[0].pageY;
                    if (deltaY === 0) {
                        return;
                    }
                    this.viewportElement.scrollTop += deltaY;
                    ev.preventDefault();
                };
                return Viewport;
            }();
            exports.Viewport = Viewport;
        }, {}], 16: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var EscapeSequences_1 = require("../EscapeSequences");
            var Direction;
            (function (Direction) {
                Direction["Up"] = "A";
                Direction["Down"] = "B";
                Direction["Right"] = "C";
                Direction["Left"] = "D";
            })(Direction || (Direction = {}));
            var AltClickHandler = function () {
                function AltClickHandler(_mouseEvent, _terminal) {
                    this._mouseEvent = _mouseEvent;
                    this._terminal = _terminal;
                    this._lines = this._terminal.buffer.lines;
                    this._startCol = this._terminal.buffer.x;
                    this._startRow = this._terminal.buffer.y;
                    _a = this._terminal.mouseHelper.getCoords(this._mouseEvent, this._terminal.element, this._terminal.charMeasure, this._terminal.options.lineHeight, this._terminal.cols, this._terminal.rows, false).map(function (coordinate) {
                        return coordinate - 1;
                    }), this._endCol = _a[0], this._endRow = _a[1];
                    var _a;
                }
                AltClickHandler.prototype.move = function () {
                    if (this._mouseEvent.altKey) {
                        this._terminal.send(this._arrowSequences());
                    }
                };
                AltClickHandler.prototype._arrowSequences = function () {
                    return this._resetStartingRow() + this._moveToRequestedRow() + this._moveToRequestedCol();
                };
                AltClickHandler.prototype._resetStartingRow = function () {
                    var startRow = this._endRow - this._wrappedRowsForRow(this._endRow);
                    var endRow = this._endRow;
                    if (this._moveToRequestedRow().length === 0) {
                        return '';
                    } else {
                        return repeat(this._bufferLine(this._startCol, this._startRow, this._startCol, this._startRow - this._wrappedRowsForRow(this._startRow), false).length, this._sequence(Direction.Left));
                    }
                };
                AltClickHandler.prototype._moveToRequestedRow = function () {
                    var startRow = this._startRow - this._wrappedRowsForRow(this._startRow);
                    var endRow = this._endRow - this._wrappedRowsForRow(this._endRow);
                    var rowsToMove = Math.abs(startRow - endRow) - this._wrappedRowsCount();
                    return repeat(rowsToMove, this._sequence(this._verticalDirection()));
                };
                AltClickHandler.prototype._moveToRequestedCol = function () {
                    var startRow;
                    if (this._moveToRequestedRow().length > 0) {
                        startRow = this._endRow - this._wrappedRowsForRow(this._endRow);
                    } else {
                        startRow = this._startRow;
                    }
                    var endRow = this._endRow;
                    var direction = this._horizontalDirection();
                    return repeat(this._bufferLine(this._startCol, startRow, this._endCol, endRow, direction === Direction.Right).length, this._sequence(direction));
                };
                AltClickHandler.prototype._wrappedRowsCount = function () {
                    var wrappedRows = 0;
                    var startRow = this._startRow - this._wrappedRowsForRow(this._startRow);
                    var endRow = this._endRow - this._wrappedRowsForRow(this._endRow);
                    for (var i = 0; i < Math.abs(startRow - endRow); i++) {
                        var direction = this._verticalDirection() === Direction.Up ? -1 : 1;
                        if (this._lines.get(startRow + direction * i).isWrapped) {
                            wrappedRows++;
                        }
                    }
                    return wrappedRows;
                };
                AltClickHandler.prototype._wrappedRowsForRow = function (currentRow) {
                    var rowCount = 0;
                    var lineWraps = this._lines.get(currentRow).isWrapped;
                    while (lineWraps && currentRow >= 0 && currentRow < this._terminal.rows) {
                        rowCount++;
                        currentRow--;
                        lineWraps = this._lines.get(currentRow).isWrapped;
                    }
                    return rowCount;
                };
                AltClickHandler.prototype._horizontalDirection = function () {
                    var startRow;
                    if (this._moveToRequestedRow().length > 0) {
                        startRow = this._endRow - this._wrappedRowsForRow(this._endRow);
                    } else {
                        startRow = this._startRow;
                    }
                    if (this._startCol < this._endCol && startRow <= this._endRow || this._startCol >= this._endCol && startRow < this._endRow) {
                        return Direction.Right;
                    } else {
                        return Direction.Left;
                    }
                };
                AltClickHandler.prototype._verticalDirection = function () {
                    if (this._startRow > this._endRow) {
                        return Direction.Up;
                    } else {
                        return Direction.Down;
                    }
                };
                AltClickHandler.prototype._bufferLine = function (startCol, startRow, endCol, endRow, forward) {
                    var currentCol = startCol;
                    var currentRow = startRow;
                    var bufferStr = '';
                    while (currentCol !== endCol || currentRow !== endRow) {
                        currentCol += forward ? 1 : -1;
                        if (forward && currentCol > this._terminal.cols - 1) {
                            bufferStr += this._terminal.buffer.translateBufferLineToString(currentRow, false, startCol, currentCol);
                            currentCol = 0;
                            startCol = 0;
                            currentRow++;
                        } else if (!forward && currentCol < 0) {
                            bufferStr += this._terminal.buffer.translateBufferLineToString(currentRow, false, 0, startCol + 1);
                            currentCol = this._terminal.cols - 1;
                            startCol = currentCol;
                            currentRow--;
                        }
                    }
                    return bufferStr + this._terminal.buffer.translateBufferLineToString(currentRow, false, startCol, currentCol);
                };
                AltClickHandler.prototype._sequence = function (direction) {
                    var mod = this._terminal.applicationCursor ? 'O' : '[';
                    return EscapeSequences_1.C0.ESC + mod + direction;
                };
                return AltClickHandler;
            }();
            exports.AltClickHandler = AltClickHandler;
            function repeat(count, str) {
                count = Math.floor(count);
                var rpt = '';
                for (var i = 0; i < count; i++) {
                    rpt += str;
                }
                return rpt;
            }
        }, { "../EscapeSequences": 6 }], 17: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            function prepareTextForTerminal(text, isMSWindows) {
                if (isMSWindows) {
                    return text.replace(/\r?\n/g, '\r');
                }
                return text;
            }
            exports.prepareTextForTerminal = prepareTextForTerminal;
            function bracketTextForPaste(text, bracketedPasteMode) {
                if (bracketedPasteMode) {
                    return '\x1b[200~' + text + '\x1b[201~';
                }
                return text;
            }
            exports.bracketTextForPaste = bracketTextForPaste;
            function copyHandler(ev, term, selectionManager) {
                if (term.browser.isMSIE) {
                    window.clipboardData.setData('Text', selectionManager.selectionText);
                } else {
                    ev.clipboardData.setData('text/plain', selectionManager.selectionText);
                }
                ev.preventDefault();
            }
            exports.copyHandler = copyHandler;
            function pasteHandler(ev, term) {
                ev.stopPropagation();
                var text;
                var dispatchPaste = function dispatchPaste(text) {
                    text = prepareTextForTerminal(text, term.browser.isMSWindows);
                    text = bracketTextForPaste(text, term.bracketedPasteMode);
                    term.handler(text);
                    term.textarea.value = '';
                    term.emit('paste', text);
                    term.cancel(ev);
                };
                if (term.browser.isMSIE) {
                    if (window.clipboardData) {
                        text = window.clipboardData.getData('Text');
                        dispatchPaste(text);
                    }
                } else {
                    if (ev.clipboardData) {
                        text = ev.clipboardData.getData('text/plain');
                        dispatchPaste(text);
                    }
                }
            }
            exports.pasteHandler = pasteHandler;
            function moveTextAreaUnderMouseCursor(ev, textarea) {
                textarea.style.position = 'fixed';
                textarea.style.width = '20px';
                textarea.style.height = '20px';
                textarea.style.left = ev.clientX - 10 + 'px';
                textarea.style.top = ev.clientY - 10 + 'px';
                textarea.style.zIndex = '1000';
                textarea.focus();
                setTimeout(function () {
                    textarea.style.position = null;
                    textarea.style.width = null;
                    textarea.style.height = null;
                    textarea.style.left = null;
                    textarea.style.top = null;
                    textarea.style.zIndex = null;
                }, 200);
            }
            exports.moveTextAreaUnderMouseCursor = moveTextAreaUnderMouseCursor;
            function rightClickHandler(ev, textarea, selectionManager, shouldSelectWord) {
                moveTextAreaUnderMouseCursor(ev, textarea);
                if (shouldSelectWord && !selectionManager.isClickInSelection(ev)) {
                    selectionManager.selectWordAtCursor(ev);
                }
                textarea.value = selectionManager.selectionText;
                textarea.select();
            }
            exports.rightClickHandler = rightClickHandler;
        }, {}], 18: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var HOVER_DURATION = 500;
            var MouseZoneManager = function () {
                function MouseZoneManager(_terminal) {
                    var _this = this;
                    this._terminal = _terminal;
                    this._zones = [];
                    this._areZonesActive = false;
                    this._tooltipTimeout = null;
                    this._currentZone = null;
                    this._lastHoverCoords = [null, null];
                    this._terminal.element.addEventListener('mousedown', function (e) {
                        return _this._onMouseDown(e);
                    });
                    this._mouseMoveListener = function (e) {
                        return _this._onMouseMove(e);
                    };
                    this._clickListener = function (e) {
                        return _this._onClick(e);
                    };
                }
                MouseZoneManager.prototype.add = function (zone) {
                    this._zones.push(zone);
                    if (this._zones.length === 1) {
                        this._activate();
                    }
                };
                MouseZoneManager.prototype.clearAll = function (start, end) {
                    if (this._zones.length === 0) {
                        return;
                    }
                    if (!end) {
                        start = 0;
                        end = this._terminal.rows - 1;
                    }
                    for (var i = 0; i < this._zones.length; i++) {
                        var zone = this._zones[i];
                        if (zone.y > start && zone.y <= end + 1) {
                            if (this._currentZone && this._currentZone === zone) {
                                this._currentZone.leaveCallback();
                                this._currentZone = null;
                            }
                            this._zones.splice(i--, 1);
                        }
                    }
                    if (this._zones.length === 0) {
                        this._deactivate();
                    }
                };
                MouseZoneManager.prototype._activate = function () {
                    if (!this._areZonesActive) {
                        this._areZonesActive = true;
                        this._terminal.element.addEventListener('mousemove', this._mouseMoveListener);
                        this._terminal.element.addEventListener('click', this._clickListener);
                    }
                };
                MouseZoneManager.prototype._deactivate = function () {
                    if (this._areZonesActive) {
                        this._areZonesActive = false;
                        this._terminal.element.removeEventListener('mousemove', this._mouseMoveListener);
                        this._terminal.element.removeEventListener('click', this._clickListener);
                    }
                };
                MouseZoneManager.prototype._onMouseMove = function (e) {
                    if (this._lastHoverCoords[0] !== e.pageX || this._lastHoverCoords[1] !== e.pageY) {
                        this._onHover(e);
                        this._lastHoverCoords = [e.pageX, e.pageY];
                    }
                };
                MouseZoneManager.prototype._onHover = function (e) {
                    var _this = this;
                    var zone = this._findZoneEventAt(e);
                    if (zone === this._currentZone) {
                        return;
                    }
                    if (this._currentZone) {
                        this._currentZone.leaveCallback();
                        this._currentZone = null;
                        if (this._tooltipTimeout) {
                            clearTimeout(this._tooltipTimeout);
                        }
                    }
                    if (!zone) {
                        return;
                    }
                    this._currentZone = zone;
                    if (zone.hoverCallback) {
                        zone.hoverCallback(e);
                    }
                    this._tooltipTimeout = setTimeout(function () {
                        return _this._onTooltip(e);
                    }, HOVER_DURATION);
                };
                MouseZoneManager.prototype._onTooltip = function (e) {
                    this._tooltipTimeout = null;
                    var zone = this._findZoneEventAt(e);
                    if (zone && zone.tooltipCallback) {
                        zone.tooltipCallback(e);
                    }
                };
                MouseZoneManager.prototype._onMouseDown = function (e) {
                    if (!this._areZonesActive) {
                        return;
                    }
                    var zone = this._findZoneEventAt(e);
                    if (zone) {
                        if (zone.willLinkActivate(e)) {
                            e.preventDefault();
                            e.stopImmediatePropagation();
                        }
                    }
                };
                MouseZoneManager.prototype._onClick = function (e) {
                    var zone = this._findZoneEventAt(e);
                    if (zone) {
                        zone.clickCallback(e);
                        e.preventDefault();
                        e.stopImmediatePropagation();
                    }
                };
                MouseZoneManager.prototype._findZoneEventAt = function (e) {
                    var coords = this._terminal.mouseHelper.getCoords(e, this._terminal.screenElement, this._terminal.charMeasure, this._terminal.options.lineHeight, this._terminal.cols, this._terminal.rows);
                    if (!coords) {
                        return null;
                    }
                    for (var i = 0; i < this._zones.length; i++) {
                        var zone = this._zones[i];
                        if (zone.y === coords[1] && zone.x1 <= coords[0] && zone.x2 > coords[0]) {
                            return zone;
                        }
                    }
                    return null;
                };
                return MouseZoneManager;
            }();
            exports.MouseZoneManager = MouseZoneManager;
            var MouseZone = function () {
                function MouseZone(x1, x2, y, clickCallback, hoverCallback, tooltipCallback, leaveCallback, willLinkActivate) {
                    this.x1 = x1;
                    this.x2 = x2;
                    this.y = y;
                    this.clickCallback = clickCallback;
                    this.hoverCallback = hoverCallback;
                    this.tooltipCallback = tooltipCallback;
                    this.leaveCallback = leaveCallback;
                    this.willLinkActivate = willLinkActivate;
                }
                return MouseZone;
            }();
            exports.MouseZone = MouseZone;
        }, {}], 19: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var CharAtlas_1 = require("./CharAtlas");
            var Buffer_1 = require("../Buffer");
            exports.INVERTED_DEFAULT_COLOR = -1;
            var DIM_OPACITY = 0.5;
            var BaseRenderLayer = function () {
                function BaseRenderLayer(_container, id, zIndex, _alpha, _colors) {
                    this._container = _container;
                    this._alpha = _alpha;
                    this._colors = _colors;
                    this._scaledCharWidth = 0;
                    this._scaledCharHeight = 0;
                    this._scaledCellWidth = 0;
                    this._scaledCellHeight = 0;
                    this._scaledCharLeft = 0;
                    this._scaledCharTop = 0;
                    this._canvas = document.createElement('canvas');
                    this._canvas.classList.add("xterm-" + id + "-layer");
                    this._canvas.style.zIndex = zIndex.toString();
                    this._initCanvas();
                    this._container.appendChild(this._canvas);
                }
                BaseRenderLayer.prototype._initCanvas = function () {
                    this._ctx = this._canvas.getContext('2d', { alpha: this._alpha });
                    if (!this._alpha) {
                        this.clearAll();
                    }
                };
                BaseRenderLayer.prototype.onOptionsChanged = function (terminal) {};
                BaseRenderLayer.prototype.onBlur = function (terminal) {};
                BaseRenderLayer.prototype.onFocus = function (terminal) {};
                BaseRenderLayer.prototype.onCursorMove = function (terminal) {};
                BaseRenderLayer.prototype.onGridChanged = function (terminal, startRow, endRow) {};
                BaseRenderLayer.prototype.onSelectionChanged = function (terminal, start, end) {};
                BaseRenderLayer.prototype.onThemeChanged = function (terminal, colorSet) {
                    this._refreshCharAtlas(terminal, colorSet);
                };
                BaseRenderLayer.prototype.setTransparency = function (terminal, alpha) {
                    if (alpha === this._alpha) {
                        return;
                    }
                    var oldCanvas = this._canvas;
                    this._alpha = alpha;
                    this._canvas = this._canvas.cloneNode();
                    this._initCanvas();
                    this._container.replaceChild(this._canvas, oldCanvas);
                    this._refreshCharAtlas(terminal, this._colors);
                    this.onGridChanged(terminal, 0, terminal.rows - 1);
                };
                BaseRenderLayer.prototype._refreshCharAtlas = function (terminal, colorSet) {
                    var _this = this;
                    if (this._scaledCharWidth <= 0 && this._scaledCharHeight <= 0) {
                        return;
                    }
                    this._charAtlas = null;
                    var result = CharAtlas_1.acquireCharAtlas(terminal, colorSet, this._scaledCharWidth, this._scaledCharHeight);
                    if (result instanceof HTMLCanvasElement) {
                        this._charAtlas = result;
                    } else {
                        result.then(function (bitmap) {
                            return _this._charAtlas = bitmap;
                        });
                    }
                };
                BaseRenderLayer.prototype.resize = function (terminal, dim, charSizeChanged) {
                    this._scaledCellWidth = dim.scaledCellWidth;
                    this._scaledCellHeight = dim.scaledCellHeight;
                    this._scaledCharWidth = dim.scaledCharWidth;
                    this._scaledCharHeight = dim.scaledCharHeight;
                    this._scaledCharLeft = dim.scaledCharLeft;
                    this._scaledCharTop = dim.scaledCharTop;
                    this._canvas.width = dim.scaledCanvasWidth;
                    this._canvas.height = dim.scaledCanvasHeight;
                    this._canvas.style.width = dim.canvasWidth + "px";
                    this._canvas.style.height = dim.canvasHeight + "px";
                    if (!this._alpha) {
                        this.clearAll();
                    }
                    if (charSizeChanged) {
                        this._refreshCharAtlas(terminal, this._colors);
                    }
                };
                BaseRenderLayer.prototype.fillCells = function (x, y, width, height) {
                    this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
                };
                BaseRenderLayer.prototype.fillBottomLineAtCells = function (x, y, width) {
                    if (width === void 0) {
                        width = 1;
                    }
                    this._ctx.fillRect(x * this._scaledCellWidth, (y + 1) * this._scaledCellHeight - window.devicePixelRatio - 1, width * this._scaledCellWidth, window.devicePixelRatio);
                };
                BaseRenderLayer.prototype.fillLeftLineAtCell = function (x, y) {
                    this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, window.devicePixelRatio, this._scaledCellHeight);
                };
                BaseRenderLayer.prototype.strokeRectAtCell = function (x, y, width, height) {
                    this._ctx.lineWidth = window.devicePixelRatio;
                    this._ctx.strokeRect(x * this._scaledCellWidth + window.devicePixelRatio / 2, y * this._scaledCellHeight + window.devicePixelRatio / 2, width * this._scaledCellWidth - window.devicePixelRatio, height * this._scaledCellHeight - window.devicePixelRatio);
                };
                BaseRenderLayer.prototype.clearAll = function () {
                    if (this._alpha) {
                        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
                    } else {
                        this._ctx.fillStyle = this._colors.background;
                        this._ctx.fillRect(0, 0, this._canvas.width, this._canvas.height);
                    }
                };
                BaseRenderLayer.prototype.clearCells = function (x, y, width, height) {
                    if (this._alpha) {
                        this._ctx.clearRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
                    } else {
                        this._ctx.fillStyle = this._colors.background;
                        this._ctx.fillRect(x * this._scaledCellWidth, y * this._scaledCellHeight, width * this._scaledCellWidth, height * this._scaledCellHeight);
                    }
                };
                BaseRenderLayer.prototype.fillCharTrueColor = function (terminal, charData, x, y) {
                    this._ctx.font = this._getFont(terminal, false);
                    this._ctx.textBaseline = 'top';
                    this._clipRow(terminal, y);
                    this._ctx.fillText(charData[Buffer_1.CHAR_DATA_CHAR_INDEX], x * this._scaledCellWidth + this._scaledCharLeft, y * this._scaledCellHeight + this._scaledCharTop);
                };
                BaseRenderLayer.prototype.drawChar = function (terminal, char, code, width, x, y, fg, bg, bold, dim) {
                    var colorIndex = 0;
                    if (fg < 256) {
                        colorIndex = fg + 2;
                    } else {
                        if (bold && terminal.options.enableBold) {
                            colorIndex = 1;
                        }
                    }
                    var isAscii = code < 256;
                    var isBasicColor = colorIndex > 1 && fg < 16 && (fg < 8 || bold);
                    var isDefaultColor = fg >= 256;
                    var isDefaultBackground = bg >= 256;
                    if (this._charAtlas && isAscii && (isBasicColor || isDefaultColor) && isDefaultBackground) {
                        var charAtlasCellWidth = this._scaledCharWidth + CharAtlas_1.CHAR_ATLAS_CELL_SPACING;
                        var charAtlasCellHeight = this._scaledCharHeight + CharAtlas_1.CHAR_ATLAS_CELL_SPACING;
                        if (dim) {
                            this._ctx.globalAlpha = DIM_OPACITY;
                        }
                        if (bold && !terminal.options.enableBold) {
                            if (colorIndex > 1) {
                                colorIndex -= 8;
                            }
                        }
                        this._ctx.drawImage(this._charAtlas, code * charAtlasCellWidth, colorIndex * charAtlasCellHeight, charAtlasCellWidth, this._scaledCharHeight, x * this._scaledCellWidth + this._scaledCharLeft, y * this._scaledCellHeight + this._scaledCharTop, charAtlasCellWidth, this._scaledCharHeight);
                    } else {
                        this._drawUncachedChar(terminal, char, width, fg, x, y, bold && terminal.options.enableBold, dim);
                    }
                };
                BaseRenderLayer.prototype._drawUncachedChar = function (terminal, char, width, fg, x, y, bold, dim) {
                    this._ctx.save();
                    this._ctx.font = this._getFont(terminal, bold);
                    this._ctx.textBaseline = 'top';
                    if (fg === exports.INVERTED_DEFAULT_COLOR) {
                        this._ctx.fillStyle = this._colors.background;
                    } else if (fg < 256) {
                        this._ctx.fillStyle = this._colors.ansi[fg];
                    } else {
                        this._ctx.fillStyle = this._colors.foreground;
                    }
                    this._clipRow(terminal, y);
                    if (dim) {
                        this._ctx.globalAlpha = DIM_OPACITY;
                    }
                    this._ctx.fillText(char, x * this._scaledCellWidth + this._scaledCharLeft, y * this._scaledCellHeight + this._scaledCharTop);
                    this._ctx.restore();
                };
                BaseRenderLayer.prototype._clipRow = function (terminal, y) {
                    this._ctx.beginPath();
                    this._ctx.rect(0, y * this._scaledCellHeight, terminal.cols * this._scaledCellWidth, this._scaledCellHeight);
                    this._ctx.clip();
                };
                BaseRenderLayer.prototype._getFont = function (terminal, isBold) {
                    var fontWeight = isBold ? terminal.options.fontWeightBold : terminal.options.fontWeight;
                    return fontWeight + " " + terminal.options.fontSize * window.devicePixelRatio + "px " + terminal.options.fontFamily;
                };
                return BaseRenderLayer;
            }();
            exports.BaseRenderLayer = BaseRenderLayer;
        }, { "../Buffer": 1, "./CharAtlas": 20 }], 20: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var CharAtlasGenerator_1 = require("../shared/CharAtlasGenerator");
            exports.CHAR_ATLAS_CELL_SPACING = 1;
            var charAtlasCache = [];
            function acquireCharAtlas(terminal, colors, scaledCharWidth, scaledCharHeight) {
                var newConfig = generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors);
                for (var i = 0; i < charAtlasCache.length; i++) {
                    var entry = charAtlasCache[i];
                    var ownedByIndex = entry.ownedBy.indexOf(terminal);
                    if (ownedByIndex >= 0) {
                        if (configEquals(entry.config, newConfig)) {
                            return entry.bitmap;
                        } else {
                            if (entry.ownedBy.length === 1) {
                                charAtlasCache.splice(i, 1);
                            } else {
                                entry.ownedBy.splice(ownedByIndex, 1);
                            }
                            break;
                        }
                    }
                }
                for (var i = 0; i < charAtlasCache.length; i++) {
                    var entry = charAtlasCache[i];
                    if (configEquals(entry.config, newConfig)) {
                        entry.ownedBy.push(terminal);
                        return entry.bitmap;
                    }
                }
                var canvasFactory = function canvasFactory(width, height) {
                    var canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;
                    return canvas;
                };
                var charAtlasConfig = {
                    scaledCharWidth: scaledCharWidth,
                    scaledCharHeight: scaledCharHeight,
                    fontSize: terminal.options.fontSize,
                    fontFamily: terminal.options.fontFamily,
                    fontWeight: terminal.options.fontWeight,
                    fontWeightBold: terminal.options.fontWeightBold,
                    background: colors.background,
                    foreground: colors.foreground,
                    ansiColors: colors.ansi,
                    devicePixelRatio: window.devicePixelRatio,
                    allowTransparency: terminal.options.allowTransparency
                };
                var newEntry = {
                    bitmap: CharAtlasGenerator_1.generateCharAtlas(window, canvasFactory, charAtlasConfig),
                    config: newConfig,
                    ownedBy: [terminal]
                };
                charAtlasCache.push(newEntry);
                return newEntry.bitmap;
            }
            exports.acquireCharAtlas = acquireCharAtlas;
            function generateConfig(scaledCharWidth, scaledCharHeight, terminal, colors) {
                var clonedColors = {
                    foreground: colors.foreground,
                    background: colors.background,
                    cursor: null,
                    cursorAccent: null,
                    selection: null,
                    ansi: colors.ansi.slice(0, 16)
                };
                return {
                    scaledCharWidth: scaledCharWidth,
                    scaledCharHeight: scaledCharHeight,
                    fontFamily: terminal.options.fontFamily,
                    fontSize: terminal.options.fontSize,
                    fontWeight: terminal.options.fontWeight,
                    fontWeightBold: terminal.options.fontWeightBold,
                    allowTransparency: terminal.options.allowTransparency,
                    colors: clonedColors
                };
            }
            function configEquals(a, b) {
                for (var i = 0; i < a.colors.ansi.length; i++) {
                    if (a.colors.ansi[i] !== b.colors.ansi[i]) {
                        return false;
                    }
                }
                return a.fontFamily === b.fontFamily && a.fontSize === b.fontSize && a.fontWeight === b.fontWeight && a.fontWeightBold === b.fontWeightBold && a.allowTransparency === b.allowTransparency && a.scaledCharWidth === b.scaledCharWidth && a.scaledCharHeight === b.scaledCharHeight && a.colors.foreground === b.colors.foreground && a.colors.background === b.colors.background;
            }
        }, { "../shared/CharAtlasGenerator": 29 }], 21: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var DEFAULT_FOREGROUND = '#ffffff';
            var DEFAULT_BACKGROUND = '#000000';
            var DEFAULT_CURSOR = '#ffffff';
            var DEFAULT_CURSOR_ACCENT = '#000000';
            var DEFAULT_SELECTION = 'rgba(255, 255, 255, 0.3)';
            exports.DEFAULT_ANSI_COLORS = ['#2e3436', '#cc0000', '#4e9a06', '#c4a000', '#3465a4', '#75507b', '#06989a', '#d3d7cf', '#555753', '#ef2929', '#8ae234', '#fce94f', '#729fcf', '#ad7fa8', '#34e2e2', '#eeeeec'];
            function generate256Colors(first16Colors) {
                var colors = first16Colors.slice();
                var v = [0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff];
                for (var i = 0; i < 216; i++) {
                    var r = toPaddedHex(v[i / 36 % 6 | 0]);
                    var g = toPaddedHex(v[i / 6 % 6 | 0]);
                    var b = toPaddedHex(v[i % 6]);
                    colors.push("#" + r + g + b);
                }
                for (var i = 0; i < 24; i++) {
                    var c = toPaddedHex(8 + i * 10);
                    colors.push("#" + c + c + c);
                }
                return colors;
            }
            function toPaddedHex(c) {
                var s = c.toString(16);
                return s.length < 2 ? '0' + s : s;
            }
            var ColorManager = function () {
                function ColorManager() {
                    this.colors = {
                        foreground: DEFAULT_FOREGROUND,
                        background: DEFAULT_BACKGROUND,
                        cursor: DEFAULT_CURSOR,
                        cursorAccent: DEFAULT_CURSOR_ACCENT,
                        selection: DEFAULT_SELECTION,
                        ansi: generate256Colors(exports.DEFAULT_ANSI_COLORS)
                    };
                }
                ColorManager.prototype.setTheme = function (theme) {
                    this.colors.foreground = theme.foreground || DEFAULT_FOREGROUND;
                    this.colors.background = theme.background || DEFAULT_BACKGROUND;
                    this.colors.cursor = theme.cursor || DEFAULT_CURSOR;
                    this.colors.cursorAccent = theme.cursorAccent || DEFAULT_CURSOR_ACCENT;
                    this.colors.selection = theme.selection || DEFAULT_SELECTION;
                    this.colors.ansi[0] = theme.black || exports.DEFAULT_ANSI_COLORS[0];
                    this.colors.ansi[1] = theme.red || exports.DEFAULT_ANSI_COLORS[1];
                    this.colors.ansi[2] = theme.green || exports.DEFAULT_ANSI_COLORS[2];
                    this.colors.ansi[3] = theme.yellow || exports.DEFAULT_ANSI_COLORS[3];
                    this.colors.ansi[4] = theme.blue || exports.DEFAULT_ANSI_COLORS[4];
                    this.colors.ansi[5] = theme.magenta || exports.DEFAULT_ANSI_COLORS[5];
                    this.colors.ansi[6] = theme.cyan || exports.DEFAULT_ANSI_COLORS[6];
                    this.colors.ansi[7] = theme.white || exports.DEFAULT_ANSI_COLORS[7];
                    this.colors.ansi[8] = theme.brightBlack || exports.DEFAULT_ANSI_COLORS[8];
                    this.colors.ansi[9] = theme.brightRed || exports.DEFAULT_ANSI_COLORS[9];
                    this.colors.ansi[10] = theme.brightGreen || exports.DEFAULT_ANSI_COLORS[10];
                    this.colors.ansi[11] = theme.brightYellow || exports.DEFAULT_ANSI_COLORS[11];
                    this.colors.ansi[12] = theme.brightBlue || exports.DEFAULT_ANSI_COLORS[12];
                    this.colors.ansi[13] = theme.brightMagenta || exports.DEFAULT_ANSI_COLORS[13];
                    this.colors.ansi[14] = theme.brightCyan || exports.DEFAULT_ANSI_COLORS[14];
                    this.colors.ansi[15] = theme.brightWhite || exports.DEFAULT_ANSI_COLORS[15];
                };
                return ColorManager;
            }();
            exports.ColorManager = ColorManager;
        }, {}], 22: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var Buffer_1 = require("../Buffer");
            var BaseRenderLayer_1 = require("./BaseRenderLayer");
            var BLINK_INTERVAL = 600;
            var CursorRenderLayer = function (_super) {
                __extends(CursorRenderLayer, _super);
                function CursorRenderLayer(container, zIndex, colors) {
                    var _this = _super.call(this, container, 'cursor', zIndex, true, colors) || this;
                    _this._state = {
                        x: null,
                        y: null,
                        isFocused: null,
                        style: null,
                        width: null
                    };
                    _this._cursorRenderers = {
                        'bar': _this._renderBarCursor.bind(_this),
                        'block': _this._renderBlockCursor.bind(_this),
                        'underline': _this._renderUnderlineCursor.bind(_this)
                    };
                    return _this;
                }
                CursorRenderLayer.prototype.resize = function (terminal, dim, charSizeChanged) {
                    _super.prototype.resize.call(this, terminal, dim, charSizeChanged);
                    this._state = {
                        x: null,
                        y: null,
                        isFocused: null,
                        style: null,
                        width: null
                    };
                };
                CursorRenderLayer.prototype.reset = function (terminal) {
                    this._clearCursor();
                    if (this._cursorBlinkStateManager) {
                        this._cursorBlinkStateManager.dispose();
                        this._cursorBlinkStateManager = null;
                        this.onOptionsChanged(terminal);
                    }
                };
                CursorRenderLayer.prototype.onBlur = function (terminal) {
                    if (this._cursorBlinkStateManager) {
                        this._cursorBlinkStateManager.pause();
                    }
                    terminal.refresh(terminal.buffer.y, terminal.buffer.y);
                };
                CursorRenderLayer.prototype.onFocus = function (terminal) {
                    if (this._cursorBlinkStateManager) {
                        this._cursorBlinkStateManager.resume(terminal);
                    } else {
                        terminal.refresh(terminal.buffer.y, terminal.buffer.y);
                    }
                };
                CursorRenderLayer.prototype.onOptionsChanged = function (terminal) {
                    var _this = this;
                    if (terminal.options.cursorBlink) {
                        if (!this._cursorBlinkStateManager) {
                            this._cursorBlinkStateManager = new CursorBlinkStateManager(terminal, function () {
                                _this._render(terminal, true);
                            });
                        }
                    } else {
                        if (this._cursorBlinkStateManager) {
                            this._cursorBlinkStateManager.dispose();
                            this._cursorBlinkStateManager = null;
                        }
                        terminal.refresh(terminal.buffer.y, terminal.buffer.y);
                    }
                };
                CursorRenderLayer.prototype.onCursorMove = function (terminal) {
                    if (this._cursorBlinkStateManager) {
                        this._cursorBlinkStateManager.restartBlinkAnimation(terminal);
                    }
                };
                CursorRenderLayer.prototype.onGridChanged = function (terminal, startRow, endRow) {
                    if (!this._cursorBlinkStateManager || this._cursorBlinkStateManager.isPaused) {
                        this._render(terminal, false);
                    } else {
                        this._cursorBlinkStateManager.restartBlinkAnimation(terminal);
                    }
                };
                CursorRenderLayer.prototype._render = function (terminal, triggeredByAnimationFrame) {
                    if (!terminal.cursorState || terminal.cursorHidden) {
                        this._clearCursor();
                        return;
                    }
                    var cursorY = terminal.buffer.ybase + terminal.buffer.y;
                    var viewportRelativeCursorY = cursorY - terminal.buffer.ydisp;
                    if (viewportRelativeCursorY < 0 || viewportRelativeCursorY >= terminal.rows) {
                        this._clearCursor();
                        return;
                    }
                    var charData = terminal.buffer.lines.get(cursorY)[terminal.buffer.x];
                    if (!charData) {
                        return;
                    }
                    if (!terminal.isFocused) {
                        this._clearCursor();
                        this._ctx.save();
                        this._ctx.fillStyle = this._colors.cursor;
                        this._renderBlurCursor(terminal, terminal.buffer.x, viewportRelativeCursorY, charData);
                        this._ctx.restore();
                        this._state.x = terminal.buffer.x;
                        this._state.y = viewportRelativeCursorY;
                        this._state.isFocused = false;
                        this._state.style = terminal.options.cursorStyle;
                        this._state.width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
                        return;
                    }
                    if (this._cursorBlinkStateManager && !this._cursorBlinkStateManager.isCursorVisible) {
                        this._clearCursor();
                        return;
                    }
                    if (this._state) {
                        if (this._state.x === terminal.buffer.x && this._state.y === viewportRelativeCursorY && this._state.isFocused === terminal.isFocused && this._state.style === terminal.options.cursorStyle && this._state.width === charData[Buffer_1.CHAR_DATA_WIDTH_INDEX]) {
                            return;
                        }
                        this._clearCursor();
                    }
                    this._ctx.save();
                    this._cursorRenderers[terminal.options.cursorStyle || 'block'](terminal, terminal.buffer.x, viewportRelativeCursorY, charData);
                    this._ctx.restore();
                    this._state.x = terminal.buffer.x;
                    this._state.y = viewportRelativeCursorY;
                    this._state.isFocused = false;
                    this._state.style = terminal.options.cursorStyle;
                    this._state.width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
                };
                CursorRenderLayer.prototype._clearCursor = function () {
                    if (this._state) {
                        this.clearCells(this._state.x, this._state.y, this._state.width, 1);
                        this._state = {
                            x: null,
                            y: null,
                            isFocused: null,
                            style: null,
                            width: null
                        };
                    }
                };
                CursorRenderLayer.prototype._renderBarCursor = function (terminal, x, y, charData) {
                    this._ctx.save();
                    this._ctx.fillStyle = this._colors.cursor;
                    this.fillLeftLineAtCell(x, y);
                    this._ctx.restore();
                };
                CursorRenderLayer.prototype._renderBlockCursor = function (terminal, x, y, charData) {
                    this._ctx.save();
                    this._ctx.fillStyle = this._colors.cursor;
                    this.fillCells(x, y, charData[Buffer_1.CHAR_DATA_WIDTH_INDEX], 1);
                    this._ctx.fillStyle = this._colors.cursorAccent;
                    this.fillCharTrueColor(terminal, charData, x, y);
                    this._ctx.restore();
                };
                CursorRenderLayer.prototype._renderUnderlineCursor = function (terminal, x, y, charData) {
                    this._ctx.save();
                    this._ctx.fillStyle = this._colors.cursor;
                    this.fillBottomLineAtCells(x, y);
                    this._ctx.restore();
                };
                CursorRenderLayer.prototype._renderBlurCursor = function (terminal, x, y, charData) {
                    this._ctx.save();
                    this._ctx.strokeStyle = this._colors.cursor;
                    this.strokeRectAtCell(x, y, charData[Buffer_1.CHAR_DATA_WIDTH_INDEX], 1);
                    this._ctx.restore();
                };
                return CursorRenderLayer;
            }(BaseRenderLayer_1.BaseRenderLayer);
            exports.CursorRenderLayer = CursorRenderLayer;
            var CursorBlinkStateManager = function () {
                function CursorBlinkStateManager(terminal, renderCallback) {
                    this.renderCallback = renderCallback;
                    this.isCursorVisible = true;
                    if (terminal.isFocused) {
                        this._restartInterval();
                    }
                }
                Object.defineProperty(CursorBlinkStateManager.prototype, "isPaused", {
                    get: function get() {
                        return !(this._blinkStartTimeout || this._blinkInterval);
                    },
                    enumerable: true,
                    configurable: true
                });
                CursorBlinkStateManager.prototype.dispose = function () {
                    if (this._blinkInterval) {
                        window.clearInterval(this._blinkInterval);
                        this._blinkInterval = null;
                    }
                    if (this._blinkStartTimeout) {
                        window.clearTimeout(this._blinkStartTimeout);
                        this._blinkStartTimeout = null;
                    }
                    if (this._animationFrame) {
                        window.cancelAnimationFrame(this._animationFrame);
                        this._animationFrame = null;
                    }
                };
                CursorBlinkStateManager.prototype.restartBlinkAnimation = function (terminal) {
                    var _this = this;
                    if (this.isPaused) {
                        return;
                    }
                    this._animationTimeRestarted = Date.now();
                    this.isCursorVisible = true;
                    if (!this._animationFrame) {
                        this._animationFrame = window.requestAnimationFrame(function () {
                            _this.renderCallback();
                            _this._animationFrame = null;
                        });
                    }
                };
                CursorBlinkStateManager.prototype._restartInterval = function (timeToStart) {
                    var _this = this;
                    if (timeToStart === void 0) {
                        timeToStart = BLINK_INTERVAL;
                    }
                    if (this._blinkInterval) {
                        window.clearInterval(this._blinkInterval);
                    }
                    this._blinkStartTimeout = setTimeout(function () {
                        if (_this._animationTimeRestarted) {
                            var time = BLINK_INTERVAL - (Date.now() - _this._animationTimeRestarted);
                            _this._animationTimeRestarted = null;
                            if (time > 0) {
                                _this._restartInterval(time);
                                return;
                            }
                        }
                        _this.isCursorVisible = false;
                        _this._animationFrame = window.requestAnimationFrame(function () {
                            _this.renderCallback();
                            _this._animationFrame = null;
                        });
                        _this._blinkInterval = setInterval(function () {
                            if (_this._animationTimeRestarted) {
                                var time = BLINK_INTERVAL - (Date.now() - _this._animationTimeRestarted);
                                _this._animationTimeRestarted = null;
                                _this._restartInterval(time);
                                return;
                            }
                            _this.isCursorVisible = !_this.isCursorVisible;
                            _this._animationFrame = window.requestAnimationFrame(function () {
                                _this.renderCallback();
                                _this._animationFrame = null;
                            });
                        }, BLINK_INTERVAL);
                    }, timeToStart);
                };
                CursorBlinkStateManager.prototype.pause = function () {
                    this.isCursorVisible = true;
                    if (this._blinkInterval) {
                        window.clearInterval(this._blinkInterval);
                        this._blinkInterval = null;
                    }
                    if (this._blinkStartTimeout) {
                        window.clearTimeout(this._blinkStartTimeout);
                        this._blinkStartTimeout = null;
                    }
                    if (this._animationFrame) {
                        window.cancelAnimationFrame(this._animationFrame);
                        this._animationFrame = null;
                    }
                };
                CursorBlinkStateManager.prototype.resume = function (terminal) {
                    this._animationTimeRestarted = null;
                    this._restartInterval();
                    this.restartBlinkAnimation(terminal);
                };
                return CursorBlinkStateManager;
            }();
        }, { "../Buffer": 1, "./BaseRenderLayer": 19 }], 23: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var GridCache = function () {
                function GridCache() {
                    this.cache = [];
                }
                GridCache.prototype.resize = function (width, height) {
                    for (var x = 0; x < width; x++) {
                        if (this.cache.length <= x) {
                            this.cache.push([]);
                        }
                        for (var y = this.cache[x].length; y < height; y++) {
                            this.cache[x].push(null);
                        }
                        this.cache[x].length = height;
                    }
                    this.cache.length = width;
                };
                GridCache.prototype.clear = function () {
                    for (var x = 0; x < this.cache.length; x++) {
                        for (var y = 0; y < this.cache[x].length; y++) {
                            this.cache[x][y] = null;
                        }
                    }
                };
                return GridCache;
            }();
            exports.GridCache = GridCache;
        }, {}], 24: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var Types_1 = require("../Types");
            var BaseRenderLayer_1 = require("./BaseRenderLayer");
            var LinkRenderLayer = function (_super) {
                __extends(LinkRenderLayer, _super);
                function LinkRenderLayer(container, zIndex, colors, terminal) {
                    var _this = _super.call(this, container, 'link', zIndex, true, colors) || this;
                    _this._state = null;
                    terminal.linkifier.on(Types_1.LinkHoverEventTypes.HOVER, function (e) {
                        return _this._onLinkHover(e);
                    });
                    terminal.linkifier.on(Types_1.LinkHoverEventTypes.LEAVE, function (e) {
                        return _this._onLinkLeave(e);
                    });
                    return _this;
                }
                LinkRenderLayer.prototype.resize = function (terminal, dim, charSizeChanged) {
                    _super.prototype.resize.call(this, terminal, dim, charSizeChanged);
                    this._state = null;
                };
                LinkRenderLayer.prototype.reset = function (terminal) {
                    this._clearCurrentLink();
                };
                LinkRenderLayer.prototype._clearCurrentLink = function () {
                    if (this._state) {
                        this.clearCells(this._state.x, this._state.y, this._state.length, 1);
                        this._state = null;
                    }
                };
                LinkRenderLayer.prototype._onLinkHover = function (e) {
                    this._ctx.fillStyle = this._colors.foreground;
                    this.fillBottomLineAtCells(e.x, e.y, e.length);
                    this._state = e;
                };
                LinkRenderLayer.prototype._onLinkLeave = function (e) {
                    this._clearCurrentLink();
                };
                return LinkRenderLayer;
            }(BaseRenderLayer_1.BaseRenderLayer);
            exports.LinkRenderLayer = LinkRenderLayer;
        }, { "../Types": 14, "./BaseRenderLayer": 19 }], 25: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var TextRenderLayer_1 = require("./TextRenderLayer");
            var SelectionRenderLayer_1 = require("./SelectionRenderLayer");
            var CursorRenderLayer_1 = require("./CursorRenderLayer");
            var ColorManager_1 = require("./ColorManager");
            var LinkRenderLayer_1 = require("./LinkRenderLayer");
            var EventEmitter_1 = require("../EventEmitter");
            var ScreenDprMonitor_1 = require("../utils/ScreenDprMonitor");
            var Renderer = function (_super) {
                __extends(Renderer, _super);
                function Renderer(_terminal, theme) {
                    var _this = _super.call(this) || this;
                    _this._terminal = _terminal;
                    _this._refreshRowsQueue = [];
                    _this._refreshAnimationFrame = null;
                    _this._isPaused = false;
                    _this._needsFullRefresh = false;
                    _this.colorManager = new ColorManager_1.ColorManager();
                    if (theme) {
                        _this.colorManager.setTheme(theme);
                    }
                    _this._renderLayers = [new TextRenderLayer_1.TextRenderLayer(_this._terminal.screenElement, 0, _this.colorManager.colors, _this._terminal.options.allowTransparency), new SelectionRenderLayer_1.SelectionRenderLayer(_this._terminal.screenElement, 1, _this.colorManager.colors), new LinkRenderLayer_1.LinkRenderLayer(_this._terminal.screenElement, 2, _this.colorManager.colors, _this._terminal), new CursorRenderLayer_1.CursorRenderLayer(_this._terminal.screenElement, 3, _this.colorManager.colors)];
                    _this.dimensions = {
                        scaledCharWidth: null,
                        scaledCharHeight: null,
                        scaledCellWidth: null,
                        scaledCellHeight: null,
                        scaledCharLeft: null,
                        scaledCharTop: null,
                        scaledCanvasWidth: null,
                        scaledCanvasHeight: null,
                        canvasWidth: null,
                        canvasHeight: null,
                        actualCellWidth: null,
                        actualCellHeight: null
                    };
                    _this._devicePixelRatio = window.devicePixelRatio;
                    _this._updateDimensions();
                    _this.onOptionsChanged();
                    _this._screenDprMonitor = new ScreenDprMonitor_1.ScreenDprMonitor();
                    _this._screenDprMonitor.setListener(function () {
                        return _this.onWindowResize(window.devicePixelRatio);
                    });
                    if ('IntersectionObserver' in window) {
                        var observer = new IntersectionObserver(function (e) {
                            return _this.onIntersectionChange(e[0]);
                        }, { threshold: 0 });
                        observer.observe(_this._terminal.element);
                    }
                    return _this;
                }
                Renderer.prototype.onIntersectionChange = function (entry) {
                    this._isPaused = entry.intersectionRatio === 0;
                    if (!this._isPaused && this._needsFullRefresh) {
                        this._terminal.refresh(0, this._terminal.rows - 1);
                    }
                };
                Renderer.prototype.onWindowResize = function (devicePixelRatio) {
                    if (this._devicePixelRatio !== devicePixelRatio) {
                        this._devicePixelRatio = devicePixelRatio;
                        this.onResize(this._terminal.cols, this._terminal.rows, true);
                    }
                };
                Renderer.prototype.setTheme = function (theme) {
                    var _this = this;
                    this.colorManager.setTheme(theme);
                    this._renderLayers.forEach(function (l) {
                        l.onThemeChanged(_this._terminal, _this.colorManager.colors);
                        l.reset(_this._terminal);
                    });
                    if (this._isPaused) {
                        this._needsFullRefresh = true;
                    } else {
                        this._terminal.refresh(0, this._terminal.rows - 1);
                    }
                    return this.colorManager.colors;
                };
                Renderer.prototype.onResize = function (cols, rows, didCharSizeChange) {
                    var _this = this;
                    this._updateDimensions();
                    this._renderLayers.forEach(function (l) {
                        return l.resize(_this._terminal, _this.dimensions, didCharSizeChange);
                    });
                    if (this._isPaused) {
                        this._needsFullRefresh = true;
                    } else {
                        this._terminal.refresh(0, this._terminal.rows - 1);
                    }
                    this._terminal.screenElement.style.width = this.dimensions.canvasWidth + this._terminal.viewport.scrollBarWidth + "px";
                    this._terminal.screenElement.style.height = this.dimensions.canvasHeight + "px";
                    this.emit('resize', {
                        width: this.dimensions.canvasWidth,
                        height: this.dimensions.canvasHeight
                    });
                };
                Renderer.prototype.onCharSizeChanged = function () {
                    this.onResize(this._terminal.cols, this._terminal.rows, true);
                };
                Renderer.prototype.onBlur = function () {
                    var _this = this;
                    this._runOperation(function (l) {
                        return l.onBlur(_this._terminal);
                    });
                };
                Renderer.prototype.onFocus = function () {
                    var _this = this;
                    this._runOperation(function (l) {
                        return l.onFocus(_this._terminal);
                    });
                };
                Renderer.prototype.onSelectionChanged = function (start, end) {
                    var _this = this;
                    this._runOperation(function (l) {
                        return l.onSelectionChanged(_this._terminal, start, end);
                    });
                };
                Renderer.prototype.onCursorMove = function () {
                    var _this = this;
                    this._runOperation(function (l) {
                        return l.onCursorMove(_this._terminal);
                    });
                };
                Renderer.prototype.onOptionsChanged = function () {
                    var _this = this;
                    this._runOperation(function (l) {
                        return l.onOptionsChanged(_this._terminal);
                    });
                };
                Renderer.prototype.clear = function () {
                    var _this = this;
                    this._runOperation(function (l) {
                        return l.reset(_this._terminal);
                    });
                };
                Renderer.prototype._runOperation = function (operation) {
                    if (this._isPaused) {
                        this._needsFullRefresh = true;
                    } else {
                        this._renderLayers.forEach(function (l) {
                            return operation(l);
                        });
                    }
                };
                Renderer.prototype.queueRefresh = function (start, end) {
                    if (this._isPaused) {
                        this._needsFullRefresh = true;
                        return;
                    }
                    this._refreshRowsQueue.push({ start: start, end: end });
                    if (!this._refreshAnimationFrame) {
                        this._refreshAnimationFrame = window.requestAnimationFrame(this._refreshLoop.bind(this));
                    }
                };
                Renderer.prototype._refreshLoop = function () {
                    var _this = this;
                    var start;
                    var end;
                    if (this._refreshRowsQueue.length > 4) {
                        start = 0;
                        end = this._terminal.rows - 1;
                    } else {
                        start = this._refreshRowsQueue[0].start;
                        end = this._refreshRowsQueue[0].end;
                        for (var i = 1; i < this._refreshRowsQueue.length; i++) {
                            if (this._refreshRowsQueue[i].start < start) {
                                start = this._refreshRowsQueue[i].start;
                            }
                            if (this._refreshRowsQueue[i].end > end) {
                                end = this._refreshRowsQueue[i].end;
                            }
                        }
                    }
                    this._refreshRowsQueue = [];
                    this._refreshAnimationFrame = null;
                    start = Math.max(start, 0);
                    end = Math.min(end, this._terminal.rows - 1);
                    this._renderLayers.forEach(function (l) {
                        return l.onGridChanged(_this._terminal, start, end);
                    });
                    this._terminal.emit('refresh', { start: start, end: end });
                };
                Renderer.prototype._updateDimensions = function () {
                    if (!this._terminal.charMeasure.width || !this._terminal.charMeasure.height) {
                        return;
                    }
                    this.dimensions.scaledCharWidth = Math.floor(this._terminal.charMeasure.width * window.devicePixelRatio);
                    this.dimensions.scaledCharHeight = Math.ceil(this._terminal.charMeasure.height * window.devicePixelRatio);
                    this.dimensions.scaledCellHeight = Math.floor(this.dimensions.scaledCharHeight * this._terminal.options.lineHeight);
                    this.dimensions.scaledCharTop = this._terminal.options.lineHeight === 1 ? 0 : Math.round((this.dimensions.scaledCellHeight - this.dimensions.scaledCharHeight) / 2);
                    this.dimensions.scaledCellWidth = this.dimensions.scaledCharWidth + Math.round(this._terminal.options.letterSpacing);
                    this.dimensions.scaledCharLeft = Math.floor(this._terminal.options.letterSpacing / 2);
                    this.dimensions.scaledCanvasHeight = this._terminal.rows * this.dimensions.scaledCellHeight;
                    this.dimensions.scaledCanvasWidth = this._terminal.cols * this.dimensions.scaledCellWidth;
                    this.dimensions.canvasHeight = Math.round(this.dimensions.scaledCanvasHeight / window.devicePixelRatio);
                    this.dimensions.canvasWidth = Math.round(this.dimensions.scaledCanvasWidth / window.devicePixelRatio);
                    this.dimensions.actualCellHeight = this.dimensions.canvasHeight / this._terminal.rows;
                    this.dimensions.actualCellWidth = this.dimensions.canvasWidth / this._terminal.cols;
                };
                return Renderer;
            }(EventEmitter_1.EventEmitter);
            exports.Renderer = Renderer;
        }, { "../EventEmitter": 7, "../utils/ScreenDprMonitor": 34, "./ColorManager": 21, "./CursorRenderLayer": 22, "./LinkRenderLayer": 24, "./SelectionRenderLayer": 26, "./TextRenderLayer": 27 }], 26: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var BaseRenderLayer_1 = require("./BaseRenderLayer");
            var SelectionRenderLayer = function (_super) {
                __extends(SelectionRenderLayer, _super);
                function SelectionRenderLayer(container, zIndex, colors) {
                    var _this = _super.call(this, container, 'selection', zIndex, true, colors) || this;
                    _this._state = {
                        start: null,
                        end: null
                    };
                    return _this;
                }
                SelectionRenderLayer.prototype.resize = function (terminal, dim, charSizeChanged) {
                    _super.prototype.resize.call(this, terminal, dim, charSizeChanged);
                    this._state = {
                        start: null,
                        end: null
                    };
                };
                SelectionRenderLayer.prototype.reset = function (terminal) {
                    if (this._state.start && this._state.end) {
                        this._state = {
                            start: null,
                            end: null
                        };
                        this.clearAll();
                    }
                };
                SelectionRenderLayer.prototype.onSelectionChanged = function (terminal, start, end) {
                    if (this._state.start === start || this._state.end === end) {
                        return;
                    }
                    this.clearAll();
                    if (!start || !end) {
                        return;
                    }
                    var viewportStartRow = start[1] - terminal.buffer.ydisp;
                    var viewportEndRow = end[1] - terminal.buffer.ydisp;
                    var viewportCappedStartRow = Math.max(viewportStartRow, 0);
                    var viewportCappedEndRow = Math.min(viewportEndRow, terminal.rows - 1);
                    if (viewportCappedStartRow >= terminal.rows || viewportCappedEndRow < 0) {
                        return;
                    }
                    var startCol = viewportStartRow === viewportCappedStartRow ? start[0] : 0;
                    var startRowEndCol = viewportCappedStartRow === viewportCappedEndRow ? end[0] : terminal.cols;
                    this._ctx.fillStyle = this._colors.selection;
                    this.fillCells(startCol, viewportCappedStartRow, startRowEndCol - startCol, 1);
                    var middleRowsCount = Math.max(viewportCappedEndRow - viewportCappedStartRow - 1, 0);
                    this.fillCells(0, viewportCappedStartRow + 1, terminal.cols, middleRowsCount);
                    if (viewportCappedStartRow !== viewportCappedEndRow) {
                        var endCol = viewportEndRow === viewportCappedEndRow ? end[0] : terminal.cols;
                        this.fillCells(0, viewportCappedEndRow, endCol, 1);
                    }
                    this._state.start = [start[0], start[1]];
                    this._state.end = [end[0], end[1]];
                };
                return SelectionRenderLayer;
            }(BaseRenderLayer_1.BaseRenderLayer);
            exports.SelectionRenderLayer = SelectionRenderLayer;
        }, { "./BaseRenderLayer": 19 }], 27: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var Buffer_1 = require("../Buffer");
            var Types_1 = require("./Types");
            var GridCache_1 = require("./GridCache");
            var BaseRenderLayer_1 = require("./BaseRenderLayer");
            var OVERLAP_OWNED_CHAR_DATA = [null, '', 0, -1];
            var TextRenderLayer = function (_super) {
                __extends(TextRenderLayer, _super);
                function TextRenderLayer(container, zIndex, colors, alpha) {
                    var _this = _super.call(this, container, 'text', zIndex, alpha, colors) || this;
                    _this._characterOverlapCache = {};
                    _this._state = new GridCache_1.GridCache();
                    return _this;
                }
                TextRenderLayer.prototype.resize = function (terminal, dim, charSizeChanged) {
                    _super.prototype.resize.call(this, terminal, dim, charSizeChanged);
                    var terminalFont = this._getFont(terminal, false);
                    if (this._characterWidth !== dim.scaledCharWidth || this._characterFont !== terminalFont) {
                        this._characterWidth = dim.scaledCharWidth;
                        this._characterFont = terminalFont;
                        this._characterOverlapCache = {};
                    }
                    this._state.clear();
                    this._state.resize(terminal.cols, terminal.rows);
                };
                TextRenderLayer.prototype.reset = function (terminal) {
                    this._state.clear();
                    this.clearAll();
                };
                TextRenderLayer.prototype.onGridChanged = function (terminal, startRow, endRow) {
                    if (this._state.cache.length === 0) {
                        return;
                    }
                    for (var y = startRow; y <= endRow; y++) {
                        var row = y + terminal.buffer.ydisp;
                        var line = terminal.buffer.lines.get(row);
                        this.clearCells(0, y, terminal.cols, 1);
                        for (var x = 0; x < terminal.cols; x++) {
                            var charData = line[x];
                            var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX];
                            var char = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];
                            var attr = charData[Buffer_1.CHAR_DATA_ATTR_INDEX];
                            var width = charData[Buffer_1.CHAR_DATA_WIDTH_INDEX];
                            if (width === 0) {
                                continue;
                            }
                            if (code === 32) {
                                if (x > 0) {
                                    var previousChar = line[x - 1];
                                    if (this._isOverlapping(previousChar)) {
                                        continue;
                                    }
                                }
                            }
                            var flags = attr >> 18;
                            var bg = attr & 0x1ff;
                            var isDefaultBackground = bg >= 256;
                            var isInvisible = flags & Types_1.FLAGS.INVISIBLE;
                            var isInverted = flags & Types_1.FLAGS.INVERSE;
                            if (!code || code === 32 && isDefaultBackground && !isInverted || isInvisible) {
                                continue;
                            }
                            if (width !== 0 && this._isOverlapping(charData)) {
                                if (x < line.length - 1 && line[x + 1][Buffer_1.CHAR_DATA_CODE_INDEX] === 32) {
                                    width = 2;
                                }
                            }
                            var fg = attr >> 9 & 0x1ff;
                            if (isInverted) {
                                var temp = bg;
                                bg = fg;
                                fg = temp;
                                if (fg === 256) {
                                    fg = BaseRenderLayer_1.INVERTED_DEFAULT_COLOR;
                                }
                                if (bg === 257) {
                                    bg = BaseRenderLayer_1.INVERTED_DEFAULT_COLOR;
                                }
                            }
                            if (width === 2) {}
                            if (bg < 256) {
                                this._ctx.save();
                                this._ctx.fillStyle = bg === BaseRenderLayer_1.INVERTED_DEFAULT_COLOR ? this._colors.foreground : this._colors.ansi[bg];
                                this.fillCells(x, y, width, 1);
                                this._ctx.restore();
                            }
                            this._ctx.save();
                            if (flags & Types_1.FLAGS.BOLD) {
                                this._ctx.font = this._getFont(terminal, true);
                                if (fg < 8) {
                                    fg += 8;
                                }
                            }
                            if (flags & Types_1.FLAGS.UNDERLINE) {
                                if (fg === BaseRenderLayer_1.INVERTED_DEFAULT_COLOR) {
                                    this._ctx.fillStyle = this._colors.background;
                                } else if (fg < 256) {
                                    this._ctx.fillStyle = this._colors.ansi[fg];
                                } else {
                                    this._ctx.fillStyle = this._colors.foreground;
                                }
                                this.fillBottomLineAtCells(x, y);
                            }
                            this.drawChar(terminal, char, code, width, x, y, fg, bg, !!(flags & Types_1.FLAGS.BOLD), !!(flags & Types_1.FLAGS.DIM));
                            this._ctx.restore();
                        }
                    }
                };
                TextRenderLayer.prototype.onOptionsChanged = function (terminal) {
                    this.setTransparency(terminal, terminal.options.allowTransparency);
                };
                TextRenderLayer.prototype._isOverlapping = function (charData) {
                    if (charData[Buffer_1.CHAR_DATA_WIDTH_INDEX] !== 1) {
                        return false;
                    }
                    var code = charData[Buffer_1.CHAR_DATA_CODE_INDEX];
                    if (code < 256) {
                        return false;
                    }
                    var char = charData[Buffer_1.CHAR_DATA_CHAR_INDEX];
                    if (this._characterOverlapCache.hasOwnProperty(char)) {
                        return this._characterOverlapCache[char];
                    }
                    this._ctx.save();
                    this._ctx.font = this._characterFont;
                    var overlaps = Math.floor(this._ctx.measureText(char).width) > this._characterWidth;
                    this._ctx.restore();
                    this._characterOverlapCache[char] = overlaps;
                    return overlaps;
                };
                TextRenderLayer.prototype._clearChar = function (x, y) {
                    var colsToClear = 1;
                    var state = this._state.cache[x][y];
                    if (state && state[Buffer_1.CHAR_DATA_WIDTH_INDEX] === 2) {
                        colsToClear = 2;
                    }
                    this.clearCells(x, y, colsToClear, 1);
                };
                return TextRenderLayer;
            }(BaseRenderLayer_1.BaseRenderLayer);
            exports.TextRenderLayer = TextRenderLayer;
        }, { "../Buffer": 1, "./BaseRenderLayer": 19, "./GridCache": 23, "./Types": 28 }], 28: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var FLAGS;
            (function (FLAGS) {
                FLAGS[FLAGS["BOLD"] = 1] = "BOLD";
                FLAGS[FLAGS["UNDERLINE"] = 2] = "UNDERLINE";
                FLAGS[FLAGS["BLINK"] = 4] = "BLINK";
                FLAGS[FLAGS["INVERSE"] = 8] = "INVERSE";
                FLAGS[FLAGS["INVISIBLE"] = 16] = "INVISIBLE";
                FLAGS[FLAGS["DIM"] = 32] = "DIM";
            })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
        }, {}], 29: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var Browser_1 = require("./utils/Browser");
            exports.CHAR_ATLAS_CELL_SPACING = 1;
            function generateCharAtlas(context, canvasFactory, request) {
                var cellWidth = request.scaledCharWidth + exports.CHAR_ATLAS_CELL_SPACING;
                var cellHeight = request.scaledCharHeight + exports.CHAR_ATLAS_CELL_SPACING;
                var canvas = canvasFactory(255 * cellWidth, (2 + 16) * cellHeight);
                var ctx = canvas.getContext('2d', { alpha: request.allowTransparency });
                ctx.fillStyle = request.background;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.fillStyle = request.foreground;
                ctx.font = getFont(request.fontWeight, request);
                ctx.textBaseline = 'top';
                for (var i = 0; i < 256; i++) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(i * cellWidth, 0, cellWidth, cellHeight);
                    ctx.clip();
                    ctx.fillText(String.fromCharCode(i), i * cellWidth, 0);
                    ctx.restore();
                }
                ctx.save();
                ctx.font = getFont(request.fontWeightBold, request);
                for (var i = 0; i < 256; i++) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(i * cellWidth, cellHeight, cellWidth, cellHeight);
                    ctx.clip();
                    ctx.fillText(String.fromCharCode(i), i * cellWidth, cellHeight);
                    ctx.restore();
                }
                ctx.restore();
                ctx.font = getFont(request.fontWeight, request);
                for (var colorIndex = 0; colorIndex < 16; colorIndex++) {
                    if (colorIndex === 8) {
                        ctx.font = getFont(request.fontWeightBold, request);
                    }
                    var y = (colorIndex + 2) * cellHeight;
                    for (var i = 0; i < 256; i++) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(i * cellWidth, y, cellWidth, cellHeight);
                        ctx.clip();
                        ctx.fillStyle = request.ansiColors[colorIndex];
                        ctx.fillText(String.fromCharCode(i), i * cellWidth, y);
                        ctx.restore();
                    }
                }
                ctx.restore();
                if (!('createImageBitmap' in context) || Browser_1.isFirefox) {
                    if (canvas instanceof HTMLCanvasElement) {
                        return canvas;
                    } else {
                        return new Promise(function (r) {
                            return r(canvas.transferToImageBitmap());
                        });
                    }
                }
                var charAtlasImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                var r = parseInt(request.background.substr(1, 2), 16);
                var g = parseInt(request.background.substr(3, 2), 16);
                var b = parseInt(request.background.substr(5, 2), 16);
                clearColor(charAtlasImageData, r, g, b);
                return context.createImageBitmap(charAtlasImageData);
            }
            exports.generateCharAtlas = generateCharAtlas;
            function clearColor(imageData, r, g, b) {
                for (var offset = 0; offset < imageData.data.length; offset += 4) {
                    if (imageData.data[offset] === r && imageData.data[offset + 1] === g && imageData.data[offset + 2] === b) {
                        imageData.data[offset + 3] = 0;
                    }
                }
            }
            function getFont(fontWeight, request) {
                return fontWeight + " " + request.fontSize * request.devicePixelRatio + "px " + request.fontFamily;
            }
        }, { "./utils/Browser": 30 }], 30: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var isNode = typeof navigator === 'undefined' ? true : false;
            var userAgent = isNode ? 'node' : navigator.userAgent;
            var platform = isNode ? 'node' : navigator.platform;
            exports.isFirefox = !!~userAgent.indexOf('Firefox');
            exports.isMSIE = !!~userAgent.indexOf('MSIE') || !!~userAgent.indexOf('Trident');
            exports.isMac = contains(['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'], platform);
            exports.isIpad = platform === 'iPad';
            exports.isIphone = platform === 'iPhone';
            exports.isMSWindows = contains(['Windows', 'Win16', 'Win32', 'WinCE'], platform);
            exports.isLinux = platform.indexOf('Linux') >= 0;
            function contains(arr, el) {
                return arr.indexOf(el) >= 0;
            }
        }, {}], 31: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var EventEmitter_1 = require("../EventEmitter");
            var CharMeasure = function (_super) {
                __extends(CharMeasure, _super);
                function CharMeasure(document, parentElement) {
                    var _this = _super.call(this) || this;
                    _this._document = document;
                    _this._parentElement = parentElement;
                    _this._measureElement = _this._document.createElement('span');
                    _this._measureElement.style.position = 'absolute';
                    _this._measureElement.style.top = '0';
                    _this._measureElement.style.left = '-9999em';
                    _this._measureElement.style.lineHeight = 'normal';
                    _this._measureElement.textContent = 'W';
                    _this._measureElement.setAttribute('aria-hidden', 'true');
                    _this._parentElement.appendChild(_this._measureElement);
                    return _this;
                }
                Object.defineProperty(CharMeasure.prototype, "width", {
                    get: function get() {
                        return this._width;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CharMeasure.prototype, "height", {
                    get: function get() {
                        return this._height;
                    },
                    enumerable: true,
                    configurable: true
                });
                CharMeasure.prototype.measure = function (options) {
                    this._measureElement.style.fontFamily = options.fontFamily;
                    this._measureElement.style.fontSize = options.fontSize + "px";
                    var geometry = this._measureElement.getBoundingClientRect();
                    if (geometry.width === 0 || geometry.height === 0) {
                        return;
                    }
                    if (this._width !== geometry.width || this._height !== geometry.height) {
                        this._width = geometry.width;
                        this._height = Math.ceil(geometry.height);
                        this.emit('charsizechanged');
                    }
                };
                return CharMeasure;
            }(EventEmitter_1.EventEmitter);
            exports.CharMeasure = CharMeasure;
        }, { "../EventEmitter": 7 }], 32: [function (require, module, exports) {
            "use strict";

            var __extends = this && this.__extends || function () {
                var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
                    d.__proto__ = b;
                } || function (d, b) {
                    for (var p in b) {
                        if (b.hasOwnProperty(p)) d[p] = b[p];
                    }
                };
                return function (d, b) {
                    extendStatics(d, b);
                    function __() {
                        this.constructor = d;
                    }
                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
            }();
            Object.defineProperty(exports, "__esModule", { value: true });
            var EventEmitter_1 = require("../EventEmitter");
            var CircularList = function (_super) {
                __extends(CircularList, _super);
                function CircularList(_maxLength) {
                    var _this = _super.call(this) || this;
                    _this._maxLength = _maxLength;
                    _this._array = new Array(_this._maxLength);
                    _this._startIndex = 0;
                    _this._length = 0;
                    return _this;
                }
                Object.defineProperty(CircularList.prototype, "maxLength", {
                    get: function get() {
                        return this._maxLength;
                    },
                    set: function set(newMaxLength) {
                        if (this._maxLength === newMaxLength) {
                            return;
                        }
                        var newArray = new Array(newMaxLength);
                        for (var i = 0; i < Math.min(newMaxLength, this.length); i++) {
                            newArray[i] = this._array[this._getCyclicIndex(i)];
                        }
                        this._array = newArray;
                        this._maxLength = newMaxLength;
                        this._startIndex = 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CircularList.prototype, "length", {
                    get: function get() {
                        return this._length;
                    },
                    set: function set(newLength) {
                        if (newLength > this._length) {
                            for (var i = this._length; i < newLength; i++) {
                                this._array[i] = undefined;
                            }
                        }
                        this._length = newLength;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(CircularList.prototype, "forEach", {
                    get: function get() {
                        var _this = this;
                        return function (callbackfn) {
                            var i = 0;
                            var length = _this.length;
                            for (var i_1 = 0; i_1 < length; i_1++) {
                                callbackfn(_this.get(i_1), i_1);
                            }
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                CircularList.prototype.get = function (index) {
                    return this._array[this._getCyclicIndex(index)];
                };
                CircularList.prototype.set = function (index, value) {
                    this._array[this._getCyclicIndex(index)] = value;
                };
                CircularList.prototype.push = function (value) {
                    this._array[this._getCyclicIndex(this._length)] = value;
                    if (this._length === this._maxLength) {
                        this._startIndex++;
                        if (this._startIndex === this._maxLength) {
                            this._startIndex = 0;
                        }
                        this.emit('trim', 1);
                    } else {
                        this._length++;
                    }
                };
                CircularList.prototype.pop = function () {
                    return this._array[this._getCyclicIndex(this._length-- - 1)];
                };
                CircularList.prototype.splice = function (start, deleteCount) {
                    var items = [];
                    for (var _i = 2; _i < arguments.length; _i++) {
                        items[_i - 2] = arguments[_i];
                    }
                    if (deleteCount) {
                        for (var i = start; i < this._length - deleteCount; i++) {
                            this._array[this._getCyclicIndex(i)] = this._array[this._getCyclicIndex(i + deleteCount)];
                        }
                        this._length -= deleteCount;
                    }
                    if (items && items.length) {
                        for (var i = this._length - 1; i >= start; i--) {
                            this._array[this._getCyclicIndex(i + items.length)] = this._array[this._getCyclicIndex(i)];
                        }
                        for (var i = 0; i < items.length; i++) {
                            this._array[this._getCyclicIndex(start + i)] = items[i];
                        }
                        if (this._length + items.length > this.maxLength) {
                            var countToTrim = this._length + items.length - this.maxLength;
                            this._startIndex += countToTrim;
                            this._length = this.maxLength;
                            this.emit('trim', countToTrim);
                        } else {
                            this._length += items.length;
                        }
                    }
                };
                CircularList.prototype.trimStart = function (count) {
                    if (count > this._length) {
                        count = this._length;
                    }
                    this._startIndex += count;
                    this._length -= count;
                    this.emit('trim', count);
                };
                CircularList.prototype.shiftElements = function (start, count, offset) {
                    if (count <= 0) {
                        return;
                    }
                    if (start < 0 || start >= this._length) {
                        throw new Error('start argument out of range');
                    }
                    if (start + offset < 0) {
                        throw new Error('Cannot shift elements in list beyond index 0');
                    }
                    if (offset > 0) {
                        for (var i = count - 1; i >= 0; i--) {
                            this.set(start + i + offset, this.get(start + i));
                        }
                        var expandListBy = start + count + offset - this._length;
                        if (expandListBy > 0) {
                            this._length += expandListBy;
                            while (this._length > this.maxLength) {
                                this._length--;
                                this._startIndex++;
                                this.emit('trim', 1);
                            }
                        }
                    } else {
                        for (var i = 0; i < count; i++) {
                            this.set(start + i + offset, this.get(start + i));
                        }
                    }
                };
                CircularList.prototype._getCyclicIndex = function (index) {
                    return (this._startIndex + index) % this.maxLength;
                };
                return CircularList;
            }(EventEmitter_1.EventEmitter);
            exports.CircularList = CircularList;
        }, { "../EventEmitter": 7 }], 33: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var MouseHelper = function () {
                function MouseHelper(_renderer) {
                    this._renderer = _renderer;
                }
                MouseHelper.getCoordsRelativeToElement = function (event, element) {
                    if (event.pageX == null) {
                        return null;
                    }
                    var originalElement = element;
                    var x = event.pageX;
                    var y = event.pageY;
                    while (element) {
                        x -= element.offsetLeft;
                        y -= element.offsetTop;
                        element = element.offsetParent;
                    }
                    element = originalElement;
                    while (element && element !== element.ownerDocument.body) {
                        x += element.scrollLeft;
                        y += element.scrollTop;
                        element = element.parentElement;
                    }
                    return [x, y];
                };
                MouseHelper.prototype.getCoords = function (event, element, charMeasure, lineHeight, colCount, rowCount, isSelection) {
                    if (!charMeasure.width || !charMeasure.height) {
                        return null;
                    }
                    var coords = MouseHelper.getCoordsRelativeToElement(event, element);
                    if (!coords) {
                        return null;
                    }
                    coords[0] = Math.ceil((coords[0] + (isSelection ? this._renderer.dimensions.actualCellWidth / 2 : 0)) / this._renderer.dimensions.actualCellWidth);
                    coords[1] = Math.ceil(coords[1] / this._renderer.dimensions.actualCellHeight);
                    coords[0] = Math.min(Math.max(coords[0], 1), colCount + (isSelection ? 1 : 0));
                    coords[1] = Math.min(Math.max(coords[1], 1), rowCount);
                    return coords;
                };
                MouseHelper.prototype.getRawByteCoords = function (event, element, charMeasure, lineHeight, colCount, rowCount) {
                    var coords = this.getCoords(event, element, charMeasure, lineHeight, colCount, rowCount);
                    var x = coords[0];
                    var y = coords[1];
                    x += 32;
                    y += 32;
                    return { x: x, y: y };
                };
                return MouseHelper;
            }();
            exports.MouseHelper = MouseHelper;
        }, {}], 34: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var ScreenDprMonitor = function () {
                function ScreenDprMonitor() {}
                ScreenDprMonitor.prototype.setListener = function (listener) {
                    var _this = this;
                    if (this._listener) {
                        this.clearListener();
                    }
                    this._listener = listener;
                    this._outerListener = function () {
                        _this._listener(window.devicePixelRatio, _this._currentDevicePixelRatio);
                        _this._updateDpr();
                    };
                    this._updateDpr();
                };
                ScreenDprMonitor.prototype._updateDpr = function () {
                    if (this._resolutionMediaMatchList) {
                        this._resolutionMediaMatchList.removeListener(this._outerListener);
                    }
                    this._currentDevicePixelRatio = window.devicePixelRatio;
                    this._resolutionMediaMatchList = window.matchMedia("screen and (resolution: " + window.devicePixelRatio + "dppx)");
                    this._resolutionMediaMatchList.addListener(this._outerListener);
                };
                ScreenDprMonitor.prototype.clearListener = function () {
                    if (!this._listener) {
                        return;
                    }
                    this._resolutionMediaMatchList.removeListener(this._outerListener);
                    this._listener = null;
                    this._outerListener = null;
                };
                return ScreenDprMonitor;
            }();
            exports.ScreenDprMonitor = ScreenDprMonitor;
        }, {}], 35: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            exports.BELL_SOUND = 'data:audio/wav;base64,UklGRigBAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQBAADpAFgCwAMlBZoG/wdmCcoKRAypDQ8PbRDBEQQTOxRtFYcWlBePGIUZXhoiG88bcBz7HHIdzh0WHlMeZx51HmkeUx4WHs8dah0AHXwc3hs9G4saxRnyGBIYGBcQFv8U4RPAEoYRQBACD70NWwwHC6gJOwjWBloF7gOBAhABkf8b/qv8R/ve+Xf4Ife79W/0JfPZ8Z/wde9N7ijtE+wU6xvqM+lb6H7nw+YX5mrlxuQz5Mzje+Ma49fioeKD4nXiYeJy4pHitOL04j/jn+MN5IPkFOWs5U3mDefM55/ogOl36m7rdOyE7abuyu8D8Unyj/Pg9D/2qfcb+Yn6/vuK/Qj/lAAlAg==';
        }, {}], 36: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            var Terminal_1 = require("./Terminal");
            module.exports = Terminal_1.Terminal;
        }, { "./Terminal": 13 }] }, {}, [36])(36);
});
//# sourceMappingURL=xterm.js.map;


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (f) {
    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define('js/xterm/addons/fit/fit.js',[], f);
    } else {
        var g;if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }g.fit = f();
    }
})(function () {
    var define, module, exports;return function e(t, n, r) {
        function s(o, u) {
            if (!n[o]) {
                if (!t[o]) {
                    var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
                }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                    var n = t[o][1][e];return s(n ? n : e);
                }, l, l.exports, e, t, n, r);
            }return n[o].exports;
        }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
            s(r[o]);
        }return s;
    }({ 1: [function (require, module, exports) {
            "use strict";

            Object.defineProperty(exports, "__esModule", { value: true });
            function proposeGeometry(term) {
                if (!term.element.parentElement) {
                    return null;
                }
                var parentElementStyle = window.getComputedStyle(term.element.parentElement);
                var parentElementHeight = parseInt(parentElementStyle.getPropertyValue('height'));
                var parentElementWidth = Math.max(0, parseInt(parentElementStyle.getPropertyValue('width')));
                var elementStyle = window.getComputedStyle(term.element);
                var elementPadding = {
                    top: parseInt(elementStyle.getPropertyValue('padding-top')),
                    bottom: parseInt(elementStyle.getPropertyValue('padding-bottom')),
                    right: parseInt(elementStyle.getPropertyValue('padding-right')),
                    left: parseInt(elementStyle.getPropertyValue('padding-left'))
                };
                var elementPaddingVer = elementPadding.top + elementPadding.bottom;
                var elementPaddingHor = elementPadding.right + elementPadding.left;
                var availableHeight = parentElementHeight - elementPaddingVer;
                var availableWidth = parentElementWidth - elementPaddingHor - term.viewport.scrollBarWidth;
                var geometry = {
                    cols: Math.floor(availableWidth / term.renderer.dimensions.actualCellWidth),
                    rows: Math.floor(availableHeight / term.renderer.dimensions.actualCellHeight)
                };
                return geometry;
            }
            exports.proposeGeometry = proposeGeometry;
            function fit(term) {
                var geometry = proposeGeometry(term);
                if (geometry) {
                    if (term.rows !== geometry.rows || term.cols !== geometry.cols) {
                        term.renderer.clear();
                        term.resize(geometry.cols, geometry.rows);
                    }
                }
            }
            exports.fit = fit;
            function apply(terminalConstructor) {
                terminalConstructor.prototype.proposeGeometry = function () {
                    return proposeGeometry(this);
                };
                terminalConstructor.prototype.fit = function () {
                    fit(this);
                };
            }
            exports.apply = apply;
        }, {}] }, {}, [1])(1);
});
//# sourceMappingURL=fit.js.map;


//
// Modeled on jupyter's terminado.js, but modified a lot for Graffiti usage.
//
// xterm, xterm's css and its fit addon were downloaded and put in the graffiti code base, from here:
// "xterm.js": "https://unpkg.com/xterm@~3.1.0/dist/xterm.js"
// "xterm.js-fit": "https://unpkg.com/xterm@~3.1.0/dist/addons/fit/fit.js"
// "xterm.js-css": "https://unpkg.com/xterm@~3.1.0/dist/xterm.css"

define('js/xterm/terminals.js',['base/js/utils', '../utils.js', './xterm.js', './addons/fit/fit.js'], function (jupyterUtils, utils, terminalLib, fit) {
  var terminals = {

    focusedTerminal: undefined,
    terminalsList: {},

    _makeTerminal: function _makeTerminal(element, terminalId, wsUrl, sizeObj) {
      var ws = new WebSocket(wsUrl);
      terminalLib.applyAddon(fit);
      var term = new terminalLib({
        scrollback: 10000,
        theme: {
          foreground: 'white',
          background: '#222',
          // foreground: 'black',
          // background: '#eee',
          selection: '#fff',
          cursor: '#f73',
          cursorAccent: '#f22'
        }
      });
      term.id = terminalId;
      // contents: contains all chars in and out of the terminal over the socket.
      var termObject = { socket: ws, term: term, contents: '' };
      ws.onopen = function (event) {
        term.on('data', function (data) {
          ws.send(JSON.stringify(['stdin', data]));
        });

        // term.on('keydown', (data) => {
        //  console.log('keypress data:', data);
        // });

        //term.on('scroll', (data) => {
        //console.log('term scroll:', data);
        //});

        // term.on('selection', (data) => {
        //   console.log('term selection:', term.getSelection());
        // });

        term.on('focus', function () {
          //console.log('Graffiti: terminal ' + term.id + ' focused');
          terminals.focusedTerminal = term.id;
        });

        term.on('blur', function () {
          // console.log('terminal defocused'); 
          terminals.focusedTerminal = undefined;
        });

        term.on('refresh', function (data) {
          var checkYdisp = term.buffer.ydisp;
          if (term.storedYdisp !== undefined) {
            if (term.storedYdisp != checkYdisp) {
              terminals.eventsCallback({
                id: term.id,
                type: 'refresh',
                scrollLine: checkYdisp
              });
              //console.log('Graffiti: terminal refresh delta:', term.storedYdisp, checkYdisp);
            }
          }
          term.storedYdisp = term.buffer.ydisp;
        });

        term.open(element);
        term.fit();
        // send the terminal size to the server.
        ws.send(JSON.stringify(["set_size", term.rows, term.cols, window.innerHeight, window.innerWidth]));

        ws.onmessage = function (event) {
          var json_msg = JSON.parse(event.data);
          switch (json_msg[0]) {
            case "stdout":
              var newChars = json_msg[1];
              term.write(newChars);
              term.storedYdisp = term.buffer.ydisp;
              //console.log('received newCharslength:', newChars.length, newChars);
              termObject.contents += newChars;
              terminals.eventsCallback({
                id: term.id,
                scrollLine: term.storedYdisp,
                position: termObject.contents.length,
                focusedTerminal: terminals.focusedTerminal,
                firstRecord: false
              });
              // console.log('termId:', terminalId,'received string of length:', json_msg[1].length, 'from server, contents now has:', termObject.contents);
              break;
            case "disconnect":
              term.write("\r\n\r\n[CLOSED]\r\n");
              break;
          }
        };
      };

      return termObject;
    },

    getFocusedTerminal: function getFocusedTerminal() {
      return terminals.focusedTerminal;
    },

    // Get enough content to fill a terminal sufficiently during scrubbing or just starting playback.
    // We don't restore the entire contents we may have had for the terminal because it could be huge,
    // but we restore about 4x the terminal contents so you can scroll back a bit and to account for
    // curses program output and multibyte characters, etc.
    getContentToFillTerminal: function getContentToFillTerminal(terminal, contents, contentsPointer) {
      var portionMultiplier = 8;
      var term = terminal.term;
      var portionLength = term.rows * term.cols * portionMultiplier;
      var contentsPortion = contents.substr(Math.max(0, contentsPointer - portionLength), contentsPointer);
      //const contentsPortion = contents.substr(0, contentsPointer);
      //console.log('contentsPointer:', contentsPointer);
      return contentsPortion;
    },

    createTerminalCell: function createTerminalCell(cellId, config) {
      if (terminals.terminalsList.hasOwnProperty(cellId)) {
        return terminals.terminalsList[cellId]; // already have this terminal set up
      }
      var cell = utils.findCellByCellId(cellId);
      if (cell !== undefined) {
        var cellJq = $(cell.element);
        var renderArea = cellJq.find('.rendered_html');

        renderArea.html('<div>' + '  <span id="dummy-screen-rows" style="font-family:courier; font-weight:bold; font-size:15px;">bash-3.2$ </span>' + '</div>');
        var lineHeight = renderArea.find('#dummy-screen-rows').height();
        renderArea.html('Loading...');

        var terminalHeight = lineHeight * config.rows; // pixels
        var terminalContainerId = 'terminal-container-' + cellId;

        renderArea.html('<div class="graffiti-terminal-container" id="' + terminalContainerId + '" class="container" style="width:100%;height:' + terminalHeight + 'px;"></div>' + '<div class="graffiti-terminal-links">' + ' <div class="graffiti-terminal-go-notebook-dir">Jump to Notebook\'s Dir</div>' + ' <div class="graffiti-terminal-reset">Reset</div>' + '</div>').show();
        var wsUrl = location.protocol.replace('http', 'ws') + '//' + location.host + '/terminals/websocket/' + config.terminalId;
        var elem = $('#' + terminalContainerId);
        var sizeObj = { cols: 40, rows: 10 };
        renderArea.find('.graffiti-terminal-reset').click(function (e) {
          var target = $(e.target);
          var cellDOM = target.parents('.cell');
          var cellId = cellDOM.attr('graffiti-cell-id');
          terminals.resetTerminalCell(cellId);
        });

        renderArea.find('.graffiti-terminal-container').bind('mousewheel', function (e) {
          //console.log('xterm mousewheel',e.originalEvent.wheelDeltaY); // looks like values about 10 move one line...
        });

        var newTerminal = terminals._makeTerminal(elem[0], cellId, wsUrl, sizeObj);
        terminals.terminalsList[cellId] = newTerminal;

        elem.bind('click', function () {
          newTerminal.term.focus();
        });

        if (config.startingDirectory !== undefined) {
          // in theory we could check to see if we're already in the directory we are supposed to be in using basename:
          // https://stackoverflow.com/questions/23162299/how-to-get-the-last-part-of-dirname-in-bash
          var cdCommand = "" + 'cd ' + config.startingDirectory + "\n";
          renderArea.find('.graffiti-terminal-go-notebook-dir').click(function (e) {
            newTerminal.term.send(cdCommand);
          });
        } else {
          renderArea.find('.graffiti-terminal-go-notebook-dir').hide(); // if this link is inactive, just hide it.
        }

        return newTerminal;
      } else {
        return undefined;
      }
    },

    createTerminalInCell: function createTerminalInCell(cell, terminalId) {
      var cellId = utils.getMetadataCellId(cell.metadata);
      if (terminalId === undefined) {
        terminalId = cellId;
      }
      if (cellId !== undefined) {
        var fullNotebookPath = Jupyter.notebook.notebook_path;
        var notebookPath = void 0,
            notebookPathParts = void 0;
        if (fullNotebookPath.indexOf('/') === -1) {
          notebookPath = fullNotebookPath;
          if (notebookPath.indexOf('.ipynb') !== -1) {
            notebookPath = undefined; // at the top level, we don't set a CD command
          }
        } else {
          notebookPathParts = fullNotebookPath.split('/');
          notebookPath = notebookPathParts.slice(0, notebookPathParts.length - 1).join('/');
        }
        var graffitiConfig = {
          type: 'terminal',
          startingDirectory: notebookPath,
          terminalId: terminalId, // defaults to the graffiti cell id, but can be changed if author wants to display the same terminal twice in one notebook.
          rows: 6 // default is 6 but can be changed in metadata
        };
        utils.assignCellGraffitiConfig(cell, graffitiConfig);
        cell.set_text('<i>Loading terminal (' + cellId + '), please wait...</i>');
        cell.render();
        return terminals.createTerminalCell(cellId, graffitiConfig);
      }
    },

    refreshTerminalCell: function refreshTerminalCell(cellId) {
      if (terminals.terminalsList[cellId] !== undefined) {
        // Create a new terminal id so we'll connect to a fresh socket.
        var term = terminals.terminalsList[cellId].term;
        term.refresh(0, 100000);
        term.focus();
      }
    },

    resetTerminalCell: function resetTerminalCell(cellId) {
      if (terminals.terminalsList[cellId] !== undefined) {
        var fetchParams = { method: 'delete', credentials: 'include' };
        var cell = utils.findCellByCellId(cellId);
        var graffitiConfig = utils.getCellGraffitiConfig(cell);
        if (graffitiConfig !== undefined) {
          var deleteAPIEndpoint = location.origin + '/api/terminals/' + graffitiConfig.terminalId;
          var settings = {
            // liberally cribbed from jupyter's codebase,
            // https://github.com/jupyter/notebook/blob/b8b66332e2023e83d2ee04f83d8814f567e01a4e/notebook/static/tree/js/terminallist.js#L110
            processData: false,
            type: "DELETE",
            dataType: "json",
            success: function success() {
              console.log('Graffiti: successful terminal delete.');
            },
            error: utils.log_ajax_error
          };
          jupyterUtils.ajax(deleteAPIEndpoint, settings);
        }
        delete terminals.terminalsList[cellId];
        terminals.createTerminalInCell(cell, utils.generateUniqueId());
        utils.saveNotebook();
      }
    },

    // Just remove the cellId from the list we keep of terminals in the nb.
    removeTerminal: function removeTerminal(cellId) {
      delete terminals.terminalsList[cellId];
    },

    createTerminalCellAboveSelectedCell: function createTerminalCellAboveSelectedCell() {
      var newTerminalCell = Jupyter.notebook.insert_cell_above('markdown');
      if (newTerminalCell !== undefined) {
        return terminals.createTerminalInCell(newTerminalCell);
      }
      return undefined;
    },

    processRenderQueue: function processRenderQueue() {
      if (terminals.renderQueue.length > 0) {
        var rq = terminals.renderQueue.shift();
        var cellId = utils.getMetadataCellId(rq.cell.metadata);
        console.log('Processing render queue entry:', rq);
        terminals.createTerminalCell(cellId, rq.cell.metadata.graffitiConfig);
        // make sure you can't double click this cell because that would break the terminal
        $(rq.cell.element[0]).unbind('dblclick').bind('dblclick', function (e) {
          e.stopPropagation();
          return false;
        });
        setTimeout(terminals.processRenderQueue, 250);
      }
    },

    // If there are terminals present in this notebook, render them.
    renderAllTerminals: function renderAllTerminals() {
      var cells = Jupyter.notebook.get_cells();
      var cell = void 0,
          cellId = void 0;
      terminals.renderQueue = [];
      for (var i = 0; i < cells.length; ++i) {
        cell = cells[i];
        if (cell.cell_type === 'markdown') {
          if (cell.metadata.hasOwnProperty('graffitiConfig')) {
            if (cell.metadata.graffitiConfig.type === 'terminal') {
              terminals.renderQueue.push({ cell: cell, config: cell.metadata.graffitiConfig });
            }
          }
        }
      }
      terminals.processRenderQueue();
    },

    backupTerminalOutput: function backupTerminalOutput(cellId) {
      var terminal = terminals.terminalsList[cellId];
      if (terminal !== undefined) {
        terminal.contentsBackup = terminal.contents;
      }
    },

    setTerminalContents: function setTerminalContents(opts) {
      var cellId = opts.id;
      var terminal = terminals.terminalsList[cellId];
      terminal.contents = opts.terminalsContents[cellId];
      //console.log('setTerminalContents', opts);
      if (terminal !== undefined) {
        if (!opts.incremental || opts.firstRecord || terminal.lastPosition === undefined) {
          terminal.term.reset();
          var portion = terminals.getContentToFillTerminal(terminal, terminal.contents, opts.position);
          terminal.term.write(portion);
          terminal.lastPosition = opts.position;
        } else {
          if (terminal.lastPosition !== opts.position) {
            var newPortion = terminal.contents.substr(terminal.lastPosition, opts.position - terminal.lastPosition);
            //console.log('writing newPortion', newPortion);
            terminal.term.write(newPortion);
            terminal.lastPosition = opts.position;
          }
        }
        // Scroll to the correct spot if needed
        terminals.scrollTerminal(opts);
      }
    },

    clearTerminalsContentsPositions: function clearTerminalsContentsPositions() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(terminals.terminalsList)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var cellId = _step.value;

          terminals.terminalsList[cellId].lastPosition = undefined;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    },

    focusTerminal: function focusTerminal(cellId) {
      var termRecord = terminals.terminalsList[cellId];
      if (termRecord !== undefined) {
        var cell = utils.findCellByCellId(cellId);
        cell.focus_cell();
        terminals.focusedTerminal = cellId;
        termRecord.term.focus();
      }
    },

    scrollTerminal: function scrollTerminal(opts) {
      var termRecord = terminals.terminalsList[opts.id];
      if (termRecord !== undefined) {
        var term = termRecord.term;
        // Basically the same functionality as in scrollToLine, see here:
        // https://github.com/xtermjs/xterm.js/blob/c908da351b11d718f8dcda7424baee4bd8211681/src/Terminal.ts#L1302
        var scrollAmount = opts.scrollLine - term.buffer.ydisp;
        if (scrollAmount !== 0) {
          term.scrollLines(scrollAmount);
        }
      }
    },

    restoreTerminalOutput: function restoreTerminalOutput(cellId) {
      var terminal = terminals.terminalsList[cellId];
      if (terminal !== undefined) {
        if (terminal.contentsBackup !== undefined) {
          if (terminal.contents != terminal.contentsBackup) {
            terminal.contents = terminal.contentsBackup;
            terminal.term.reset();
            terminal.term.write(terminal.contents);
          }
        }
      }
    },

    saveOrRestoreTerminalOutputs: function saveOrRestoreTerminalOutputs(action) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = Object.keys(terminals.terminalsList)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var cellId = _step2.value;

          if (action === 'save') {
            terminals.backupTerminalOutput(cellId);
          } else {
            terminals.restoreTerminalOutput(cellId);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    },

    getTerminalsStates: function getTerminalsStates(markAsFirstRecord) {
      var states = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = Object.keys(terminals.terminalsList)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var cellId = _step3.value;

          terminal = terminals.terminalsList[cellId];
          states.push({
            id: cellId,
            scrollLine: terminal.term.buffer.ydisp,
            position: terminal.contents.length,
            isFocused: terminals.focusedTerminal === cellId,
            focusedTerminal: terminals.focusedTerminal,
            firstRecord: markAsFirstRecord
          });
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return states;
    },

    getTerminalsContents: function getTerminalsContents() {
      var contents = {};
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = Object.keys(terminals.terminalsList)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var cellId = _step4.value;

          terminal = terminals.terminalsList[cellId];
          contents[cellId] = terminal.contents;
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return contents;
    },

    isTerminalCell: function isTerminalCell(cellId) {
      return terminals.terminalsList[cellId] !== undefined;
    },

    runTerminalCommand: function runTerminalCommand(terminalId, command, addCR) {
      // Inject the terminal command into the target terminal (if found).
      if (terminals.terminalsList[terminalId] !== undefined) {
        var term = terminals.terminalsList[terminalId];
        term.term.send(command);
        if (addCR) {
          term.term.send("\n");
        }
      }
    },

    init: function init(eventsCallback) {
      terminals.eventsCallback = eventsCallback;
      terminals.renderAllTerminals();
    }

  };

  return terminals;
});


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

define('js/state.js',['./utils.js', './xterm/terminals.js'], function (utils, terminalLib) {
  var _state;

  var state = (_state = {
    init: function init() {
      console.log('Graffiti: state constructor running.');
      state.history = undefined;
      state.manifest = {};
      state.utils = utils;
      state.accessLevel = 'view'; // one of 'create' or 'view'. If 'create' then we can create new graffitis, otherwise we can only view them
      state.authorId = undefined; // set when we activivateGraffiti or load a manifest
      state.authorType = 'creator'; // currently hardwired to be creator (teacher).
      state.audioInitialized = false;
      state.recordingBlocked = false;
      state.activity = 'idle'; // one of "recording", "playing", "idle"
      state.previousActivity = undefined;
      state.pointer = { x: 0, y: 0 };
      state.windowSize = state.getWindowSize();
      state.resetOnNextPlay = false;
      state.recordedAudioString = '';
      state.audioStorageCallback = undefined;
      state.frameArrays = ['view', 'selections', 'contents', 'drawings', 'terminals', 'speaking'];
      state.scrollTop = undefined;
      state.selectedCellId = undefined;
      state.mute = false;
      state.playSpeeds = {
        'regular': 1.0, // playback rate at speed it was originally recorded
        'rapid': 2.0, // playback rate when watching entire recording fast
        'scanInactive': 1.0, // playback rate while watching non-silence (speaking) in the recording
        'scanActive': 3.0 // playback rate while watching silence (no speaking) in the recording
      };
      state.currentPlaySpeed = 'regular';
      state.rapidScanActive = false; // whether rapidscan is activate at this moment (it's activated during silent moments so we play faster)
      state.recordedCursorPosition = { x: -1000, y: -1000 };
      state.viewInfo = undefined;
      state.recordingCellInfo = {};
      state.tipTimeout = undefined;
      state.displayedTipInfo = undefined;
      state.movieRecordingStarted = false;
      state.cellsAffectedByActivity = {};
      state.terminalsAffectedByActivity = undefined;
      state.drawingFadeClockAllowed = true;
      state.drawingFadeStart;
      state.drawingFadeDuration = 1000;
      state.drawingFadePreFadeDelay = 2000;
      state.maxDrawingOpacity = 0.5;
      state.drawingOpacity = state.maxDrawingOpacity;
      state.totalDrawingFadeDuration = state.drawingFadePreFadeDelay + state.drawingFadeDuration;
      state.lastDrawingInfo = { drawinging: false };
      state.lastEditActivityTime = undefined;
      state.controlPanelDragging = false;
      state.controlPanelDragOffset = { x: 0, y: 0 };
      state.playableMovies = {};
      state.selectionSerialized = undefined;
      state.hidePlayerAfterPlayback = false;
      state.dontRestoreCellContentsAfterPlayback = false; // this is something the author can decide with a tooltip command.
      state.cellOutputsSent = {};
      state.stickerImageUrl = undefined;
      state.stickerImageCandidateUrl = undefined;
      state.cellIdsAddedDuringRecording = {};
      state.userId = undefined;
      state.workspace = {};
      state.speakingStatus = false; // true when the graffiti creator is currently speaking (not silent)
      state.skipStatus = 0; // value to show we have activated a skip, and what speed (0 = regular speed/user choice, 1 = fixed compression, 2,3,4 = 2x,3x,4x.
      state.editingSkips = false;
      state.replacingSkips = false;
      state.currentSkipRecord = 0;
      state.cellStates = {
        contents: {},
        changedCells: {},
        selections: {}
      };
      state.animationIntervalIds = {};
      state.playbackCellAdditions = {};
      state.highlightsRefreshCellId = undefined;
      state.graffitiEditCellId = undefined;
      state.narratorInfo = {};
      state.shiftKeyIsDown = false;
      state.executionSourceChoiceId = undefined;
      state.terminalState = undefined;

      // Usage statistic gathering for the current session (since last load of the notebook)
      state.usageStats = {
        notebookLoadedAt: utils.getNow(),
        created: {}, // how many graffiti were created
        played: {}, // how much time and how many plays were done
        terminalCommands: {}, // what terminal commands were executed by graffiti
        totalTipsShown: 0, // how many times we've shown tips
        totalUniqueTipsShown: 0,
        totalUniquePlays: 0,
        totalPlaysAllGraffiti: 0,
        totalPlayTimeAllGraffiti: 0,
        totalTerminalCommandsRun: 0,
        uniqueTips: {}
      };
      state.statsKey = undefined;

      // Set up a default version of the drawing state object. This gets updated during drawing activity.
      state.drawingState = {
        drawingModeActivated: false, // when true a drawing tool is selected
        drawingActivity: 'draw', // One of 'draw', 'fade', 'wipe', 'sticker'. Note that 'drawing activity' includes using the eraser tool and stickering
        cellId: undefined,
        positions: {
          start: { x: 0, y: 0 },
          end: { x: 0, y: 0 }
        },
        promptWidth: 0,
        pen: {
          isDown: false, // becomes true when the pen is down, ie user has clicked and held the mouse button
          mouseDownPosition: { x: 0, y: 0 },
          downInMarkdown: false, // Whether the pen went down in a markdown cell
          downInPromptArea: false, // Whether the pen went down in the prompt area
          inPromptArea: false, // True if the pen is in Jupyter's "prompt" div. This part of drawings/stickers will not be scaled in X, only in Y (if in markdown cell)
          permanence: 'temporary', // default: ink disappears after a second of inactivity
          type: 'line', // one of 'line', 'highlight', 'eraser', 'sticker'
          color: 'black',
          dash: 'solid', // one of 'solid', 'dashed'
          fill: 'none', // one of 'none', '#xyz'
          fillOpacity: 0
        },
        stickersRecords: {}, // This contains records of all stickers drawn to date during a recording, or since the last fadeout in a recording.
        stickerOnGrid: false,
        opacity: state.maxDrawingOpacity
      };

      state.SKIP_STATUS_NONE = 0;
      state.SKIP_STATUS_COMPRESS = 1;
      state.SKIP_STATUS_2X = 2;
      state.SKIP_STATUS_3X = 3;
      state.SKIP_STATUS_4X = 4;
      state.SKIP_STATUS_ABSOLUTE = -1;

      state.skipStatusColorMap = {};
      state.skipStatusColorMap[state.SKIP_STATUS_NONE] = '5e5';
      state.skipStatusColorMap[state.SKIP_STATUS_COMPRESS] = 'ddd';
      state.skipStatusColorMap[state.SKIP_STATUS_2X] = '500';
      state.skipStatusColorMap[state.SKIP_STATUS_3X] = 'a00';
      state.skipStatusColorMap[state.SKIP_STATUS_4X] = 'f00';
      state.skipStatusColorMap[state.SKIP_STATUS_ABSOLUTE] = '000';

      state.skipStatusCaptions = {};
      state.skipStatusCaptions[state.SKIP_STATUS_NONE] = 'Regular speed';
      state.skipStatusCaptions[state.SKIP_STATUS_COMPRESS] = 'Compress to fixed duration';
      state.skipStatusCaptions[state.SKIP_STATUS_2X] = '2x speed';
      state.skipStatusCaptions[state.SKIP_STATUS_3X] = '3x speed';
      state.skipStatusCaptions[state.SKIP_STATUS_4X] = '4x speed';
      state.skipStatusCaptions[state.SKIP_STATUS_ABSOLUTE] = 'Skip entire section';

      utils.refreshCellMaps();
    },

    getSkipStatusColor: function getSkipStatusColor(status) {
      return state.skipStatusColorMap[status];
    },

    getSkipStatusCaption: function getSkipStatusCaption(status) {
      return state.skipStatusCaptions[status];
    },

    getManifest: function getManifest() {
      return state.manifest;
    },

    setManifest: function setManifest(manifest) {
      state.manifest = $.extend({}, manifest);
    },

    removeManifestEntry: function removeManifestEntry(recordingCellId, recordingKey) {
      var recordings = state.getManifestRecordingsForCell(recordingCellId);
      if (recordings != undefined) {
        if (recordings.hasOwnProperty(recordingKey)) {
          delete recordings[recordingKey];
          return true;
        }
      }
      return false;
    },

    getManifestSingleRecording: function getManifestSingleRecording(recordingCellId, recordingKey) {
      var recordings = state.getManifestRecordingsForCell(recordingCellId);
      if (recordings === undefined) {
        return undefined;
      }
      return recordings.hasOwnProperty(recordingKey) ? recordings[recordingKey] : undefined;
    },

    getManifestRecordingsForCell: function getManifestRecordingsForCell(recordingCellId) {
      return state.manifest.hasOwnProperty(recordingCellId) ? state.manifest[recordingCellId] : undefined;
    },

    setSingleManifestRecording: function setSingleManifestRecording(recordingCellId, recordingKey, recordingData) {
      if (!state.manifest.hasOwnProperty(recordingCellId)) {
        state.manifest[recordingCellId] = {};
      }
      state.manifest[recordingCellId][recordingKey] = recordingData;
    },

    // compute aggregate stats for this manifest: total number and time of all graffitis, how many cells have graffitis, etc.
    computeManifestStats: function computeManifestStats() {
      var manifest = state.manifest;
      var cells = Jupyter.notebook.get_cells();
      var totals = {
        totalGraffitis: 0, // how many graffitis in this notebook
        totalCells: cells.length, // how many cells in this notebook
        totalCellsWithGraffitis: 0, // how many cells have graffitis
        maxGraffitiPerCell: 0, // the maximum number of graffitis in any one cell
        maxTakesPerGraffiti: 0, // the maximum number of takes for any one graffiti to date
        totalRecordedTime: 0 // total play time of all graffitis
      };
      var recording = void 0,
          recordingCells = void 0,
          recordingCellId = void 0,
          recordingKeys = void 0;
      var lenCheck = void 0,
          activeTakeId = void 0,
          takes = void 0;
      recordingCells = Object.keys(manifest);
      if (recordingCells.length > 0) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = Object.keys(manifest)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            recordingCellId = _step.value;

            if (recordingCellId !== 'stats') {
              // we don't want to gather stats on the stats themselves!
              recordingKeys = Object.keys(manifest[recordingCellId]);
              totals.totalCellsWithGraffitis++;
              lenCheck = recordingKeys.length;
              if (lenCheck > 0) {
                if (lenCheck > totals.maxGraffitiPerCell) {
                  totals.maxGraffitiPerCell = lenCheck;
                }
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = recordingKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    recordingKey = _step2.value;

                    recording = manifest[recordingCellId][recordingKey];
                    totals.totalGraffitis++;
                    takes = recording.takes;
                    if (takes !== undefined) {
                      activeTakeId = recording.activeTakeId;
                      if (takes[activeTakeId] !== undefined) {
                        totals.totalRecordedTime += takes[activeTakeId].duration;
                      }
                      lenCheck = Object.keys(takes).length;
                      if (lenCheck > totals.maxTakesPerGraffiti) {
                        totals.maxTakesPerGraffiti = lenCheck;
                      }
                    }
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2.return) {
                      _iterator2.return();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
      return totals;
    },

    getAccessLevel: function getAccessLevel() {
      return state.accessLevel;
    },

    setAccessLevel: function setAccessLevel(level) {
      state.accessLevel = level;
    },

    getAuthorId: function getAuthorId() {
      return state.authorId;
    },

    setAuthorId: function setAuthorId(authorId) {
      state.authorId = authorId;
    },

    getAuthorType: function getAuthorType() {
      return state.authorType;
    },

    setAuthorType: function setAuthorType(authorType) {
      state.authorType = authorType;
    },

    getUserId: function getUserId() {
      return state.userId;
    },

    setUserId: function setUserId(userId) {
      state.userId = userId;
    },

    getWorkspace: function getWorkspace() {
      return state.workspace;
    },

    setWorkspace: function setWorkspace(workspace) {
      state.workspace = workspace;
    },

    getSpeakingStatus: function getSpeakingStatus() {
      return state.speakingStatus;
    },

    setSpeakingStatus: function setSpeakingStatus(speakingStatus) {
      state.speakingStatus = speakingStatus;
      state.storeHistoryRecord('speaking'); // record speaking status, if we are currently recording
    },

    getSkipStatus: function getSkipStatus() {
      return state.skipStatus;
    },

    setSkipStatus: function setSkipStatus(skipStatus) {
      if (state.skipStatus === skipStatus) {
        state.skipStatus = state.SKIP_STATUS_NONE;
      } else {
        state.skipStatus = skipStatus;
      }
      state.storeHistoryRecord('skip'); // record skip status, if we are currently in a skip (time compression)
    },

    clearHighlightsRefreshableCell: function clearHighlightsRefreshableCell() {
      state.highlightsRefreshCellId = undefined;
    },

    getEditingSkips: function getEditingSkips() {
      //return true;
      return state.editingSkips;
    },

    setEditingSkips: function setEditingSkips(val) {
      state.editingSkips = val;
    },

    getReplacingSkips: function getReplacingSkips() {
      return state.replacingSkips;
    },

    setReplacingSkips: function setReplacingSkips(val) {
      state.replacingSkips = val;
    },

    getCurrentSkipRecord: function getCurrentSkipRecord() {
      return state.currentSkipRecord;
    },

    // If the current time is in the current (or next) skip record, return the skip record.
    timeInSkipRecordRange: function timeInSkipRecordRange(t) {
      if (state.currentSkipRecord !== undefined) {
        var _record = state.history.skips[state.currentSkipRecord];
        if (_record.startTime <= t && t < _record.endtime) {
          return _record;
        }
      }
      return undefined;
    },

    // Set the current or next skip record by scanning from 0 to the time given, looking
    // for a skip record that either straddles the time given, or is greater than the time
    // given (next skip record).
    setCurrentSkipRecord: function setCurrentSkipRecord(t) {
      if (t === undefined) {
        t = state.getTimePlayedSoFar();
      }
      var record = void 0;
      state.currentSkipRecord = undefined;
      for (var i = 0; i < state.history.skips; ++i) {
        record = state.history.skips[i];
        if (record.startTime <= t && t < record.endTime) {
          state.currentSkipRecord = i;
          break;
        } else if (record.startTime > t) {
          state.currentSkipRecord = i;
          break;
        }
      }
    },

    setExecutionSourceChoiceId: function setExecutionSourceChoiceId(choiceId) {
      state.executionSourceChoiceId = choiceId;
    },

    clearExecutionSourceChoiceId: function clearExecutionSourceChoiceId() {
      state.executionSourceChoiceId = undefined;
    },

    getExecutionSourceChoiceId: function getExecutionSourceChoiceId() {
      return state.executionSourceChoiceId;
    },

    getShiftKeyIsDown: function getShiftKeyIsDown() {
      return state.shiftKeyIsDown;
    },

    setShiftKeyIsDown: function setShiftKeyIsDown(val) {
      state.shiftKeyIsDown = val;
    },

    getGraffitiEditCellId: function getGraffitiEditCellId() {
      return state.graffitiEditCellId;
    },

    setGraffitiEditCellId: function setGraffitiEditCellId(cellId) {
      state.graffitiEditCellId = cellId;
    },

    getNarratorInfo: function getNarratorInfo(which) {
      return state.narratorInfo[which];
    },

    clearNarratorInfo: function clearNarratorInfo() {
      state.narratorInfo = {};
    },

    setNarratorInfo: function setNarratorInfo(which, val) {
      state.narratorInfo[which] = val;
    },

    scanForSpeakingStatus: function scanForSpeakingStatus() {
      targetTime = state.getTimePlayedSoFar();
      var lastSpeakingIndex = state.getIndexUpToTime('speaking', targetTime);
      var currentSpeakingStatus = true; // assume we are speaking initially, in case we don't have any speaking records at all.
      if (lastSpeakingIndex !== undefined) {
        for (var index = 0; index < lastSpeakingIndex; ++index) {
          record = state.getHistoryItem('speaking', index);
          currentSpeakingStatus = record.speaking;
        }
      }
      return currentSpeakingStatus;
    },

    // Set the start and end time of where the first speaking period began and the last speaking period ends and put these into
    // absolute skip records
    addSpeakingLimitsSkipRecords: function addSpeakingLimitsSkipRecords() {
      var record = void 0;
      if (state.history.speaking.length >= 2) {
        var lastRec = state.history.speaking.length - 1;
        state.setSkipStatus(state.SKIP_STATUS_ABSOLUTE);
        record = state.createSkipRecord();
        record.startTime = 0;
        record.endTime = state.history.speaking[0].startTime - 1;
        state.history['skip'].push(record);

        state.setSkipStatus(state.SKIP_STATUS_NONE);
        record = state.createSkipRecord();
        record.startTime = state.history.speaking[0].startTime;
        record.endTime = state.history.speaking[lastRec].startTime - 1;
        state.history['skip'].push(record);

        state.setSkipStatus(state.SKIP_STATUS_ABSOLUTE);
        record = state.createSkipRecord();
        record.startTime = state.history.speaking[lastRec].startTime;
        record.endTime = state.history.duration;
        state.history['skip'].push(record);
      }
    },

    setHighlightsRefreshCellId: function setHighlightsRefreshCellId(cellId) {
      state.highlightsRefreshCellId = cellId;
    },

    getHighlightsRefreshCellId: function getHighlightsRefreshCellId() {
      return state.highlightsRefreshCellId;
    },

    getAudioInitialized: function getAudioInitialized() {
      return state.audioInitialized;
    },

    setAudioInitialized: function setAudioInitialized() {
      state.audioInitialized = true;
    },

    getLastEditActivityTime: function getLastEditActivityTime() {
      return state.lastEditActivityTime;
    },

    setLastEditActivityTime: function setLastEditActivityTime() {
      state.lastEditActivityTime = utils.getNow();
    },

    clearLastEditActivityTime: function clearLastEditActivityTime() {
      state.lastEditActivityTime = undefined;
    },

    getControlPanelDragging: function getControlPanelDragging() {
      return state.controlPanelDragging;
    },

    getControlPanelDragOffset: function getControlPanelDragOffset() {
      return state.controlPanelDragOffset;
    },

    setControlPanelDragOffset: function setControlPanelDragOffset(offset) {
      state.controlPanelDragOffset = offset;
    },

    setControlPanelDragging: function setControlPanelDragging(dragging) {
      state.controlPanelDragging = dragging;
    },

    // Window proportion adjustments for when recording is played on a different sized window than what it was recorded on. Not used any more
    getWindowSize: function getWindowSize() {
      return { width: $(window).width(), height: $(window).height() };
    },

    // deprecated, we are now relying on watching for width changes to #notebook-container to adjust for window size changes
    getStoredWindowSize: function getStoredWindowSize() {
      return state.windowSize;
    },

    // deprecated, we are now relying on watching for width changes to #notebook-container to adjust for window size changes
    windowSizeChanged: function windowSizeChanged() {
      var currentWindowSize = state.getWindowSize();
      var previousWindowSize = state.getStoredWindowSize();
      if (previousWindowSize.width !== currentWindowSize.width || previousWindowSize.height !== currentWindowSize.height) {
        state.windowSize = state.getWindowSize();
        return true;
      }
      return false;
    },

    setTipTimeout: function setTipTimeout(tipFunc, t) {
      state.clearTipTimeout();
      state.tipTimeout = setTimeout(tipFunc, t);
    },

    clearTipTimeout: function clearTipTimeout() {
      if (state.tipTimeout !== undefined) {
        clearTimeout(state.tipTimeout);
        state.tipTimeout = undefined;
      }
    },

    clearDisplayedTipInfo: function clearDisplayedTipInfo() {
      state.displayedTipInfo = undefined;
    },

    setDisplayedTipInfo: function setDisplayedTipInfo(cellId, recordingKey) {
      state.displayedTipInfo = { cellId: cellId, recordingKey: recordingKey };
    },

    getDisplayedTipInfo: function getDisplayedTipInfo() {
      return state.displayedTipInfo;
    },

    getStickerImageUrl: function getStickerImageUrl(stickerImageUrl) {
      return state.stickerImageUrl;
    },

    setStickerImageUrl: function setStickerImageUrl(stickerImageUrl) {
      state.stickerImageUrl = stickerImageUrl;
    },

    getStickerImageCandidateUrl: function getStickerImageCandidateUrl(stickerImageCandidateUrl) {
      return state.stickerImageCandidateUrl;
    },

    // We set this in setPlayableMovie(). 
    // When we start playing a movie, we use this to set the final candidate for the movie, which was set by %%custom_sticker in tooltip.
    setStickerImageCandidateUrl: function setStickerImageCandidateUrl(stickerImageCandidateUrl) {
      state.stickerImageCandidateUrl = stickerImageCandidateUrl;
    },

    saveSelectedCellId: function saveSelectedCellId(cellId) {
      state.selectedCellId = cellId;
    },

    getSelectedCellId: function getSelectedCellId() {
      return state.selectedCellId;
    },

    getMute: function getMute() {
      return state.mute;
    },

    setMute: function setMute(muteState) {
      state.mute = muteState;
    },

    rapidIsOn: function rapidIsOn() {
      return state.currentPlaySpeed === 'rapid';
    },

    scanningIsOn: function scanningIsOn() {
      //console.log('scanning is on, currentPlaySpeed:', state.currentPlaySpeed);
      return state.currentPlaySpeed === 'scanActive' || state.currentPlaySpeed === 'scanInactive';
    },

    getCurrentPlaySpeed: function getCurrentPlaySpeed() {
      return state.currentPlaySpeed;
    },

    resetPlayTimes: function resetPlayTimes(preset) {
      //console.log('resetPlayTimes, preset:', preset);
      state.playTimes = {};
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = Object.keys(state.playSpeeds)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var type = _step3.value;

          state.playTimes[type] = {
            start: undefined,
            total: 0
          };
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      ;
      if (preset !== undefined) {
        state.playTimes['regular'] = {
          start: utils.getNow(),
          total: preset
        };
      };
    },

    setPlayTimeBegin: function setPlayTimeBegin(kind) {
      state.playTimes[kind].start = utils.getNow();
    },

    setPlayTimeEnd: function setPlayTimeEnd(kind) {
      var playSpeed = state.currentPlaySpeed;
      if (kind !== undefined) {
        playSpeed = kind;
      }
      state.playTimes[playSpeed].total += utils.getNow() - state.playTimes[playSpeed].start; // real-time spent watching at this given playSpeed
    },

    // play speed types are 'regular', 'rapid', and 'scan'.
    setCurrentPlaySpeed: function setCurrentPlaySpeed(kind) {
      if (state.activity === 'playing') {
        if (state.currentPlaySpeed !== kind) {
          state.setPlayTimeEnd();
          state.setPlayTimeBegin(kind);
        }
      }
      state.currentPlaySpeed = kind;
      //console.log('currentPlaySpeed:', state.currentPlaySpeed, 'playTimes', state.playTimes);
    },

    getPlayRateScalar: function getPlayRateScalar() {
      return state.playSpeeds[state.currentPlaySpeed];
    },

    setPlayStartTimeToNow: function setPlayStartTimeToNow() {
      state.playTimes[state.currentPlaySpeed].start = utils.getNow();
    },

    shouldUpdateDisplay: function shouldUpdateDisplay(kind, frameIndex) {
      if (frameIndex === undefined) {
        return false;
      }
      if (_.contains(state.history.processed[kind], frameIndex.index)) {
        return false; // during playback, we've already processed this record so don't reprocess it.
      }
      state.history.processed[kind].push(frameIndex.index);
      return true;
    },

    resetProcessedArrays: function resetProcessedArrays() {
      if (state.history !== undefined) {
        state.history.processed = [];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = state.frameArrays[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var arrName = _step4.value;

            state.history.processed[arrName] = [];
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    },

    blockRecording: function blockRecording() {
      state.recordingBlocked = true;
    },

    unblockRecording: function unblockRecording() {
      state.recordingBlocked = false;
    },

    getUsageStats: function getUsageStats() {
      var usageStats = $.extend(true, {}, state.usageStats, state.computeManifestStats());
      usageStats.totalUniqueTipsShown = Object.keys(state.usageStats.uniqueTips).length;
      usageStats.statsGatheredAt = utils.getNow();
      delete usageStats['uniqueTips'];

      return usageStats;
    },

    updateUsageStats: function updateUsageStats(opts) {
      var data = opts.data;
      var type = opts.type;
      var playStats = state.usageStats.played;
      var createStats = state.usageStats.created;
      var cellId = void 0,
          recordingKey = void 0,
          activeTakeId = void 0,
          statsKey = void 0;
      if (type === 'create' || type === 'setup' || type === 'terminalCommand' || type === 'tip') {
        cellId = data.cellId;
        recordingKey = data.recordingKey;
      }
      switch (type) {
        case 'create':
          statsKey = utils.composeGraffitiId(cellId, recordingKey);
          if (!createStats.hasOwnProperty(statsKey)) {
            createStats[statsKey] = {
              createDate: data.createDate,
              numEditsThisSession: 0
            };
          }
          createStats[statsKey].numEditsThisSession++;
          createStats[statsKey].numTakes = data.numTakes;
          break;
        case 'setup':
          activeTakeId = data.activeTakeId;
          statsKey = utils.composeGraffitiId(cellId, recordingKey, activeTakeId);
          if (!playStats.hasOwnProperty(statsKey)) {
            playStats[statsKey] = {
              totalTime: 0,
              totalPlays: 0
            };
          }
          state.currentStatsKey = statsKey;
          break;
        case 'tip':
          state.usageStats.totalTipsShown++;
          var tipKey = utils.composeGraffitiId(cellId, recordingKey);
          if (!state.usageStats.uniqueTips.hasOwnProperty(tipKey)) {
            state.usageStats.uniqueTips[tipKey] = 0;
          }
          state.usageStats.uniqueTips[tipKey]++;
          break;
        case 'terminalCommand':
          var terminalCommandsStats = state.usageStats.terminalCommands;
          statsKey = utils.composeGraffitiId(cellId, recordingKey);
          state.usageStats.totalTerminalCommandsRun++;
          if (!terminalCommandsStats.hasOwnProperty(statsKey)) {
            terminalCommandsStats[statsKey] = {
              createDate: data.createDate,
              commands: [],
              numRunsThisSession: 0
            };
          }
          terminalCommandsStats[statsKey].numRunsThisSession++;
          terminalCommandsStats[statsKey].commands.push(opts.command);
          break;
        case 'play':
          var usageRecord = playStats[state.currentStatsKey];
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = data.actions[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var action = _step5.value;

              switch (action) {
                case 'resetCurrentPlayTime':
                  delete usageRecord['currentPlayTime'];
                  break;
                case 'updateCurrentPlayTime':
                  usageRecord.currentPlayTime = Math.round(state.getTimePlayedSoFar());
                  break;
                case 'updateTotalPlayTime':
                  if (state.currentStatsKey !== undefined) {
                    usageRecord.totalTime += usageRecord.currentPlayTime;
                    state.usageStats.totalPlayTimeAllGraffiti += usageRecord.currentPlayTime;
                    delete usageRecord['currentPlayTime'];
                  }
                  break;
                case 'incrementPlayCount':
                  usageRecord.totalPlays++;
                  state.usageStats.totalPlaysAllGraffiti++;
                  state.usageStats.totalUniquePlays = Object.keys(playStats).length;
                  break;
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }

      }
      //console.log('updateUsageStats:', state.usageStats);
    },

    //
    // Drawing utility fns
    //
    getDrawingPenAttribute: function getDrawingPenAttribute(attr) {
      return state.drawingState.pen[attr];
    },

    getDrawingState: function getDrawingState() {
      return state.drawingState;
    },

    getDrawingStateField: function getDrawingStateField(field) {
      return state.drawingState[field];
    },

    // Store the stickers stages sticker lists for later redrawing during playing/scrubbing
    storeStickersStateForCell: function storeStickersStateForCell(stickers, cellId) {
      var stickersRecords = {};
      if (stickers !== undefined && stickers.length > 0) {
        stickersRecords = [];
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = stickers[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var sticker = _step6.value;

            // Copy important fields from the "live" sticker records into the drawing state; these will be persisted as sticker records
            // inside drawing records for later playback.
            // NB: we don't include label stickers that don't have text labels at all, these are just displayed for guidance while placing the sticker

            stickersRecords.push({
              positions: { start: { x: sticker.positions.start.x, y: sticker.positions.start.y },
                end: { x: sticker.positions.end.x, y: sticker.positions.end.y } },
              innerCellRect: {
                left: sticker.innerCellRect.left,
                top: sticker.innerCellRect.top,
                width: sticker.innerCellRect.width,
                height: sticker.innerCellRect.height
              },
              pen: {
                stickerType: sticker.pen.stickerType,
                color: sticker.pen.color,
                dash: sticker.pen.dash,
                fill: sticker.pen.fill,
                fillOpacity: sticker.pen.fillOpacity,
                permanence: sticker.pen.permanence,
                label: sticker.pen.label,
                downInMarkdown: sticker.pen.downInMarkdown,
                downInPromptArea: sticker.pen.downInPromptArea,
                inPromptArea: sticker.pen.inPromptArea
              },
              stickerOnGrid: sticker.stickerOnGrid,
              promptWidth: sticker.promptWidth
            });
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }
      state.drawingState.stickersRecords = stickersRecords;
      //console.log('stickersRecords:', stickersRecords);
    },

    updateDrawingState: function updateDrawingState(changeSets) {
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = changeSets[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var changeSet = _step7.value;

          var change = changeSet.change;
          var data = changeSet.data;
          var drawingState = state.drawingState;
          drawingState.wipe = false; // default, we don't register a wipe state
          switch (change) {
            case 'drawingModeActivated':
              drawingState.drawingModeActivated = data; // a drawing/sticker tool is activated.
              break;
            case 'drawingActivity':
              drawingState.drawingActivity = data; // the drawing mode (mouse is down) : one of 'draw', 'sticker', 'fade', 'wipe' (mutually exclusive)
              break;
            case 'cellId':
              drawingState.cellId = data;
              break;
            case 'isDown':
              drawingState.pen.isDown = data;
              break;
            case 'mouseDownPosition':
              drawingState.pen.mouseDownPosition = { x: data.x, y: data.y };
              break;
            case 'downInMarkdown':
              drawingState.pen.downInMarkdown = data; // whether the drawing/stickering started in a markdown cell
              break;
            case 'downInPromptArea':
              drawingState.pen.downInPromptArea = data; // whether the drawing/stickering started in the prompt area
              break;
            case 'inPromptArea':
              drawingState.pen.inPromptArea = data; // whether the drawing/stickering in the .prompt div
              break;
            case 'promptWidth':
              drawingState.promptWidth = data;
              break;
            case 'stickerOnGrid':
              drawingState.stickerOnGrid = data;
              break;
            case 'fillOpacity':
              // if sticker fill is actually visible
              drawingState.pen.fillOpacity = data;
              break;
            case 'penType':
              drawingState.pen.type = data; // one of 'line', 'highlight', 'eraser', or 'sticker'
              break;
            case 'stickerType':
              drawingState.pen.stickerType = data; // one of many sticker types. if this is set that penType will not be set, and vice versa
              var fill = 'none'; // fill color. this is confusing and needs to be cleaned up a lot
              switch (data) {
                case 'isocelesTriangle':
                case 'rightTriangle':
                case 'ellipse':
                case 'rectangle':
                case 'leftCurlyBrace':
                case 'rightCurlyBrace':
                case 'symmetricCurlyBraces':
                case 'topBracket':
                case 'bottomBracket':
                case 'leftBracket':
                case 'rightBracket':
                case 'horizontalBrackets':
                case 'verticalBrackets':
                case 'smiley':
                case 'frowney':
                case 'thumbsUp':
                case 'thumbsDown':
                case 'star':
                case 'line':
                case 'lineWithArrow':
                case 'label':
                case 'custom':
                  // all these cases have an implicit fill type of 'none'
                  break;
                case 'checkMark':
                  fill = '00aa00'; // hardwired to green
                  break;
                case 'x':
                  fill = 'aa0000'; // hardwired to reddish
                  break;
                case 'theta': // greek symbols hardwired to black
                case 'sigma':
                  fill = '000000';
                  break;
              }
              drawingState.pen.fill = fill; // fill color, if opacity == 1
              break;
            case 'label':
              // a label is actually a sticker that's just typed text
              drawingState.pen.label = data;
              break;
            case 'permanence':
              drawingState.pen.permanence = data; // one of 'permanent', 'temporary'
              break;
            case 'positions':
              var bbox = { start: { x: data.positions.start.x, y: data.positions.start.y }, end: { x: data.positions.end.x, y: data.positions.end.y } };
              if (drawingState.pen.penType === 'sticker') {
                if (drawingState.pen.stickerType !== 'line') {
                  // Unless we're drawing a line sticker, we want to compute bounding box around the given shape, as it will always be the same orientation, and
                  // always have a minimum size
                  bbox = { start: { x: Math.min(data.positions.start.x, data.positions.end.x),
                      y: Math.min(data.positions.start.y, data.positions.end.y) },
                    end: { x: Math.max(data.positions.start.x, data.positions.end.x),
                      y: Math.max(data.positions.start.y, data.positions.end.y) }
                  };
                }
              }
              drawingState.positions = bbox;
              break;
            case 'color':
              drawingState.pen.color = data;
              break;
            case 'dash':
              drawingState.pen.dash = data; // one of 'solid', 'dashed'
              break;
            case 'opacity':
              drawingState.opacity = data; // set during fades of temporary ink
              break;
            case 'wipe':
              drawingState.wipe = true; // after fades are done, this record wipes the temporary canvases clean
              break;
          }
        }
        // console.log('updateDrawingState, state=', state.drawingState);
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    },

    resetDrawingOpacity: function resetDrawingOpacity() {
      state.drawingState.opacity = state.maxDrawingOpacity;
    },

    getActivePenType: function getActivePenType() {
      return state.drawingState.pen.type;
    },

    getDrawingOpacity: function getDrawingOpacity() {
      return state.drawingOpacity;
    },

    setDrawingOpacity: function setDrawingOpacity(opacity) {
      state.drawingState.drawingOpacity = opacity;
    },

    getMaxDrawingOpacity: function getMaxDrawingOpacity() {
      return state.maxDrawingOpacity;
    }

  }, _defineProperty(_state, 'resetDrawingOpacity', function resetDrawingOpacity() {
    state.drawingState.drawingOpacity = state.maxDrawingOpacity;
  }), _defineProperty(_state, 'getDrawingFadeTimeSoFar', function getDrawingFadeTimeSoFar() {
    return utils.getNow() - state.drawingFadeStart;
  }), _defineProperty(_state, 'calculateDrawingOpacity', function calculateDrawingOpacity() {
    // console.log('drawingFadeCounter', state.drawingFadeCounter);
    var timeSoFar = state.getDrawingFadeTimeSoFar();
    var opacity = state.maxDrawingOpacity;
    if (!state.drawingFadeClockAllowed || timeSoFar < state.drawingFadePreFadeDelay) {
      return { status: 'max', opacity: state.maxDrawingOpacity };
    }
    if (timeSoFar < state.totalDrawingFadeDuration) {
      opacity = (state.totalDrawingFadeDuration - timeSoFar) / state.drawingFadeDuration * state.maxDrawingOpacity;
      //console.log('calculateDrawingOpacity:', opacity);
      return { status: 'fade', opacity: opacity };
    }
    return { status: 'fadeDone', opacity: 0 };
  }), _defineProperty(_state, 'disableDrawingFadeClock', function disableDrawingFadeClock() {
    state.drawingFadeClockAllowed = false; // not allowed while drawing a drawing
  }), _defineProperty(_state, 'startDrawingFadeClock', function startDrawingFadeClock() {
    // console.log('startDrawingFadeClock');
    state.drawingFadeStart = utils.getNow();
    state.drawingFadeClockAllowed = true;
  }), _defineProperty(_state, 'getLastRecordedCursorPosition', function getLastRecordedCursorPosition() {
    return { x: state.recordedCursorPosition.x, y: state.recordedCursorPosition.y };
  }), _defineProperty(_state, 'setLastRecordedCursorPosition', function setLastRecordedCursorPosition(pos) {
    state.recordedCursorPosition = { x: pos.x, y: pos.y };
  }), _defineProperty(_state, 'getPlaybackStartTime', function getPlaybackStartTime() {
    return state.playbackStartTime;
  }), _defineProperty(_state, 'setPlaybackStartTime', function setPlaybackStartTime(startTime) {
    state.playbackStartTime = startTime;
  }), _defineProperty(_state, 'startAnimationInterval', function startAnimationInterval(name, cb, timing) {
    if (state.animationIntervalIds[name] !== undefined) {
      clearInterval(state.animationIntervalIds[name]);
    }
    state.animationIntervalIds[name] = setInterval(cb, timing);
  }), _defineProperty(_state, 'clearAnimationIntervals', function clearAnimationIntervals() {
    var ids = Object.keys(state.animationIntervalIds);
    var _iteratorNormalCompletion8 = true;
    var _didIteratorError8 = false;
    var _iteratorError8 = undefined;

    try {
      for (var _iterator8 = ids[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
        var id = _step8.value;

        if (state.animationIntervalIds[id] !== undefined) {
          clearInterval(state.animationIntervalIds[id]);
          delete state.animationIntervalIds[id];
        }
      }
    } catch (err) {
      _didIteratorError8 = true;
      _iteratorError8 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion8 && _iterator8.return) {
          _iterator8.return();
        }
      } finally {
        if (_didIteratorError8) {
          throw _iteratorError8;
        }
      }
    }
  }), _defineProperty(_state, 'getSetupForReset', function getSetupForReset() {
    return state.resetOnNextPlay;
  }), _defineProperty(_state, 'clearSetupForReset', function clearSetupForReset() {
    state.resetOnNextPlay = false;
  }), _defineProperty(_state, 'setupForReset', function setupForReset() {
    state.resetOnNextPlay = true;
  }), _defineProperty(_state, 'getResetOnNextPlay', function getResetOnNextPlay() {
    return state.resetOnNextPlay;
  }), _defineProperty(_state, 'resetPlayState', function resetPlayState() {
    state.resetOnNextPlay = false;
    state.resetPlayTimes();
    state.resetProcessedArrays();
  }), _defineProperty(_state, 'getActivity', function getActivity() {
    return state.activity;
  }), _defineProperty(_state, 'setActivity', function setActivity(newState) {
    console.log('Graffiti: setting activity to:', newState);
    state.activity = newState;
  }), _defineProperty(_state, 'getPreviousActivity', function getPreviousActivity() {
    return state.previousActivity;
  }), _defineProperty(_state, 'storePreviousActivity', function storePreviousActivity() {
    state.previousActivity = state.activity;
  }), _defineProperty(_state, 'restorePreviousActivity', function restorePreviousActivity() {
    state.activity = state.previousActivity;
  }), _defineProperty(_state, 'getPointerPosition', function getPointerPosition() {
    return state.pointer;
  }), _defineProperty(_state, 'storePointerPosition', function storePointerPosition(x, y) {
    state.pointer = { x: x, y: y };
    //console.log('graffiti.state.pointer:', graffiti.state.pointer);
  }), _defineProperty(_state, 'getViewInfo', function getViewInfo() {
    return state.viewInfo;
  }), _defineProperty(_state, 'storeViewInfo', function storeViewInfo(viewInfo) {
    // console.log('storeViewInfo, hover cellId:', viewInfo.cellId);
    if (viewInfo.cellId !== undefined) {
      // may not be set if cursor is btwn cells
      state.viewInfo = $.extend({}, viewInfo);
    }
  }), _defineProperty(_state, 'setSelectionSerialized', function setSelectionSerialized(selectionSerialized) {
    state.selectionSerialized = selectionSerialized;
  }), _defineProperty(_state, 'clearSelectionSerialized', function clearSelectionSerialized() {
    state.selectionSerialized = undefined;
  }), _defineProperty(_state, 'getSelectionSerialized', function getSelectionSerialized() {
    return state.selectionSerialized;
  }), _defineProperty(_state, 'getRecordingCellInfo', function getRecordingCellInfo() {
    // Copy the latest duration into the recordingCellInfo so we persist it in the manifest, if we have it (for the activeTake only)
    if (state.history !== undefined && state.history.duration !== undefined && state.recordingCellInfo.takes !== undefined && state.recordingCellInfo.activeTakeId !== undefined) {
      state.recordingCellInfo.takes[state.recordingCellInfo.activeTakeId].duration = state.history.duration;
    }
    return state.recordingCellInfo;
  }), _defineProperty(_state, 'storeRecordingCellInfo', function storeRecordingCellInfo(cellInfo) {
    // console.trace('storeRecordingCellInfo:', cellInfo);
    state.recordingCellInfo = cellInfo;
  }), _defineProperty(_state, 'getPlayableMovie', function getPlayableMovie(kind) {
    return state.playableMovies[kind];
  }), _defineProperty(_state, 'setPlayableMovie', function setPlayableMovie(kind, cellId, recordingKey) {
    //console.log('setPlayableMovie, cellId, recordingKey:', cellId,recordingKey);
    var cell = utils.findCellByCellId(cellId);
    if (cell !== undefined) {
      var recording = state.getManifestSingleRecording(cellId, recordingKey);
      var activeTakeId = recording.activeTakeId;
      state.playableMovies[kind] = { recordingCellId: cellId, recordingKey: recordingKey, activeTakeId: activeTakeId, cell: cell, cellType: cell.cell_type };
      state.setStickerImageCandidateUrl(recording.stickerImageUrl);
      return recording;
    }
    return undefined;
  }), _defineProperty(_state, 'clearPlayableMovie', function clearPlayableMovie(kind) {
    //console.log('Graffiti: clearing playable movie');
    state.playableMovies[kind] = undefined;
  }), _defineProperty(_state, 'getMovieRecordingStarted', function getMovieRecordingStarted() {
    return state.movieRecordingStarted;
  }), _defineProperty(_state, 'setMovieRecordingStarted', function setMovieRecordingStarted(status) {
    state.movieRecordingStarted = status;
  }), _defineProperty(_state, 'getHidePlayerAfterPlayback', function getHidePlayerAfterPlayback() {
    return state.hidePlayerAfterPlayback;
  }), _defineProperty(_state, 'setHidePlayerAfterPlayback', function setHidePlayerAfterPlayback(status) {
    state.hidePlayerAfterPlayback = status;
  }), _defineProperty(_state, 'getDontRestoreCellContentsAfterPlayback', function getDontRestoreCellContentsAfterPlayback() {
    return state.dontRestoreCellContentsAfterPlayback;
  }), _defineProperty(_state, 'setDontRestoreCellContentsAfterPlayback', function setDontRestoreCellContentsAfterPlayback(status) {
    //console.trace('setDontRestoreCellContentsAfterPlayback:', status);
    state.dontRestoreCellContentsAfterPlayback = status;
  }), _defineProperty(_state, 'clearCellOutputsSent', function clearCellOutputsSent() {
    state.cellOutputsSent = {};
  }), _defineProperty(_state, 'getCellAdditions', function getCellAdditions() {
    if (state.history !== undefined) {
      var allAdditions = _.union(Object.keys(state.history.cellAdditions), Object.keys(state.playbackCellAdditions));
      return allAdditions;
    }
    return undefined;
  }), _defineProperty(_state, 'storeCellAddition', function storeCellAddition(cellId, position) {
    if (state.activity === 'recording') {
      state.history.cellAdditions[cellId] = position;
      //console.log('cellAdditions:', state.cellAdditions);
    }
  }), _defineProperty(_state, 'storePlaybackCellAddition', function storePlaybackCellAddition(cellId, position) {
    state.playbackCellAdditions[cellId] = position;
  }), _defineProperty(_state, 'clearCellAdditions', function clearCellAdditions() {
    state.history.cellAdditions = {};
    state.playbackCellAdditions = {};
  }), _defineProperty(_state, 'storeTerminalsState', function storeTerminalsState(newState) {
    state.terminalsState = newState; // state of one or more terminals at any given time
  }), _defineProperty(_state, 'dumpHistory', function dumpHistory() {
    console.log('Dumping JSON history');
    console.log("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
    console.log(state.history);
    console.log("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
  }), _defineProperty(_state, 'createViewRecord', function createViewRecord(subType) {
    var drawingState = state.drawingState;
    var pen = drawingState.pen;
    var downInMarkdown = pen.isDown && pen.downInMarkdown;
    var downInPromptArea = pen.isDown && pen.downInPromptArea;
    var drawingActivity = pen.isDown ? drawingState.drawingActivity : undefined;
    var stickerCellId = pen.isDown && drawingState.drawingActivity == 'sticker' ? drawingState.cellId : undefined;
    var stickerInfo = undefined,
        stickerCellWidth = 0,
        stickerCellHeight = 0;
    if (stickerCellId !== undefined) {
      var stickerCell = utils.findCellByCellId(stickerCellId);
      var stickerCellElement = $(stickerCell.element[0]).find('.inner_cell');
      var bbox = stickerCellElement[0].getBoundingClientRect();
      stickerCellWidth = bbox.width;
      stickerCellHeight = bbox.height;
      stickerInfo = { cellId: stickerCellId, width: stickerCellWidth, height: stickerCellHeight };
    }
    var topBarHeight = $('#header').height();
    var inTopBarArea = state.pointer.y < topBarHeight;

    return $.extend({}, state.viewInfo, {
      x: state.pointer.x - parseInt(state.viewInfo.outerCellRect.left),
      y: state.pointer.y - parseInt(state.viewInfo.outerCellRect.top),
      downInMarkdown: downInMarkdown,
      downInPromptArea: downInPromptArea,
      drawingActivity: drawingActivity,
      inTopBarArea: inTopBarArea,
      subType: subType,
      speakingStatus: state.speakingStatus,
      scrollDiff: state.viewInfo.scrollDiff,
      selectedCellId: state.selectedCellId,
      stickerInfo: stickerInfo
    });
  }), _defineProperty(_state, 'createDrawingRecord', function createDrawingRecord(opts) {
    var cell = utils.findCellByCellId(state.drawingState.cellId);
    var cellRects = utils.getCellRects(cell);
    var record = $.extend(true, {}, {
      innerCellRect: {
        left: cellRects.innerCellRect.left,
        top: cellRects.innerCellRect.top,
        width: cellRects.innerCellRect.width,
        height: cellRects.innerCellRect.height
      }
    }, state.drawingState);

    // Remove drawing status fields that are not needed in history records
    delete record['drawingModeActivated'];
    delete record.pen['isDown'];
    delete record.pen['mouseDownPosition'];
    delete record['wipe'];
    delete record['stickerActive'];
    delete record['stickerOnGrid'];
    if (opts.stickering) {
      // Remove unnecessary items which have more precise info in each sticker record for this drawing frame.
      delete record['positions'];
      delete record['pen'];
      delete record['promptWidth'];
      delete record['innerCellRect'];
    }
    //console.log('createDrawingRecord:', record);
    return record;
  }), _defineProperty(_state, 'createStickerRecord', function createStickerRecord() {
    var cell = utils.findCellByCellId(state.drawingState.cellId);
    var cellRects = utils.getCellRects(cell);
    var record = $.extend(true, {}, {
      innerCellRect: {
        left: cellRects.innerCellRect.left,
        top: cellRects.innerCellRect.top,
        width: cellRects.innerCellRect.width,
        height: cellRects.innerCellRect.height
      }
    }, state.drawingState);

    // Remove drawing status fields that are not needed in history records
    delete record.drawingModeActivated;
    delete record.pen.isDown;
    delete record.pen['mouseDownPosition'];
    delete record.wipe;
    // console.log('createStickerRecord:', record);
    return record;
  }), _defineProperty(_state, 'createSelectionsRecord', function createSelectionsRecord() {
    var activeCell = Jupyter.notebook.get_selected_cell();
    var cells = Jupyter.notebook.get_cells();
    var cellsSelections = {};
    var cellId = void 0,
        cm = void 0,
        cell = void 0,
        selections = void 0,
        cellSelections = void 0,
        output = void 0,
        outputs0 = void 0,
        ourJs = void 0;
    for (var i = 0; i < cells.length; ++i) {
      cell = cells[i];
      if (cell.cell_type === 'code') {
        cellId = utils.getMetadataCellId(cell.metadata);
        cm = cell.code_mirror;
        selections = utils.cleanSelectionRecords(cm.listSelections());
        output = null;
        ourJs = false;
        if (cell.output_area.outputs.length > 0) {
          outputs0 = cell.output_area.outputs[0];
          output_type = outputs0.output_type;
          // console.log('checking output area output_type:', output_type);
          if (output_type === 'display_data') {
            if (outputs0.data.hasOwnProperty('application/javascript')) {
              if (outputs0.data['application/javascript'].match(/Graffiti\sjavascript/g) !== null) {
                ourJs = true;
              }
            }
          }
          if (!ourJs) {
            // Note that we filter out our own javascript outputs-- we don't want to rerun these when we restore cell states or 
            // else we could rerun the whole recording.
            // console.log('recording output for outputs0:', outputs0);
            output = {
              header: { msg_type: output_type },
              content: outputs0
            };
          }
        } else {
          // if this code cell has no output at time of recording, record that fact for playback
          output = {
            empty: true
          };
        }
        cellSelections = {
          index: i,
          active: cellId === utils.getMetadataCellId(activeCell.metadata),
          selections: selections,
          output: output
        };
        cellsSelections[cellId] = cellSelections;
      }
    }

    return {
      cellsSelections: cellsSelections,
      // Record text selections in rendered markdown or output areas. These are to be found in state.selectionSerialized (or if none, undefined)
      textSelection: state.selectionSerialized
    };
  }), _defineProperty(_state, 'extractDataFromContentRecord', function extractDataFromContentRecord(record, cellId) {
    if (record.backRef !== undefined) {
      if (record.backRefKind === 'contents') {
        return state.history.contents[record.backRef].cellsContent[cellId].contentsRecord.data;
      } else {
        return state.history.contents[record.backRef].cellsContent[cellId].outputsRecord.data;
      }
    }
    return record.data;
  }), _defineProperty(_state, 'createBackRefRecord', function createBackRefRecord(data, backRefKind, backRefArray, cellId) {
    var backRef = void 0;
    var record = backRefArray[cellId];
    if (record !== undefined) {
      if (backRefKind === 'contents' && data === record.data || backRefKind === 'outputs' && _.isEqual(data, record.data)) {
        backRef = record.index;
        data = undefined;
      }
    }
    // Store as-yet-unseen contents or outputs for later backref. Delete the backRefKind value to avoid confusion, *unless* we are not bothering 
    // with backref storage (because we're using this function from storeCellStates() via createContentsRecord().
    if (data !== undefined) {
      backRefKind = undefined;
      backRefArray[cellId] = {
        index: state.history.contents.length, // note that this is not the length - 1, because we are still contructing
        // this contents record and haven't pushed it onto the history yet.
        data: data
      };
    }
    return {
      data: data,
      backRefKind: backRefKind,
      backRef: backRef
    };
  }), _defineProperty(_state, 'createContentsRecord', function createContentsRecord(doBackRefStore) {
    var cellId = void 0,
        cell = void 0,
        contents = void 0,
        outputs = void 0,
        contentsBackRefRecord = void 0,
        outputsBackRefRecord = void 0;
    var cells = Jupyter.notebook.get_cells();
    var cellsContent = {},
        cellsPresentThisFrame = {};
    for (var i = 0; i < cells.length; ++i) {
      cell = cells[i];
      var graffitiConfig = utils.getCellGraffitiConfig(cell);
      if (graffitiConfig !== undefined) {
        var graffitiType = graffitiConfig.type;
        if (graffitiType !== undefined && graffitiType === 'terminal') {
          continue; // don't save terminal cell state here, it's saved by a separate fn
        }
      }
      cellId = utils.getMetadataCellId(cell.metadata);
      cellsPresentThisFrame[cellId] = utils.findCellIndexByCellId(cellId);
      contents = cell.get_text();
      outputs = undefined;
      // Store the DOM contents of the code cells for rerendering.
      var cellDom = $(cell.element);
      var outputArea = cellDom.find('.output');
      if (outputArea.length > 0) {
        outputs = outputArea.html();
      }

      if (doBackRefStore) {
        contentsBackRefRecord = state.createBackRefRecord(contents, 'contents', state.history.cellContentsTracking, cellId);
        outputsBackRefRecord = state.createBackRefRecord(outputs, 'outputs', state.history.cellOutputsTracking, cellId);
      } else {
        contentsBackRefRecord = { data: contents, backRefKind: 'contents', backRef: undefined };
        outputsBackRefRecord = { data: outputs, backRefKind: 'outputs', backRef: undefined };
      }

      // console.log('createContentsRecord, outputs:', outputs);
      var cellContent = {
        index: i,
        contentsRecord: contentsBackRefRecord,
        outputsRecord: outputsBackRefRecord
      };
      cellsContent[cellId] = cellContent;
    }

    return { cellsContent: cellsContent, cellsPresentThisFrame: cellsPresentThisFrame };
  }), _defineProperty(_state, 'createTerminalsRecord', function createTerminalsRecord() {
    // Collect display positions of all terminals. If no terminals history has been recorded yet then mark these records as the "first records",
    // which will trigger term.reset() calls during playback.
    var markAsFirstRecord = state.history.terminals.length === 0;
    var terminalsState = terminalLib.getTerminalsStates(markAsFirstRecord);
    return { terminals: terminalsState };
  }), _defineProperty(_state, 'getHistoryTerminalsContents', function getHistoryTerminalsContents() {
    return state.history.terminalsContents;
  }), _defineProperty(_state, 'storeTerminalsContentsInHistory', function storeTerminalsContentsInHistory() {
    state.history.terminalsContents = terminalLib.getTerminalsContents();
  }), _defineProperty(_state, 'createSpeakingRecord', function createSpeakingRecord() {
    return { speaking: state.speakingStatus };
  }), _defineProperty(_state, 'createSkipRecord', function createSkipRecord() {
    return { status: state.skipStatus };
  }), _defineProperty(_state, 'storeHistoryRecord', function storeHistoryRecord(type, time) {
    if (state.activity !== 'recording' || state.recordingBlocked) return;

    var record = void 0;
    // Note: we override the type to throw together pointer moves, scroll innerScroll, and focus in one history record type
    switch (type) {
      case 'pointer':
        record = state.createViewRecord('pointer');
        type = 'view'; // override passed-in type: pointer is a view type
        break;
      case 'scroll':
        record = state.createViewRecord('scroll');
        type = 'view'; // override passed-in type: scroll is a view type
        break;
      case 'innerScroll':
        record = state.createViewRecord('innerScroll');
        type = 'view'; // override passed-in type: innerScroll is a view type
        break;
      case 'focus':
        record = state.createViewRecord('focus');
        type = 'view'; // override passed-in type: focus is a view type
        break;
      case 'selectCell':
        record = state.createViewRecord('selectCell');
        type = 'view'; // override passed-in type: focus is a view type
        break;
      case 'drawings':
        record = state.createDrawingRecord({ stickering: false });
        break;
      case 'stickers':
        record = state.createDrawingRecord({ stickering: true });
        type = 'drawings'; // we store sticker records as arrays within drawing records.
        break;
      case 'selections':
        record = state.createSelectionsRecord();
        break;
      case 'contents':
        record = state.createContentsRecord(true);
        break;
      case 'terminals':
        record = state.createTerminalsRecord();
        break;
      case 'speaking':
        record = state.createSpeakingRecord();
        break;
    }
    record.startTime = time !== undefined ? time : state.utils.getNow();
    state.history[type].push(record);
  }), _defineProperty(_state, 'getSkipsRecords', function getSkipsRecords() {
    return state.history['skip'];
  }), _defineProperty(_state, 'clearSkipsRecords', function clearSkipsRecords() {
    state.history['skip'] = [];
  }), _defineProperty(_state, 'storeSkipRecord', function storeSkipRecord(newSkipStatus) {
    var timeSoFar = state.getTimePlayedSoFar();
    var numRecords = state.history['skip'].length;
    if (numRecords > 0) {
      // Close off last record created with an end time, if it exists.
      var lastRecord = state.history['skip'][numRecords - 1];
      if (!lastRecord.hasOwnProperty('endTime')) {
        lastRecord.endTime = parseInt(Math.max(0, timeSoFar - 1));
        if (lastRecord.endTime < lastRecord.startTime) {
          // Swap reversed times to allow user to specify skips back-to-front.
          var tmp = lastRecord.startTime;
          lastRecord.startTime = lastRecord.endTime;
          lastRecord.endTime = tmp;
        }
        if (lastRecord.endTime - lastRecord.startTime < 10) {
          // Delete this record as it has insignificant time in it, ie user just flipped the button on and off.
          state.history['skip'].pop();
        } else {
          // Clean up any overlaps in the previous records
          if (numRecords > 1) {
            var i = 0,
                rec = void 0,
                newRecords = [],
                newRecordsSorted = void 0,
                recCopy = void 0;
            while (i < numRecords - 1) {
              rec = state.history['skip'][i];
              recCopy = undefined;
              if (rec.startTime < lastRecord.startTime && rec.endTime > lastRecord.endTime) {
                // if new record is totally inside an existing record, split old record in two.
                var rightRec = { status: rec.status,
                  startTime: lastRecord.endTime,
                  endTime: rec.endTime };
                newRecords.push(rightRec);
                recCopy = { status: rec.status,
                  startTime: rec.startTime,
                  endTime: lastRecord.startTime };
              } else if (rec.endTime < lastRecord.startTime || rec.startTime > lastRecord.endTime) {
                recCopy = $.extend({}, true, rec); // rec is before or after current record
              } else if (rec.startTime < lastRecord.startTime && rec.endTime <= lastRecord.endTime) {
                // this record overlaps the new record at its head so adjust old rec's tail
                recCopy = { status: rec.status,
                  startTime: rec.startTime,
                  endtime: lastRecord.startTime };
              } else if (rec.startTime >= lastRecord.startTime && rec.endTime > lastRecord.endTime) {
                // this record overlaps the new record at its tail, so adjust old rec's head
                recCopy = { status: rec.status,
                  startTime: lastRecord.endTime,
                  endtime: rec.endTime };
              } // else, completely drop the old record (since it must be inside the new record).
              if (recCopy !== undefined) {
                newRecords.push(recCopy);
              }
              i++;
            }
            newRecords.push($.extend({}, true, lastRecord));
            newRecordsSorted = _.sortBy(newRecords, 'startTime');

            console.log('previous history:', state.history['skip'], 'new history:', newRecords, newRecordsSorted);
            state.history['skip'] = newRecordsSorted;
          }
        }
      }
    }
    var previousSkipStatus = state.getSkipStatus();
    state.setSkipStatus(newSkipStatus);
    if (newSkipStatus !== previousSkipStatus) {
      // Only add a new skip record for non-zero and new skip statuses.
      var _record2 = state.createSkipRecord();
      _record2.startTime = timeSoFar;
      state.history['skip'].push(_record2);
    }
    //console.log('storeSkipRecord, skip history:', state.history['skip']);
  }), _defineProperty(_state, 'finalizeSkipRecords', function finalizeSkipRecords() {
    var numRecords = state.history['skip'].length;
    if (numRecords > 0) {
      var lastRecord = state.history['skip'][numRecords - 1];
      if (!lastRecord.hasOwnProperty('endTime')) {
        lastRecord.endTime = state.history.duration - 1;
      }
    }
    state.setSkipStatus(0);
    state.dumpHistory();
  }), _defineProperty(_state, 'initHistory', function initHistory(initialValues) {
    var now = state.utils.getNow();
    state.history = {
      storageCellId: initialValues.storageCellId,
      recordingStartTime: now,

      // Time tracks: all pointer positions, cell selections and contents over the time of the recording.
      view: [], // pointer move, vertical scroll or innerscroll (scroll inside cell)
      selections: [], // cell selections
      contents: [], // contents state: what cells present, and what their contents are, and cell outputs
      drawings: [], // drawing record, of type: ['draw', 'fade', 'wipe', 'sticker']
      terminals: [], // terminal record. Records (recent) changes to contents of a terminal
      speaking: [], // time ranges where creator is speaking or silent
      skip: [], // time ranges when creator has requested either an acceleration or a time compression

      // Where we are in each track, during playback.
      lastVisited: {
        view: 0,
        selections: 0,
        contents: 0,
        drawings: 0,
        terminals: 0,
        speaking: 0,
        skip: 0
      },

      cellContentsTracking: {}, // this enables back-referencing to reduce storage costs on content recording
      cellOutputsTracking: {}, // this enables back-referencing to reduce storage costs on output recording
      cellAdditions: {} // id's and positions of any cells added during the recording.


      // Set up to keep track of the latest record processed during playback (so we don't process a record twice).
    };state.resetProcessedArrays();

    // Store initial state records at the start of recording.
    state.storeHistoryRecord('pointer', now);
    state.storeHistoryRecord('scroll', now);
    state.storeHistoryRecord('focus', now);
    state.storeHistoryRecord('selections', now);
    state.storeHistoryRecord('contents', now);
    state.storeHistoryRecord('terminals', now);
  }), _defineProperty(_state, 'finalizeHistory', function finalizeHistory() {
    state.setHistoryDuration();
    state.normalizeTimeframes();
    state.adjustTimeRecords('speaking'); // move timing of speaking records back by 1/10th of a second since they lag
    state.setupForReset();
  }), _defineProperty(_state, 'deleteTrackingArrays', function deleteTrackingArrays() {
    // console.log('finalizeHistory: deleting Tracking arrays');
    delete state.history.cellContentsTracking;
    delete state.history.cellOutputsTracking;
  }), _defineProperty(_state, 'getJSONHistory', function getJSONHistory() {
    var jsonHistory = void 0;
    try {
      jsonHistory = JSON.stringify(state.history);
      return jsonHistory;
    } catch (ex) {
      return undefined;
    }
  }), _defineProperty(_state, 'getHistoryDuration', function getHistoryDuration() {
    return state.history.duration;
  }), _defineProperty(_state, 'setHistoryDuration', function setHistoryDuration() {
    state.history.duration = state.utils.getNow() - state.history.recordingStartTime;
  }), _defineProperty(_state, 'adjustTimeRecords', function adjustTimeRecords(type) {
    var historyArray = state.history[type];
    var adjustment = 100; // ms
    if (historyArray.length > 0) {
      for (var i = 0; i < historyArray.length; ++i) {
        historyArray[i].startTime = Math.max(0, historyArray[i].startTime - adjustment);
        historyArray[i].endTime = Math.max(0, historyArray[i].endTime - adjustment);
      }
    }
  }), _defineProperty(_state, 'findSpeakingStartNearestTime', function findSpeakingStartNearestTime(t, direction, rewindAmt) {
    var historyItem = void 0,
        numHistoryItems = 0;
    // Scan for nearest "start speaking" record ...
    var chosenTime = direction === -1 ? 0 : state.history.duration;
    if (state.history['speaking'] !== undefined) {
      numHistoryItems = state.history['speaking'].length;
    }
    if (numHistoryItems === 0) {
      // no speaking history, just jump by 2s
      if (direction === -1) {
        chosenTime = Math.max(0, t - rewindAmt * 1000);
      } else {
        chosenTime = Math.min(t + rewindAmt * 1000, state.history.duration - 1);
      }
    } else {
      for (var check = 0; check < numHistoryItems; ++check) {
        //console.log('findSpeakingStartNearestTime, check:', check);
        historyItem = state.history['speaking'][check];
        if (historyItem.speaking) {
          if (direction === -1) {
            if (historyItem.startTime > chosenTime && historyItem.endTime < t) {
              chosenTime = historyItem.startTime;
            }
          } else {
            if (historyItem.startTime < chosenTime && historyItem.startTime > t) {
              chosenTime = historyItem.startTime;
            }
          }
        }
      }
    }
    return chosenTime;
  }), _defineProperty(_state, 'normalizeTimeframes', function normalizeTimeframes() {
    var recordingStartTime = state.history.recordingStartTime;
    var now = state.utils.getNow();
    var _iteratorNormalCompletion9 = true;
    var _didIteratorError9 = false;
    var _iteratorError9 = undefined;

    try {
      for (var _iterator9 = state.frameArrays[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
        var arrName = _step9.value;

        var historyArray = state.history[arrName];
        var max = historyArray.length - 1;
        for (var i = 0; i < historyArray.length; ++i) {
          if (historyArray.length === 1 || i === max) {
            historyArray[i].endTime = now;
          } else {
            historyArray[i].endTime = historyArray[i + 1].startTime;
          }
          historyArray[i].startTime = historyArray[i].startTime - recordingStartTime;
          historyArray[i].endTime = historyArray[i].endTime - recordingStartTime;
        }
        // console.log('normalized ', historyArray.length, 'records for array', arrName);
      }
    } catch (err) {
      _didIteratorError9 = true;
      _iteratorError9 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion9 && _iterator9.return) {
          _iterator9.return();
        }
      } finally {
        if (_didIteratorError9) {
          throw _iteratorError9;
        }
      }
    }
  }), _defineProperty(_state, 'getHistoryRecordsAtTime', function getHistoryRecordsAtTime(t) {
    var indexes = {},
        frame = void 0,
        historyArray = void 0,
        arrName = void 0,
        scanPtr = void 0,
        scanDir = void 0,
        currentFrameIndex = void 0,
        previousFrameIndex = void 0,
        numRecords = void 0,
        skipped = {};
    var historyDuration = state.getHistoryDuration();
    var halfHistory = historyDuration / 2;
    var _iteratorNormalCompletion10 = true;
    var _didIteratorError10 = false;
    var _iteratorError10 = undefined;

    try {
      for (var _iterator10 = state.frameArrays[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
        arrName = _step10.value;

        skipped[arrName] = -1;
        historyArray = state.history[arrName];
        if (historyArray !== undefined) {
          numRecords = historyArray.length;
          currentFrameIndex = state.history.lastVisited[arrName];
          indexes[arrName] = undefined;
          if (historyArray.length > 0) {
            // Only do a scan if the time is within the band of recorded history. E.g. there may only be drawing
            // history in the middle of all recorded time so don't look for records if you're outside that band.
            if (t >= historyArray[0].startTime || t <= historyArray[historyArray.length - 1].endTime) {
              previousFrameIndex = currentFrameIndex;
              frame = historyArray[currentFrameIndex];
              if (t >= frame.startTime && t < frame.endTime) {
                // We're already in the right frame so just return that
                indexes[arrName] = { index: currentFrameIndex, rangeStart: undefined };
              } else {
                // if the distance between the start time of the current frame and t is
                // < 10% of the total duration, start scanning up or
                // down from the current frame until you find the right frame.
                var tDist = t - frame.startTime;
                var tDistAbs = Math.abs(tDist);
                if (tDistAbs / historyDuration < 0.1) {
                  scanDir = Math.sign(tDist);
                  scanPtr = currentFrameIndex + scanDir;
                } else {
                  // Scan to find the frame:
                  //  from the beginning of the recording if the time is in the first half of the recording,
                  //  otherwise scan backwards from the end
                  if (t < halfHistory) {
                    scanPtr = 0;
                    scanDir = 1;
                  } else {
                    scanPtr = numRecords - 1;
                    scanDir = -1;
                  }
                }
                // Now scan to find the right frame by looking for t within the time frame.
                while (scanPtr >= 0 && scanPtr < numRecords) {
                  frame = historyArray[scanPtr];
                  if (t >= frame.startTime && t < frame.endTime) {
                    indexes[arrName] = { index: scanPtr, rangeStart: undefined };
                    state.history.lastVisited[arrName] = scanPtr;
                    break;
                  }
                  scanPtr += scanDir;
                  skipped[arrName]++;
                }
                if (indexes[arrName] !== undefined && indexes[arrName].index !== previousFrameIndex && indexes[arrName].index > previousFrameIndex) {
                  // If we skipped forward a bunch of records to catch up with real time, remember how far we skipped. 
                  // This is needed to make sure we (re)draw everything we recorded during the time that was skipped over.
                  // Time skipping happens because browser animationFrame timing isn't that reliable, so to avoid desynching
                  // with the audio track, we sometimes need to skip records.
                  indexes[arrName].rangeStart = previousFrameIndex + 1;
                }
              }
            }
          }
        }
      }
      //console.log('getHistoryRecordsAtTime:, t=', t, 'records skipped:', skipped, 'indexes[drawings]:', indexes['drawings']);
    } catch (err) {
      _didIteratorError10 = true;
      _iteratorError10 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion10 && _iterator10.return) {
          _iterator10.return();
        }
      } finally {
        if (_didIteratorError10) {
          throw _iteratorError10;
        }
      }
    }

    return indexes;
  }), _defineProperty(_state, 'getIndexUpToTime', function getIndexUpToTime(kind, t) {
    var i = void 0;
    var historyArray = state.history[kind];
    if (historyArray !== undefined) {
      var historyArrayLength = historyArray.length;
      if (historyArrayLength > 0) {
        for (i = 0; i < historyArrayLength; ++i) {
          if (historyArray[i].startTime >= t) {
            return i;
          }
        }
        // check to see if time is on or past the last known record.
        i = historyArray.length - 1;
        if (historyArray[i].startTime < t && historyArray[i].endTime >= t || historyArray[i].endTime < t) {
          return i;
        }
      }
    }
    return undefined;
  }), _defineProperty(_state, 'getLastFrameIndex', function getLastFrameIndex(kind) {
    return state.history[kind].length;
  }), _defineProperty(_state, 'getHistoryItem', function getHistoryItem(kind, index) {
    if (index < state.history[kind].length && index >= 0) {
      return state.history[kind][index];
    }
    return undefined;
  }), _defineProperty(_state, 'storeWholeHistory', function storeWholeHistory(history) {
    state.history = $.extend({}, history);
    state.resetPlayState();
    state.resetProcessedArrays();
  }), _defineProperty(_state, 'getTimeRecordedSoFar', function getTimeRecordedSoFar() {
    return state.utils.getNow() - state.history.recordingStartTime;
  }), _defineProperty(_state, 'getTimePlayedSoFar', function getTimePlayedSoFar() {
    var now = utils.getNow();
    var timePlayedSoFar = 0;
    if (state.playTimes[state.currentPlaySpeed].start !== undefined && state.activity === 'playing') {
      var playRateScalar = state.getPlayRateScalar();
      timePlayedSoFar += (now - state.playTimes[state.currentPlaySpeed].start) * playRateScalar;
    }
    var _iteratorNormalCompletion11 = true;
    var _didIteratorError11 = false;
    var _iteratorError11 = undefined;

    try {
      for (var _iterator11 = Object.keys(state.playSpeeds)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
        var type = _step11.value;

        timePlayedSoFar += state.playTimes[type].total * state.playSpeeds[type];
      }
    } catch (err) {
      _didIteratorError11 = true;
      _iteratorError11 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion11 && _iterator11.return) {
          _iterator11.return();
        }
      } finally {
        if (_didIteratorError11) {
          throw _iteratorError11;
        }
      }
    }

    return timePlayedSoFar;
  }), _defineProperty(_state, 'storeCellStates', function storeCellStates() {
    state.cellsAffectedByActivity = {};
    state.terminalsAffectedByActivity = [];
    var cells = Jupyter.notebook.get_cells();
    state.cellStates = {
      contents: state.createContentsRecord(false),
      selections: state.createSelectionsRecord(),
      changedCells: {},
      lineNumberStates: {}
    };
    for (var i = 0, cell; i < cells.length; ++i) {
      cell = cells[i];
      state.cellStates.lineNumberStates[utils.getMetadataCellId(cell.metadata)] = cell.code_mirror.options.lineNumbers;
    }
  }), _defineProperty(_state, 'storeCellIdAffectedByActivity', function storeCellIdAffectedByActivity(cellId) {
    if (state.activity !== 'playing' && state.activity !== 'recording') return;

    //console.log('storeCellIdAffectedByActivity, logging cell: ' + cellId);
    state.cellStates.changedCells[cellId] = true;
  }), _defineProperty(_state, 'restoreCellOutputs', function restoreCellOutputs(cell, frameOutputs) {
    var cellId = utils.getMetadataCellId(cell.metadata);
    if (frameOutputs === undefined) return false; // no output found, so don't update DOM (e.g. markdown cell)
    if (state.cellOutputsSent[cellId] !== undefined) {
      if (state.cellOutputsSent[cellId] === frameOutputs) {
        // no change to cell output, so don't rerender
        return false;
      }
    }
    var cellDom = $(cell.element);
    var outputArea = cellDom.find('.output');
    //console.log('Sending this output to cellid:', cellId, frameOutputs);
    outputArea.html(frameOutputs).show();
    state.cellOutputsSent[cellId] = frameOutputs;
    return true;
  }), _defineProperty(_state, 'restoreCellStates', function restoreCellStates(which) {
    var affectedIds = Object.keys(state.cellStates.changedCells);
    var selections = void 0,
        cellContents = void 0,
        cellOutputs = void 0;
    if (affectedIds.length > 0) {
      var cell = void 0,
          cellState = void 0,
          cellsContent = void 0,
          contentsRecord = void 0;
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = affectedIds[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var cellId = _step12.value;

          // console.log('affectedid:', cellId);
          cell = utils.findCellByCellId(cellId);
          if (cell !== undefined) {
            selections = state.cellStates.selections.cellsSelections[cellId];
            if (which === 'contents') {
              cellsContent = state.cellStates.contents.cellsContent[cellId];
              if (cellsContent !== undefined) {
                contentsRecord = cellsContent.contentsRecord;
                cellContents = state.extractDataFromContentRecord(contentsRecord, cellId);
                if (cellContents !== undefined) {
                  cell.set_text(contentsRecord.data);
                }
                if (typeof cell.clear_output === 'function') {
                  cell.clear_output();
                  cellOutputs = state.extractDataFromContentRecord(cellsContent.outputsRecord, cellId);
                  state.restoreCellOutputs(cell, cellOutputs);
                }
              }
            } else {
              // restoring selections
              if (selections !== undefined) {
                if (cell.cell_type === 'code' && selections.active) {
                  // hack, not coded right
                  cell.code_mirror.focus();
                }
                // console.log('setting selection to :', selections.selections);
                cell.code_mirror.setSelections(selections.selections);
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
    }
  }), _defineProperty(_state, 'restoreLineNumbersStates', function restoreLineNumbersStates() {
    if (state.hasOwnProperty('cellStates')) {
      if (state.cellStates.hasOwnProperty('lineNumberStates')) {
        if (Object.keys(state.cellStates.lineNumberStates).length > 0) {
          var cell = void 0;
          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            for (var _iterator13 = Object.keys(state.cellStates.lineNumberStates)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var cellId = _step13.value;

              cell = utils.findCellByCellId(cellId);
              if (cell !== undefined) {
                if (cell.code_mirror.options.lineNumbers != state.cellStates.lineNumberStates[cellId]) {
                  cell.toggle_line_numbers();
                }
              }
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13.return) {
                _iterator13.return();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }
        }
      }
    }
  }), _defineProperty(_state, 'getScrollTop', function getScrollTop() {
    return state.scrollTop;
  }), _defineProperty(_state, 'setScrollTop', function setScrollTop(scrollTop) {
    state.scrollTop = scrollTop;
  }), _state);

  return state;
});


// From: https://github.com/muaz-khan/WebRTC-Experiment/blob/master/hark/hark.js
// original source code is taken from:
// https://github.com/SimpleWebRTC/hark
// copyright goes to &yet team
// edited by Muaz Khan for RTCMultiConnection.js
define('js/hark.js',[], function () {
  var hark = {

    running: false,

    getMaxVolume: function getMaxVolume(analyser, fftBins) {
      var maxVolume = -Infinity;
      analyser.getFloatFrequencyData(fftBins);

      for (var i = 4, ii = fftBins.length; i < ii; i++) {
        if (fftBins[i] > maxVolume && fftBins[i] < 0) {
          maxVolume = fftBins[i];
        }
      }

      return maxVolume;
    },

    on: function on(event, callback) {
      hark.events[event] = callback;
    },

    emit: function emit(arg1, arg2, arg3, arg4) {
      if (hark.events[arg1]) {
        hark.events[arg1](arg2, arg3, arg4);
      }
    },

    looper: function looper() {
      var interval = hark.speaking ? hark.talkingInterval : hark.silenceInterval;
      setTimeout(function () {

        //check if stop has been called
        if (!hark.running) {
          return;
        }

        var currentVolume = hark.getMaxVolume(hark.analyser, hark.fftBins);
        hark.emit('volume_change', currentVolume, hark.threshold);

        var history = 0;
        if (currentVolume > hark.threshold && !hark.speaking) {
          // trigger quickly, short history
          for (var i = hark.speakingHistory.length - 3; i < hark.speakingHistory.length; i++) {
            history += hark.speakingHistory[i];
          }
          if (history >= 2) {
            hark.speaking = true;
            hark.emit('speaking');
          }
        } else if (currentVolume < hark.threshold && hark.speaking) {
          for (var j = 0; j < hark.speakingHistory.length; j++) {
            history += hark.speakingHistory[j];
          }
          if (history === 0) {
            hark.speaking = false;
            hark.emit('stopped_speaking');
          }
        }
        hark.speakingHistory.shift();
        hark.speakingHistory.push(0 + (currentVolume > hark.threshold));

        hark.looper();
      }, interval);
    },

    setThreshold: function setThreshold(t) {
      hark.threshold = t;
    },

    setIntervals: function setIntervals(silenceInterval, talkingInterval) {
      //console.trace('Called from here:');
      hark.silenceInterval = silenceInterval;
      hark.talkingInterval = talkingInterval;
    },

    // Poll the analyser node to determine if speaking
    // and emit events if changed
    start: function start() {
      hark.running = true;
      hark.looper();
    },

    stop: function stop() {
      hark.running = false;
      hark.emit('volume_change', -100, hark.threshold);
      if (hark.speaking) {
        hark.speaking = false;
        hark.emit('stopped_speaking');
      }
    },

    init: function init(stream, options) {
      var audioContextType = window.webkitAudioContext || window.AudioContext;

      hark.events = {};

      // make it not break in non-supported browsers
      if (!audioContextType) return hark;

      options = options || {};
      // Config
      var smoothing = options.smoothing || 0.1;

      hark.play = options.play;
      hark.historySize = options.historySize || 10;
      hark.silenceInterval = options.silenceInterval || 10;
      hark.talkingInterval = options.talkingInterval || 100;
      hark.threshold = options.threshold || -50;

      // Setup Audio Context
      if (!window.audioContext00) {
        window.audioContext00 = new audioContextType();
      }

      var gainNode = audioContext00.createGain();
      gainNode.connect(audioContext00.destination);
      // don't play for self
      gainNode.gain.value = 0;

      hark.analyser = audioContext00.createAnalyser();
      hark.analyser.fftSize = 512;
      hark.analyser.smoothingTimeConstant = smoothing;
      hark.fftBins = new Float32Array(hark.analyser.fftSize);

      //WebRTC Stream
      var sourceNode = audioContext00.createMediaStreamSource(stream);

      sourceNode.connect(hark.analyser);

      if (hark.play) hark.analyser.connect(audioContext00.destination);

      hark.speaking = false;

      hark.speakingHistory = [];
      for (var i = 0; i < hark.historySize; i++) {
        hark.speakingHistory.push(0);
      }
    }
  };

  return hark;
});


define('js/audio.js',['./state.js', './hark.js'], function (state, hark) {

  var audio = {

    init: function init(cbs) {
      console.log('Graffiti audio constructor.');
      audio.executeCallback = true; // by default always execute the storage callback

      // fork getUserMedia for multiple browser versions, for the future
      // when more browsers support MediaRecorder
      navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
      if (navigator.getUserMedia) {
        //console.log('getUserMedia supported.');
        navigator.getUserMedia({ // constraints - only audio needed for this app
          audio: true
        },
        // Success callback
        function (stream) {
          var mediaRecorder = new MediaRecorder(stream);
          mediaRecorder.ondataavailable = audio.saveRecordedAudio;
          audio.storeMediaRecorder(mediaRecorder);
          cbs.succeed();

          hark.init(stream, { threshold: -65 });
          hark.on('speaking', function () {
            state.setSpeakingStatus(true);
            console.log('speaking started');
          });
          hark.on('stopped_speaking', function () {
            state.setSpeakingStatus(false);
            console.log('speaking ended');
          });
          //hark.on('volume_change', (currentVolume, threshold) => { console.log('volume change,', currentVolume, threshold) });
        },

        // Error callback
        function (err) {
          console.log('Graffiti: The following getUserMedia error occured: ' + err);
          cbs.fail();
        });
      } else {
        console.log('Graffiti: getUserMedia not supported on your browser!');
      }
    },

    storeMediaRecorder: function storeMediaRecorder(mediaRecorder) {
      audio.mediaRecorder = mediaRecorder;
      console.log('Graffiti: Media recorder ready and stored.');
      return true;
    },

    isAvailable: function isAvailable() {
      return audio.mediaRecorder !== undefined;
    },

    storeAudio: function storeAudio(audioObj) {
      audio.audioObj = audioObj;
    },

    updateAudioPlaybackRate: function updateAudioPlaybackRate() {
      var scalar = state.getPlayRateScalar();
      //const scalar = (rawScalar === 1.0 ? rawScalar : rawScalar * 0.85);
      //console.log('updateAudioPlaybackRate, scalar:', scalar);
      audio.audioObj.playbackRate = scalar;
    },

    // Special thanks to: https://developers.google.com/web/updates/2017/06/play-request-was-interrupted 
    // for handling of weird "play was interrupted" chrome exception.
    playAudio: function playAudio(elapsedTime) {
      audio.setAudioPosition(elapsedTime);
      audio.updateAudioPlaybackRate();
      var playPromise = audio.audioObj.play();
      if (playPromise !== undefined) {
        playPromise.then(function (_) {
          audio.playBeganOK = true;
        }).catch(function (error) {
          audio.playBeganOK = false;
          console.log('Graffiti: audio error:', error);
        });
      }
    },

    pauseAudio: function pauseAudio() {
      if (audio.playBeganOK) {
        audio.audioObj.pause();
      } else {
        console.log('Graffiti: cannot pause audio because audio playback did not begin successfully.');
        // Try again in one second if we fail. Sometimes there's a race condition if audio is stopped really quickly after it begins
        setTimeout(function () {
          if (audio.playBeganOK) {
            audio.audioObj.pause();
          }
        }, 1000);
      }
    },

    // Set time of audio clip, cf:
    // http://stackoverflow.com/questions/9563887/setting-html5-audio-position
    setAudioPosition: function setAudioPosition(elapsedTime) {
      audio.audioObj.currentTime = elapsedTime / 1000; // note that we keep elapsed time in ms, but the MSDN API wants currentTime in seconds
    },

    storeRecordedAudio: function storeRecordedAudio(base64String) {
      // console.log('storing audio base64String :', base64String);
      audio.recordedAudioString = base64String;
    },

    getRecordedAudio: function getRecordedAudio() {
      return audio.recordedAudioString || '';
    },

    setRecordedAudio: function setRecordedAudio(b64String) {
      //console.log('Fetching from ', b64String);
      var labeledAudio = 'data:video/webm;base64,' + b64String;
      var audioObj = new Audio(labeledAudio);
      audioObj.load();
      audio.storeAudio(audioObj);
    },

    setAudioStorageCallback: function setAudioStorageCallback(cb) {
      audio.audioStorageCallback = cb;
    },

    startRecording: function startRecording() {
      if (audio.mediaRecorder !== undefined) {
        audio.mediaRecorder.start();
        hark.start(); // start checking for silences
        console.log('Graffiti:', audio.mediaRecorder.state);
        console.log("Graffiti: Audio recording started");
      } else {
        console.log('Graffiti: Audio recording cannot start, access not granted.');
      }
    },

    stopRecording: function stopRecording() {
      if (audio.mediaRecorder !== undefined) {
        audio.mediaRecorder.stop();
        hark.stop(); // stop checking for silences
        console.log("Graffiti: Audio recording stopped");
      } else {
        console.log('Graffiti: Audio recording cannot stop, access not granted.');
      }
    },

    startPlayback: function startPlayback(elapsedTime) {
      audio.playAudio(elapsedTime);
    },

    pausePlayback: function pausePlayback() {
      audio.pauseAudio();
    },

    setExecuteCallback: function setExecuteCallback(value) {
      audio.executeCallback = value;
    },

    saveRecordedAudio: function saveRecordedAudio(e) {
      //console.log("Audio data available");

      // console.log('Graffiti: Audio data:', e.data);
      var reader = new FileReader();
      reader.addEventListener("loadend", function () {
        // reader.result contains the contents of blob as a typed array
        var bufferArray = reader.result;
        // From: https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string
        // For going backwards, use https://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript and note comment about ie10
        var base64String = btoa([].reduce.call(new Uint8Array(bufferArray), function (p, c) {
          return p + String.fromCharCode(c);
        }, ''));
        //console.log(base64String);
        audio.storeRecordedAudio(base64String);
        if (audio.executeCallback) {
          // This callback is actually: storage:storeMovie().
          audio.audioStorageCallback();
        }
      });
      reader.readAsArrayBuffer(e.data);

      var audioUrl = window.URL.createObjectURL(e.data);
      // This works so nice and simple. From: http://stackoverflow.com/questions/33755524/how-to-load-audio-completely-before-playing (first answer)
      var audioObj = new Audio(audioUrl);
      audioObj.load();

      // Set time of clip for scrubbing: 
      // http://stackoverflow.com/questions/9563887/setting-html5-audio-position

      audio.storeAudio(audioObj);
    }

  };

  return audio;
});


define('js/storage.js',['./state.js', './audio.js', './utils.js', './LZString.js'], function (state, audio, utils, LZString) {

  //
  // Storage tree is organized like this:
  //
  // jupytergraffiti_data/
  //   notebooks/
  //     id_1234/
  //       authors/
  //        id_1234 (creator)/
  //          manifest.json
  //          cells/
  //            id_1234/
  //               graffitis/
  //                 id_1234/
  //                   takes/
  //                     id_1234/
  //                       audio.txt
  //                       history.txt  
  // Inside the notebook's graffiti metadata, firstAuthorId records the author id of the creator of the very first graffiti in this notebook.
  // For notebooks created at Udacity, these are usually graffiti created by instructors and we use a Udacity id. Otherwise we use a randomly generated id. 

  var storage = {

    defaultKernel: 'python3',
    executorCell: undefined,
    movieCompleteCallback: undefined,

    createExecutorCell: function createExecutorCell() {
      if (storage.executorCell === undefined) {
        var cells = Jupyter.notebook.get_cells();
        var numCells = cells.length;
        storage.executorCell = Jupyter.notebook.insert_cell_below('code', numCells);
        state.storePreviousActivity();
        state.setActivity('executing');
      }
      return storage.executorCell;
    },

    runShellCommand: function runShellCommand(cmd) {
      var executorCell = storage.createExecutorCell();
      var currentKernelName = Jupyter.notebook.kernel.name;
      var fullCommand = void 0;
      if (currentKernelName === utils.rKernel) {
        // R doesn't support magics so we use internal R system() call.
        // This needs to escape double quotes eventually... 
        fullCommand = "system('" + cmd + "', intern=TRUE)";
      } else {
        fullCommand = '!' + cmd;
      }
      executorCell.set_text(fullCommand);
      executorCell.execute();
    },

    writeTextToFile: function writeTextToFile(opts) {
      var path = opts.path;
      var contents = opts.contents;
      var executorCell = storage.createExecutorCell();
      var currentKernelName = Jupyter.notebook.kernel.name;
      var writeMagic = void 0,
          chunkSize = void 0;
      switch (currentKernelName) {
        case utils.cplusplusKernel11:
        case utils.cplusplusKernel14:
        case utils.cplusplusKernel17:
          writeMagic = '%%file';
          chunkSize = 10000;
          break;
        case utils.pythonKernel:
          writeMagic = '%%writefile';
          chunkSize = 100000;
          break;
        case utils.rKernel:
          break;
      }
      var contentLength = contents.length;
      var chunkPtr = 0,
          chunk = void 0,
          appendFlag = void 0,
          cmd = void 0,
          rLines = [];
      var pathWithCrs = path + '.cr';
      while (chunkPtr < contentLength) {
        chunk = contents.substr(chunkPtr, chunkSize);
        appendFlag = chunkPtr === 0 ? ' ' : ' -a ';
        if (currentKernelName === utils.rKernel) {
          // We don't write in this loop if using the R Kernel, we just collect and write with a single command, below
          rLines.push('"' + chunk + '"');
        } else {
          cmd = writeMagic + appendFlag + pathWithCrs + "\n" + chunk;
          executorCell.set_text(cmd);
          executorCell.execute();
        }
        chunkPtr += chunkSize;
      }

      if (currentKernelName === utils.rKernel) {
        // Now write it all out in one fell swoop, cf: https://stackoverflow.com/questions/2470248/write-lines-of-text-to-a-file-in-r
        cmd = 'writeLines(c(' + rLines.join(',') + '), "' + pathWithCrs + '")';
        executorCell.set_text(cmd);
        executorCell.execute();
      }

      if (opts.stripCRs) {
        cmd = '/usr/bin/tr -d "\\n" < ' + pathWithCrs + ' > ' + path; // remove all the CR's produced by the %%writefile appends and write to the final filename
      } else {
        cmd = 'mv ' + pathWithCrs + ' ' + path; // just rename the .cr file with the final file name
      }
      storage.runShellCommand(cmd);
      cmd = 'rm ' + pathWithCrs;
      storage.runShellCommand(cmd);
    },

    cleanUpExecutorCell: function cleanUpExecutorCell() {
      var executorCell = storage.createExecutorCell();
      if (executorCell !== undefined) {
        var executorCellId = utils.getMetadataCellId(executorCell.metadata);
        var deleteCellIndex = utils.findCellIndexByCellId(executorCellId);
        if (deleteCellIndex !== undefined) {
          Jupyter.notebook.delete_cell(deleteCellIndex);
        }
        storage.executorCell = undefined;
        state.restorePreviousActivity();
      }
    },

    setMovieCompleteCallback: function setMovieCompleteCallback(cb) {
      storage.movieCompleteCallback = cb;
    },

    executeMovieCompleteCallback: function executeMovieCompleteCallback() {
      if (storage.movieCompleteCallback !== undefined) {
        storage.movieCompleteCallback();
        storage.movieCompleteCallback = undefined;
      }
    },

    ensureNotebookGetsGraffitiId: function ensureNotebookGetsGraffitiId() {
      // Make sure a new notebook gets a recording id
      var notebook = Jupyter.notebook;
      if (!notebook.metadata.hasOwnProperty('graffiti')) {
        notebook.metadata['graffiti'] = {
          id: utils.generateUniqueId(),
          language: 'EN' // defaults to EN but can be changed by the author for their preferred locale, by editing the notebook's metadata
        };
      }
      utils.assignCellIds();
      utils.refreshCellMaps();
      console.log('Graffiti: Notebook is now ready to use Graffiti.');
    },

    ensureNotebookGetsFirstAuthorId: function ensureNotebookGetsFirstAuthorId() {
      // Make sure a new notebook gets a first author id, from whatever auth system is in use.
      var notebook = Jupyter.notebook;
      var metadata = notebook.metadata;
      var firstAuthorId = void 0;
      if (!metadata.hasOwnProperty('graffiti')) {
        storage.ensureNotebookGetsGraffitiId();
      }
      if (!metadata.graffiti.hasOwnProperty('firstAuthorId')) {
        firstAuthorId = state.getUserId();
        metadata.graffiti.firstAuthorId = firstAuthorId;
        state.setAuthorId(firstAuthorId);
      } else {
        firstAuthorId = metadata.graffiti.firstAuthorId;
      }

      return firstAuthorId;
    },

    constructBasePath: function constructBasePath() {
      var notebook = Jupyter.notebook;
      if (!notebook.metadata.hasOwnProperty('graffiti')) {
        storage.ensureNotebookGetsGraffitiId();
      }
      // hardwired to only load author recordings for now
      var basePath = 'jupytergraffiti_data/notebooks/' + notebook.metadata.graffiti.id + '/authors/' + state.getAuthorId() + '/';
      return basePath;
    },

    constructManifestPath: function constructManifestPath() {
      var basePath = storage.constructBasePath();
      return { path: basePath, file: 'manifest.json' };
    },

    constructGraffitiMoviePath: function constructGraffitiMoviePath(pathParts) {
      var basePath = storage.constructBasePath();
      var graffitiPath = basePath + 'cells/' + pathParts.recordingCellId + '/' + 'graffitis/' + pathParts.recordingKey + '/';
      return graffitiPath;
    },

    constructGraffitiTakePath: function constructGraffitiTakePath(pathParts) {
      var graffitiPath = storage.constructGraffitiMoviePath(pathParts) + 'takes/' + pathParts.takeId + '/';
      return graffitiPath;
    },

    completeMovieStorage: function completeMovieStorage() {
      var recordingCellInfo = state.getRecordingCellInfo();
      var recording = state.getManifestSingleRecording(recordingCellInfo.recordingCellId, recordingCellInfo.recordingKey);
      var hasMovie = state.getMovieRecordingStarted();
      // recording is a pointer into the live manifest hash, so beware that we are modifying state directly when changing it.
      if (recording !== undefined) {
        recording.inProgress = false;
        recording.hasMovie = hasMovie;
      }
      if (hasMovie) {
        // Store the latest take information in the current take for this recording.
        recording.activeTakeId = recordingCellInfo.recordingRecord.activeTakeId;
        if (!recording.hasOwnProperty('takes')) {
          recording.takes = {};
        }
        recording.takes[recording.activeTakeId] = {
          duration: state.getHistoryDuration(),
          createDate: utils.getNow()
        };
      }
      state.setMovieRecordingStarted(false);
      console.log('Graffiti: completeMovieStorage is saving manifest, current kernel', Jupyter.notebook.kernel.name);
      storage.storeManifest();
      utils.saveNotebook(function () {
        storage.executeMovieCompleteCallback();
      });
    },

    writeOutMovieData: function writeOutMovieData(movieInfo, jsonHistory, encodedAudio) {
      //console.log('writeOutMovieData, movieInfo:', movieInfo, 'history:', jsonHistory);
      var graffitiPath = storage.constructGraffitiTakePath({
        recordingCellId: movieInfo.recordingCellId,
        recordingKey: movieInfo.recordingKey,
        takeId: movieInfo.activeTakeId
      });

      storage.runShellCommand('mkdir -p ' + graffitiPath);
      if (encodedAudio !== undefined) {
        storage.writeTextToFile({ path: graffitiPath + 'audio.txt',
          contents: encodedAudio,
          stripCRs: true });
      }
      if (jsonHistory !== undefined) {
        var base64CompressedHistory = LZString.compressToBase64(jsonHistory);
        storage.writeTextToFile({ path: graffitiPath + 'history.txt',
          contents: base64CompressedHistory,
          stripCRs: true });
      }
      storage.cleanUpExecutorCell(graffitiPath);
      return Promise.resolve();
    },

    storeMovie: function storeMovie() {
      var recordingCellInfo = state.getRecordingCellInfo();

      var notebook = Jupyter.notebook;
      var jsonHistory = state.getJSONHistory();
      if (jsonHistory !== undefined) {
        //console.log(jsonHistory);
        var encodedAudio = audio.getRecordedAudio();
        storage.writeOutMovieData({
          recordingCellId: recordingCellInfo.recordingCellId,
          recordingKey: recordingCellInfo.recordingKey,
          activeTakeId: recordingCellInfo.recordingRecord.activeTakeId
        }, jsonHistory, encodedAudio).then(function () {
          storage.completeMovieStorage();
        });
      } else {
        console.log('Graffiti: could not fetch JSON history.');
      }
    },

    // Load the manifest for this notebook.
    // Manifests contain information about all the recordings present in this notebook.
    // This version of the system only supports author manifests.
    loadManifest: function loadManifest(currentAccessLevel) {
      var notebook = Jupyter.notebook;
      if (!notebook.metadata.hasOwnProperty('graffiti')) {
        if (currentAccessLevel !== 'create') {
          console.log('Graffiti: loadManifest is bailing early because we are not in "create" mode and this notebook has no graffiti id.');
          return Promise.reject();
        } else {
          storage.ensureNotebookGetsGraffitiId();
        }
      }
      var authorId = storage.ensureNotebookGetsFirstAuthorId();
      state.setAuthorId(authorId);

      var credentials = { credentials: 'include' };
      var manifestInfo = storage.constructManifestPath();
      console.log('Graffiti: Loading manifest from:', manifestInfo);
      var manifestFullFilePath = manifestInfo.path + manifestInfo.file;
      return fetch(manifestFullFilePath, credentials).then(function (response) {
        if (!response.ok) {
          // We could not fetch for some reason (maybe manifest file doesn't exist) so initialize an empty manifest
          return undefined;
        }
        return response.text();
      }).then(function (base64Str) {
        if (base64Str === undefined) {
          state.setManifest({});
        } else {
          var uncompressedManifestString = LZString.decompressFromBase64(base64Str);
          //console.log('uncompressed manifest:', uncompressedManifestString);
          var manifestDataParsed = JSON.parse(uncompressedManifestString);
          state.setManifest(manifestDataParsed);
          console.log('Graffiti Manifest:', manifestDataParsed);
        }
      });
    },

    updateSingleManifestRecordingField: function updateSingleManifestRecordingField(recordingCellId, recordingKey, field, data) {
      var recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
      recording[field] = data;
      storage.storeManifest();
    },

    storeManifest: function storeManifest() {
      var manifest = state.getManifest();
      var manifestInfo = storage.constructManifestPath();
      var base64CompressedManifest = LZString.compressToBase64(JSON.stringify(manifest));
      var manifestFullFilePath = manifestInfo.path + manifestInfo.file;
      console.log('Graffiti: Saving manifest to:', manifestFullFilePath);

      storage.runShellCommand('mkdir -p ' + manifestInfo.path);
      storage.writeTextToFile({ path: manifestFullFilePath,
        contents: base64CompressedManifest,
        stripCRs: true });
      storage.cleanUpExecutorCell();
    },

    //
    // Load a movie.
    // Returns a promise.
    //
    loadMovie: function loadMovie(recordingCellId, recordingKey, activeTakeId) {
      var notebookRecordingId = Jupyter.notebook.metadata.graffiti.id;
      var graffitiPath = storage.constructGraffitiTakePath({
        recordingCellId: recordingCellId,
        recordingKey: recordingKey,
        takeId: activeTakeId
      });
      var credentials = { credentials: 'include' };
      storage.successfulLoad = false; /* assume we cannot fetch this recording ok */
      console.log('Graffiti: storage is loading movie from path:', graffitiPath);
      var historyUrl = graffitiPath + 'history.txt';
      return fetch(historyUrl, credentials).then(function (response) {
        if (!response.ok) {
          throw Error(response.statusText);
        }
        return response.text();
      }).then(function (base64CompressedHistory) {
        try {
          //console.log('Loaded history:', base64CompressedHistory);
          var uncompressedHistory = LZString.decompressFromBase64(base64CompressedHistory);
          //console.log('uncompressedHistory:', uncompressedHistory);
          var parsedHistory = JSON.parse(uncompressedHistory);
          state.storeWholeHistory(parsedHistory);
          console.log('Graffiti: Loaded previous history:', parsedHistory);
          var audioUrl = graffitiPath + 'audio.txt';
          return fetch(audioUrl, { credentials: 'include' }).then(function (response) {
            if (!response.ok) {
              throw Error(response.statusText);
            }
            return response.text();
          }).then(function (base64CompressedAudio) {
            try {
              audio.setRecordedAudio(base64CompressedAudio);
              storage.successfulLoad = true;
            } catch (ex) {
              console.log('Graffiti: Could not parse saved audio, ex:', ex);
              return Promise.reject('Could not parse saved audio, ex :' + ex);
            }
          });
        } catch (ex) {
          console.log('Graffiti: Could not parse previous history, ex :', ex);
          return Promise.reject('Could not parse previous history, ex :' + ex);
        }
      }).catch(function (ex) {
        console.log('Graffiti: Could not fetch history file for history, ex:', ex);
        return Promise.reject('Could not fetch history file');
      });
    },

    deleteMovie: function deleteMovie(recordingCellId, recordingKey) {
      var graffitiPath = storage.constructGraffitiMoviePath({
        recordingCellId: recordingCellId,
        recordingKey: recordingKey
      });
      storage.runShellCommand('rm -r ' + graffitiPath);
      storage.cleanUpExecutorCell();
    },

    transferGraffitis: function transferGraffitis() {
      var notebook = Jupyter.notebook;
      var originalGraffitiId = void 0;
      if (notebook.metadata.hasOwnProperty('graffiti')) {
        originalGraffitiId = $.extend(true, {}, notebook.metadata.graffiti);
        delete notebook.metadata['graffiti'];
      }
      storage.ensureNotebookGetsGraffitiId();
      storage.ensureNotebookGetsFirstAuthorId();
      utils.saveNotebook(function () {
        var newGraffitiId = notebook.metadata.graffiti.id;
        var notebookPath = "jupytergraffiti_data/notebooks/";
        var sourceTree = notebookPath + originalGraffitiId;
        var destTree = notebookPath + newGraffitiId;
        storage.runShellCommand('cp -pr ' + sourceTree + ' ' + destTree);
        storage.cleanUpExecutorCell();
      });

      return Promise.resolve(); // not really doing this right but...
    },

    packageGraffitis: function packageGraffitis() {
      //utils.saveNotebook();
      var notebook = Jupyter.notebook;
      var notebookName = notebook.get_notebook_name();
      var archiveName = 'graffiti_archive_' + utils.generateUniqueId().replace('id_', '') + '.tgz';
      var tarCmd = 'tar zcf ' + archiveName + ' "' + notebookName + '.ipynb"' + ' jupytergraffiti_data';
      storage.runShellCommand(tarCmd);
      storage.cleanUpExecutorCell();

      return Promise.resolve(archiveName);
    },

    removeGraffitiIds: function removeGraffitiIds() {
      var cells = Jupyter.notebook.get_cells();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = cells[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var cell = _step.value;

          if (cell.metadata.hasOwnProperty('graffitiCellId')) {
            delete cell.metadata.graffitiCellId;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      delete Jupyter.notebook.metadata.graffiti;
      utils.saveNotebook();
    },

    // Delete all a notebook's stored graffitis and its data directory (but not the global jupytergraffiti_data directory)
    deleteDataDirectory: function deleteDataDirectory(graffitiId) {
      var notebookStoragePath = 'jupytergraffiti_data/notebooks/' + graffitiId;
      storage.runShellCommand('rm -r ' + notebookStoragePath);
      storage.cleanUpExecutorCell();
    },

    removeUnusedTakesCore: function removeUnusedTakesCore(recordingCellId, recordingKey) {
      var recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
      var activeTakeId = recording.activeTakeId;
      var deletedTakes = 0;

      if (recording.takes !== undefined) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = Object.keys(recording.takes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var takeId = _step2.value;

            if (takeId !== activeTakeId) {
              var graffitiTakePath = storage.constructGraffitiTakePath({
                recordingCellId: recordingCellId,
                recordingKey: recordingKey,
                takeId: takeId
              });
              storage.runShellCommand('rm -r ' + graffitiTakePath);
              delete recording.takes[takeId];
              deletedTakes++;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
      return deletedTakes;
    },

    removeUnusedTakes: function removeUnusedTakes(recordingCellId, recordingKey) {
      var deletedTakes = storage.removeUnusedTakesCore(recordingCellId, recordingKey);
      if (deletedTakes > 0) {
        storage.storeManifest();
        storage.cleanUpExecutorCell();
        utils.saveNotebook();
      }
    }

  };

  return storage;
});


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

define('js/sticker.js',['./utils.js'], function (utils) {
  // Thanks to https://stackoverflow.com/questions/3642035/jquerys-append-not-working-with-svg-element
  var sticker = {

    interpretDashing: function interpretDashing(opts, obj) {
      if (opts.dashed !== undefined && opts.dashed === 'dashed') {
        if (opts.dashWidth) {
          obj['stroke-dasharray'] = opts.dashWidth;
        } else {
          obj['stroke-dasharray'] = 4;
        }
      }
    },

    // Cf : https://www.beyondjava.net/how-to-connect-html-elements-with-an-arrow-using-svg
    // and: https://stackoverflow.com/questions/43887340/how-to-include-the-arrow-head-in-the-length-of-a-line-in-svg
    generateArrowHeadElem: function generateArrowHeadElem(arrowHeadColor, arrowHeadSize) {
      var arrowHeadId = 'arrowHead-' + utils.generateUniqueId();
      var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      var marker = sticker.makeSvgElement('marker', {
        id: arrowHeadId,
        viewBox: '0 0 10 10',
        refX: 8.7,
        refY: 3,
        markerUnits: 'strokeWidth',
        markerWidth: arrowHeadSize,
        markerHeight: arrowHeadSize,
        orient: 'auto',
        stroke: arrowHeadColor,
        fill: arrowHeadColor
      });
      var path = sticker.makeSvgElement('path', {
        d: "M 0,0 L0,6 L9,3 z"
      });
      marker.appendChild(path);
      defs.appendChild(marker);
      return {
        arrowHeadId: arrowHeadId,
        defs: defs
      };
    },

    makeElementHtml: function makeElementHtml(tag, attr, innerHtml) {
      var elementHtml = '<' + tag + ' ';
      if (tag === 'svg') {
        elementHtml += 'xmlns="http://www.w3.org/2000/svg" version="1.1" class="graffitiSvg" ';
      }
      var attrHtml = '';
      if (attr !== undefined) {
        attrHtml = $.map(attr, function (val, key) {
          return key + '="' + val + '"';
        }).join(' ');
      }
      if (innerHtml !== undefined) {
        elementHtml += attrHtml + '>' + innerHtml + '</' + tag + '>';
      } else {
        elementHtml += attrHtml + '></' + tag + '>';
      }
      return elementHtml;
    },

    makeSvgElement: function makeSvgElement(tag, attrs) {
      var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
      if (tag === 'svg') {
        el.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
        el.setAttribute('version', '1.1');
        el.setAttribute('preserveAspectRatio', 'none');
      }
      for (var k in attrs) {
        el.setAttribute(k, attrs[k]);
      }
      if (attrs.text !== undefined) {
        // Handle svg text content as a special case b/c it's not an attribute, cf :
        // https://stackoverflow.com/questions/14758125/setting-text-svg-element-dynamically-via-javascript
        el.textContent = attrs.text;
      }
      return el;
    },

    makeDomElement: function makeDomElement(tag, attrs) {
      var el = document.createElement(tag);
      for (var k in attrs) {
        el.setAttribute(k, attrs[k]);
      }
      return el;
    },

    renderSvg: function renderSvg(svgChildren, x, y, width, height, viewBox, arrowHeadRecord) {
      var containerDiv = void 0,
          containerSticker = void 0,
          containerDivParams = void 0,
          metaParts = void 0;
      var svgGenerator = $('#graffitiSvgGenerator');
      if (svgGenerator.length === 0) {
        $('body').append($('<div id="graffitiSvgGenerator"></div>'));
        svgGenerator = $('#graffitiSvgGenerator');
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = svgChildren[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var svgChild = _step.value;

          var transform = '';
          if (svgChild.hasOwnProperty('cssTransform')) {
            transform = 'transform:' + svgChild.cssTransform;
          }
          var backgroundColor = '';
          if (svgChild.hasOwnProperty('backgroundColor')) {
            backgroundColor = 'background:' + svgChild.backgroundColor + ';';
          }
          var border = '';
          if (svgChild.hasOwnProperty('border')) {
            border = 'border:' + svgChild.border + ';';
          }
          containerDivParams = {
            'class': svgChild.outerClass,
            'style': 'position:absolute;' + 'left:' + parseInt(svgChild.x) + 'px;top:' + parseInt(svgChild.y) + 'px;' + 'width:' + parseInt(svgChild.width) + 'px;height:' + parseInt(svgChild.height) + 'px;' + transform + backgroundColor + border
          };
          if (svgChild.hasOwnProperty('title')) {
            containerDivParams.title = svgChild.title;
          };
          if (svgChild.hasOwnProperty('metaTag')) {
            metaParts = svgChild.metaTag.split('|');
            containerDivParams[metaParts[0]] = metaParts[1];
          };
          containerDiv = sticker.makeDomElement('div', containerDivParams);
          containerSticker = sticker.makeSvgElement('svg', {
            width: svgChild.width,
            height: svgChild.height,
            viewBox: svgChild.viewBox
          });
          if (svgChild.usesArrow) {
            containerSticker.appendChild(svgChild.arrowHeadRecord.defs);
          }
          containerSticker.appendChild(svgChild.el);
          containerDiv.appendChild(containerSticker);
          svgGenerator[0].appendChild(containerDiv);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var containerHtml = svgGenerator[0].innerHTML;
      svgGenerator.empty();

      return containerHtml;
    },

    makeLine: function makeLine(opts) {
      var endpoints = opts.endpoints;
      var p1 = endpoints.p1;
      var p2 = endpoints.p2;
      var bbox = {
        p1: {
          x: Math.min(p1.x, p2.x),
          y: Math.min(p1.y, p2.y)
        },
        p2: {
          x: Math.max(p1.x, p2.x),
          y: Math.max(p1.y, p2.y)
        }
      };
      var color = opts.color === undefined ? '#000' : opts.color;
      var strokeWidth = opts.strokeWidth === undefined ? 3 : opts.strokeWidth;
      var coordSpaceEndpoints = void 0;
      if (p2.x < p1.x && p2.y < p1.y) {
        coordSpaceEndpoints = {
          p1: {
            x: bbox.p2.x, y: bbox.p2.y
          },
          p2: {
            x: bbox.p1.x, y: bbox.p1.y
          }
        };
      } else if (p2.x < p1.x) {
        coordSpaceEndpoints = {
          p1: {
            x: bbox.p2.x, y: bbox.p1.y
          },
          p2: {
            x: bbox.p1.x, y: bbox.p2.y
          }
        };
      } else if (p2.y < p1.y) {
        coordSpaceEndpoints = {
          p1: {
            x: bbox.p1.x, y: bbox.p2.y
          },
          p2: {
            x: bbox.p2.x, y: bbox.p1.y
          }
        };
      } else {
        coordSpaceEndpoints = {
          p1: {
            x: bbox.p1.x, y: bbox.p1.y
          },
          p2: {
            x: bbox.p2.x, y: bbox.p2.y
          }
        };
      }

      // Finally, translate coords into viewport space.
      var finalCoordSpaceEndpoints = {
        p1: {
          x: coordSpaceEndpoints.p1.x - bbox.p1.x, y: coordSpaceEndpoints.p1.y - bbox.p1.y
        },
        p2: {
          x: coordSpaceEndpoints.p2.x - bbox.p1.x, y: coordSpaceEndpoints.p2.y - bbox.p1.y
        }
      };
      var pathPart = 'M ' + finalCoordSpaceEndpoints.p1.x + ' ' + finalCoordSpaceEndpoints.p1.y + ' ' + 'L ' + finalCoordSpaceEndpoints.p2.x + ' ' + finalCoordSpaceEndpoints.p2.y;
      var pathObj = {
        'vector-effect': 'non-scaling-stroke',
        'stroke-width': strokeWidth,
        stroke: color,
        fill: color,
        d: pathPart
      };
      var arrowHeadRecord = undefined;
      if (opts.usesArrow !== undefined) {
        arrowHeadRecord = sticker.generateArrowHeadElem(opts.color, opts.arrowHeadSize);
        pathObj['marker-end'] = 'url(#' + arrowHeadRecord.arrowHeadId + ')';
      }
      sticker.interpretDashing(opts, pathObj);

      var line = sticker.makeSvgElement('path', pathObj);

      var viewBoxBuffer = 10;
      var minArrowBox = 10 + viewBoxBuffer;
      var viewBox = [-1 * viewBoxBuffer, -1 * viewBoxBuffer, Math.max(minArrowBox, Math.abs(bbox.p2.x - bbox.p1.x) + viewBoxBuffer * 2), Math.max(minArrowBox, Math.abs(bbox.p2.y - bbox.p1.y) + viewBoxBuffer * 2)];
      var renderedSvg = sticker.renderSvg([{
        el: line,
        x: bbox.p1.x + opts.lineStartOffset.x - viewBoxBuffer,
        y: bbox.p1.y + opts.lineStartOffset.y - viewBoxBuffer,
        width: viewBox[2],
        height: viewBox[3],
        color: color,
        viewBox: viewBox.join(' '),
        usesArrow: opts.usesArrow,
        arrowHeadRecord: arrowHeadRecord,
        arrowHeadSize: opts.arrowHeadSize
      }]);

      //      console.log('bbox:', bbox, 'finalCoordSpaceEndpoints', finalCoordSpaceEndpoints, 'viewBox', viewBox, 'pathPart:', pathPart);
      return renderedSvg;
    },

    makeEllipse: function makeEllipse(opts) {
      var dimensions = opts.dimensions;
      var buffer = opts.buffer || 4;
      var viewBoxRaw = '0 0 ' + dimensions.width + ' ' + dimensions.height;
      var viewBox = sticker.makeBufferedViewBox({ buffer: buffer, bufferAllSides: true, viewBox: viewBoxRaw });
      var shapeObj = { cx: dimensions.width / 2,
        cy: dimensions.height / 2,
        rx: Math.max(0, dimensions.width / 2 - opts.buffer),
        ry: Math.max(0, dimensions.height / 2 - opts.buffer),
        stroke: opts.color,
        "stroke-width": opts.strokeWidth,
        "fill-opacity": opts.fillOpacity,
        fill: opts.color
      };
      sticker.interpretDashing(opts, shapeObj);

      var theEllipse = sticker.makeSvgElement('ellipse', shapeObj);
      var parmBlock = {
        el: theEllipse,
        x: dimensions.x,
        y: dimensions.y,
        width: dimensions.width,
        height: dimensions.height,
        viewBox: viewBox
      };

      var renderedSvg = sticker.renderSvg([parmBlock]);
      return renderedSvg;
    },

    makeBullsEye: function makeBullsEye(opts) {
      var dimensions = opts.dimensions;
      var buffer = opts.buffer || 4;
      var viewBoxRaw = '0 0 ' + dimensions.width + ' ' + dimensions.height;
      var viewBox = sticker.makeBufferedViewBox({ buffer: buffer, bufferAllSides: true, viewBox: viewBoxRaw });
      var shapeHash = void 0,
          shapeObj = void 0,
          parmBlocks = [];
      for (var ringCtr = 1; ringCtr < 6; ringCtr += 2) {
        shapeHash = { cx: dimensions.width / 2,
          cy: dimensions.height / 2,
          rx: Math.max(0, dimensions.width / 2 - opts.buffer) / ringCtr,
          ry: Math.max(0, dimensions.height / 2 - opts.buffer) / ringCtr,
          stroke: opts.color,
          "stroke-width": opts.strokeWidth,
          "fill-opacity": opts.fillOpacity,
          fill: opts.color
        };
        shapeObj = sticker.makeSvgElement('ellipse', shapeHash);
        parmBlocks.push({
          el: shapeObj,
          x: dimensions.x,
          y: dimensions.y,
          width: dimensions.width,
          height: dimensions.height,
          viewBox: viewBox
        });
      }

      var renderedSvg = sticker.renderSvg(parmBlocks);
      return renderedSvg;
    },

    makeBufferedViewBox: function makeBufferedViewBox(opts) {
      var doubleBuffer = opts.buffer * 2;
      var bufferedViewBox = void 0;
      var viewBox = void 0;
      if (typeof opts.viewBox === 'string') {
        viewBox = opts.viewBox.split(' ');
      } else {
        viewBox = opts.viewBox;
      }
      if (opts.bufferAllSides) {
        bufferedViewBox = [parseInt(viewBox[0]) - opts.buffer, parseInt(viewBox[1]) - opts.buffer, parseInt(viewBox[2]) + doubleBuffer, parseInt(viewBox[3]) + doubleBuffer];
      } else {
        bufferedViewBox = [parseInt(viewBox[0]), parseInt(viewBox[1]), parseInt(viewBox[2]) + doubleBuffer, parseInt(viewBox[3]) + doubleBuffer];
      }
      return bufferedViewBox.join(' ');
    },

    makeSimplePath: function makeSimplePath(opts) {
      var buffer = opts.buffer === undefined ? 4 : opts.buffer;
      var doubleBuffer = buffer * 2;
      var viewBox = sticker.makeBufferedViewBox({ buffer: buffer, bufferAllSides: true, viewBox: opts.viewBox });
      var color = opts.color === undefined ? '#000' : opts.color;
      var strokeWidth = opts.strokeWidth === undefined ? 3 : opts.strokeWidth;
      var outerClass = opts.outerClass === undefined ? 'graffiti-sticker-inner' : opts.outerClass;
      var pathObj = void 0,
          thePath = void 0,
          parmBlock = void 0;
      var renderParms = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = opts.d[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var dRec = _step2.value;

          pathObj = {
            'vector-effect': 'non-scaling-stroke',
            'stroke-width': strokeWidth,
            stroke: color,
            d: dRec
          };

          if (opts.fill !== undefined) {
            pathObj.fill = opts.fill;
          } else {
            pathObj['fill-opacity'] = 0;
          }

          if (opts.transform !== undefined) {
            pathObj.transform = opts.transform;
          }

          if (opts.fillOpacity !== undefined) {
            pathObj['fill-opacity'] = opts.fillOpacity;
            pathObj.fill = opts.color;
          }

          sticker.interpretDashing(opts, pathObj);

          thePath = sticker.makeSvgElement('path', pathObj);
          parmBlock = {
            el: thePath,
            x: opts.dimensions.x - buffer,
            y: opts.dimensions.y - buffer,
            width: opts.dimensions.width + doubleBuffer,
            height: opts.dimensions.height + doubleBuffer,
            outerClass: outerClass,
            title: opts.title,
            viewBox: viewBox
          };
          if (opts.cssTransform !== undefined) {
            parmBlock.cssTransform = opts.cssTransform;
          }
          if (opts.metaTag !== undefined) {
            parmBlock.metaTag = opts.metaTag;
          }
          renderParms.push(parmBlock);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      var renderedSvg = sticker.renderSvg(renderParms);
      return renderedSvg;
    },

    makeRightCurlyBracePath: function makeRightCurlyBracePath(opts) {
      var _pathObj;

      var pathObj = (_pathObj = {
        stroke: opts.color,
        "stroke-width": opts.strokeWidth,
        "vector-effect": "non-scaling-stroke"
      }, _defineProperty(_pathObj, 'stroke-width', "3"), _defineProperty(_pathObj, "fill-opacity", 0), _defineProperty(_pathObj, 'd', "M0,0 A100, 173.20508075688772 0 0 1  100, 173.20508075688772 A100, " + "173.20508075688772 0 0 0 200 346.41016151377545 A100, " + "173.20508075688772 0 0 0 100, 519.6152422706632 A100, " + "173.20508075688772 0 0 1 0, 692.8203230275509"), _pathObj);
      sticker.interpretDashing(opts, pathObj);
      var rightCurlyBracePath = sticker.makeSvgElement('path', pathObj);
      return rightCurlyBracePath;
    },

    makeLeftCurlyBrace: function makeLeftCurlyBrace(opts) {
      var curlyViewBox = '0 0 200 692';
      var curlyBracePath = sticker.makeRightCurlyBracePath({
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      });
      var renderedSvg = sticker.renderSvg([{
        el: curlyBracePath,
        width: 8,
        height: opts.dimensions.height,
        viewBox: curlyViewBox,
        x: opts.dimensions.x,
        y: opts.dimensions.y,
        cssTransform: "scaleX(-1)" // css transform
      }]);
      return renderedSvg;
    },

    makeRightCurlyBrace: function makeRightCurlyBrace(opts) {
      var curlyViewBox = '0 0 200 692';
      var curlyBracePath = sticker.makeRightCurlyBracePath({
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      });
      var renderedSvg = sticker.renderSvg([{
        el: curlyBracePath,
        width: 8,
        height: opts.dimensions.height,
        viewBox: curlyViewBox,
        x: opts.dimensions.x,
        y: opts.dimensions.y
      }]);
      return renderedSvg;
    },

    makeSymmetricCurlyBraces: function makeSymmetricCurlyBraces(opts) {
      var curlyViewBox = '0 0 200 692';
      var curlyBracePath1 = sticker.makeRightCurlyBracePath({
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      });
      var curlyBracePath2 = sticker.makeRightCurlyBracePath({
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      });
      var renderedSvg = sticker.renderSvg([{
        el: curlyBracePath1,
        width: 8,
        height: opts.dimensions.height,
        viewBox: curlyViewBox,
        x: opts.dimensions.x - 1,
        y: opts.dimensions.y,
        cssTransform: "scaleX(-1)" // css transform
      }, {
        el: curlyBracePath2,
        width: 8,
        height: opts.dimensions.height,
        viewBox: curlyViewBox,
        x: opts.dimensions.x + opts.dimensions.width - 8 + 1,
        y: opts.dimensions.y,
        dashed: opts.dashed,
        color: opts.color,
        strokeWidth: opts.strokeWidth
      }]);
      //console.log(renderedSvg);
      return renderedSvg;
    },

    makeTopBracket: function makeTopBracket(opts) {
      var width = opts.dimensions.width;
      var height = opts.dimensions.height;
      return sticker.makeSimplePath($.extend({}, true, opts, {
        buffer: 0,
        viewBox: [0, 0, width, height],
        d: ['M 0 ' + height + ' L 0 0 L ' + width + ' 0 L ' + width + ' ' + height]
      }));
    },

    makeBottomBracket: function makeBottomBracket(opts) {
      var width = opts.dimensions.width;
      var height = opts.dimensions.height;
      return sticker.makeSimplePath($.extend({}, true, opts, {
        viewBox: [0, 0, width, height],
        d: ['M 0 0 L 0 ' + height + ' L ' + width + ' ' + height + ' L ' + width + '0']
      }));
    },

    makeLeftBracket: function makeLeftBracket(opts) {
      var width = opts.dimensions.width;
      var height = opts.dimensions.height;
      return sticker.makeSimplePath($.extend({}, true, opts, {
        buffer: 0,
        viewBox: [0, 0, width, height],
        d: ['M ' + width + ' ' + height + ' L 0 ' + height + ' L 0 0 L ' + width + ' 0']
      }));
    },

    makeRightBracket: function makeRightBracket(opts) {
      var width = opts.dimensions.width;
      var height = opts.dimensions.height;
      return sticker.makeSimplePath($.extend({}, true, opts, {
        buffer: 0,
        viewBox: [0, 0, width, height],
        d: ['M 0 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L 0 ' + height]
      }));
    },

    makeHorizontalBrackets: function makeHorizontalBrackets(opts) {
      var width = opts.dimensions.width;
      var height = opts.dimensions.height;
      var bracketHeight1 = Math.min(sticker.minBracketWidth, parseInt(height / 10));
      var bracketHeight2 = Math.max(height - sticker.minBracketWidth, height - parseInt(height / 10));
      return sticker.makeSimplePath($.extend({}, true, opts, {
        buffer: 0,
        viewBox: [0, 0, width, height],
        d: ['M 0 ' + bracketHeight1 + ' L 0 0 L ' + width + ' 0 L ' + width + ' ' + bracketHeight1, 'M 0 ' + bracketHeight2 + ' L 0 ' + height + ' L ' + width + ' ' + height + ' L ' + width + ' ' + bracketHeight2]
      }));
    },

    makeVerticalBrackets: function makeVerticalBrackets(opts) {
      var width = opts.dimensions.width;
      var height = opts.dimensions.height;
      var bracketWidth1 = Math.min(sticker.minBracketWidth, parseInt(width / 10));
      var bracketWidth2 = Math.max(width - sticker.minBracketWidth, width - parseInt(width / 10));
      return sticker.makeSimplePath($.extend({}, true, opts, {
        viewBox: [0, 0, width, height],
        d: ['M ' + bracketWidth1 + ' 0 L 0 0 L 0 ' + height + ' L ' + bracketWidth1 + ' ' + height, 'M ' + bracketWidth2 + ' 0 L ' + width + ' 0 L ' + width + ' ' + height + ' L ' + bracketWidth2 + ' ' + height]
      }));
    },

    makeRectangle: function makeRectangle(opts) {
      var dimensions = opts.dimensions;
      var buffer = opts.buffer || 4;
      var viewBoxRaw = '0 0 ' + dimensions.width + ' ' + dimensions.height;
      var viewBox = sticker.makeBufferedViewBox({ buffer: buffer, bufferAllSides: true, viewBox: viewBoxRaw });
      var shapeObj = { x: 0,
        y: 0,
        width: dimensions.width,
        height: dimensions.height,
        stroke: opts.color,
        fill: opts.color,
        "stroke-width": opts.strokeWidth,
        "fill-opacity": opts.fillOpacity
      };
      sticker.interpretDashing(opts, shapeObj);
      if (opts.rx !== undefined) {
        // check for roundrect
        shapeObj.rx = opts.rx;
        shapeObj.ry = opts.ry;
      }
      var theRect = sticker.makeSvgElement('rect', shapeObj);
      var parmBlock = {
        el: theRect,
        x: dimensions.x,
        y: dimensions.y,
        width: dimensions.width,
        height: dimensions.height,
        viewBox: viewBox
      };

      var renderedSvg = sticker.renderSvg([parmBlock]);
      return renderedSvg;
    },

    makeRightTriangle: function makeRightTriangle(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        viewBox: [0, 0, 100, 125],
        d: ["M 0 125 L 100 125 L 0 0 Z"]
      }));
    },

    makeIsocelesTriangle: function makeIsocelesTriangle(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        viewBox: [0, 0, 100, 125],
        d: ["M 0 125 L 100 125 L 50 0 Z"]
      }));
    },

    makeTheta: function makeTheta(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        viewBox: [0, 0, 469, 700],
        d: ["M469 334c-2,440 -453,468 -469,2 -13,-435 472,-460 469,-2zm-383 -20l298 0c-9,-366 -288,-376 -298,-6l0 6zm297 46l-297 0c16,345 279,397 297,11 0,-4 0,-7 0,-11z"],
        fill: opts.color
      }));
    },

    makeSigma: function makeSigma(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 16, 16],
        d: ['M2,1l5.46,7.27L2,15h12v-4h-1v1c0,0.552-0.448,1-1,1H4.97l4.39-5.52L5.25,2H12c0.552,0,1,0.448,1,1v1h1V1H2z'],
        fill: opts.color
      }));
    },

    makeSmiley: function makeSmiley(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 49, 49],
        d: ['M25,1A24,24,0,1,0,49,25,24,24,0,0,0,25,1Zm0,46A22,22,0,1,1,47,25,22,22,0,0,1,25,47ZM35.77,33.32a1,1,0,0,1-.13,1.41C31.73,38,28.06,39.1,24.9,39.1a16,16,0,0,1-10.63-4.45,1,1,0,0,1,1.45-1.38c0.34,0.35,8.35,8.52,18.63-.08A1,1,0,0,1,35.77,33.32ZM15,19a3,3,0,1,1,3,3A3,3,0,0,1,15,19Zm14,0a3,3,0,1,1,3,3A3,3,0,0,1,29,19Z'],
        fill: opts.color
      }));
    },

    makeFrowney: function makeFrowney(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 100, 125],
        d: ['M50,2.5C23.809,2.5,2.5,23.809,2.5,50S23.809,97.5,50,97.5S97.5,76.191,97.5,50S76.191,2.5,50,2.5z M50,91.684    C27.016,91.684,8.316,72.984,8.316,50S27.016,8.316,50,8.316S91.684,27.016,91.684,50S72.984,91.684,50,91.684z M37.489,41.386    c2.964,0,5.369-2.403,5.369-5.369c0-2.966-2.405-5.368-5.369-5.368c-2.966,0-5.369,2.402-5.369,5.368    C32.12,38.982,34.523,41.386,37.489,41.386z M62.511,41.386c2.965,0,5.369-2.403,5.369-5.369c0-2.966-2.404-5.368-5.369-5.368    c-2.966,0-5.368,2.402-5.368,5.368C57.143,38.982,59.545,41.386,62.511,41.386z M50.001,51.186    c-13.939,0-20.525,9.548-22.06,14.597c-0.467,1.537,0.399,3.161,1.936,3.628c1.539,0.471,3.161-0.399,3.628-1.936    c0.032-0.105,3.336-10.473,16.496-10.473c13.015,0,16.363,10.061,16.494,10.472c0.381,1.255,1.534,2.063,2.781,2.063    c0.28,0,0.564-0.04,0.846-0.127c1.538-0.467,2.405-2.091,1.938-3.627C70.524,60.733,63.939,51.186,50.001,51.186z']
      }));
    },

    makeThumbsUp: function makeThumbsUp(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 218, 346.25],
        d: ['M28 263l31 -9c64,42 77,13 92,10 4,0 1,4 17,0 22,-7 31,-19 23,-35 19,-6 21,-18 15,-33 15,-9 15,-26 3,-38 19,-37 -11,-67 -80,-48 -5,-36 11,-59 5,-80 -7,-27 -25,-31 -50,-30 3,68 8,35 -25,101 -27,55 -3,48 -57,63 -6,36 4,70 26,99zm4 -12c-16,-24 -23,-49 -21,-77 48,-14 33,-15 57,-65 33,-71 31,-34 27,-97 31,1 32,26 26,50 -7,27 -6,40 -1,62 26,-7 74,-21 82,6 7,27 -22,40 -35,41l-42 -7c9,-28 36,-19 44,-19l10 -3 7 -13c-29,8 -10,3 -31,4 -24,1 -40,15 -43,40l8 1c-8,7 -13,16 -14,28l9 1c-5,6 -10,15 -12,26l14 3c-5,7 -9,15 -11,26l29 4c-29,10 -50,-1 -74,-20l-29 9zm87 -58c12,-30 27,-10 49,-12 5,0 27,-7 33,-14 24,20 -36,32 -39,33l-43 -7zm-2 27l10 -15c44,7 28,8 70,-4 10,19 -35,26 -35,26l-45 -7zm3 30l9 -17c36,5 26,7 53,0 4,16 -17,22 -23,22l-39 -5z'],
        fill: opts.color
      }));
    },

    makeThumbsDown: function makeThumbsDown(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 226, 357.5],
        d: ['M18 27l33 4c59,-51 77,-23 92,-23 5,0 0,-4 18,-2 23,3 33,15 28,32 20,4 24,15 20,32 17,7 19,23 8,37 25,36 -1,70 -74,60 0,38 19,59 16,82 -3,27 -21,34 -46,37 -6,-70 3,-37 -40,-99 -35,-52 -10,-48 -67,-56 -11,-36 -6,-71 12,-104zm6 12c-13,26 -16,53 -10,81 51,7 35,11 67,58 44,66 36,29 41,95 32,-7 29,-32 19,-55 -11,-27 -11,-40 -9,-63 27,4 78,10 82,-18 4,-28 -28,-37 -41,-36l-42 13c13,27 39,14 48,13l10 1 9 12c-30,-4 -10,-1 -33,1 -23,2 -41,-9 -49,-34l8 -3c-8,-6 -15,-14 -18,-26l9 -3c-6,-5 -11,-13 -16,-24l15 -5c-7,-6 -12,-15 -15,-25l28 -8c-30,-7 -50,8 -72,30l-31 -4zm96 46c17,28 30,7 52,5 6,-1 29,4 36,9 21,-23 -42,-27 -44,-27l-44 13zm-5 -27l12 14c44,-13 27,-12 72,-6 7,-21 -39,-22 -40,-22l-44 14zm-1 -31l11 16c36,-11 26,-11 54,-7 2,-18 -20,-20 -27,-20l-38 11z'],
        fill: opts.color
      }));
    },

    makeStar: function makeStar(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 1024, 1280],
        d: ['M521.19122173 257.59668148l48.67463902 112.36592198c10.61521383 24.46677333 33.65799506 41.42522469 60.32548344 44.14375505l123.62840495 12.55702124-92.30057877 79.48464988c-20.71261235 17.86462815-29.90383408 45.43829333-23.8195042 72.10578173l27.44421136 121.68659752-105.37541531-64.20909827c-11.52139061-6.99050667-24.85513482-10.74466765-38.31833283-10.74466765-13.59265185 0-26.79694222 3.75416098-38.31833286 10.74466765l-105.37541529 64.20909827 27.44421135-121.68659752c5.95487605-26.66748839-3.10689185-54.24115358-23.8195042-72.10578173l-92.30057876-79.48464988 123.62840494-12.55702124c26.53803457-2.71853037 49.71026963-19.5475279 60.32548346-44.14375505l48.1568237-112.36592198m0-117.80298272c-6.2137837 0-12.55702124 3.3657995-15.40500543 10.09739852l-85.43952593 197.28763258c-2.45962272 5.56651457-7.63777581 9.45012939-13.72210568 10.09739853l-216.446799 22.00715063c-14.7577363 1.55344592-20.45370469 19.80643555-9.32067556 29.51547258l163.11182222 140.45740248c4.66033778 4.01306864 6.86105283 10.35630617 5.43706074 16.44063605l-48.1568237 213.98717629c-2.58907653 11.26248297 6.34323753 20.58315852 16.44063604 20.58315852 2.84798419 0 5.95487605-0.77672297 8.67340642-2.45962272l186.15460346-113.40155259c2.71853037-1.68289975 5.69596839-2.45962272 8.80286024-2.45962272s6.08432987 0.77672297 8.80286026 2.45962272l186.15460344 113.40155259c2.84798419 1.68289975 5.82542222 2.45962272 8.67340644 2.45962272 10.09739852 0 19.02971259-9.32067555 16.44063604-20.58315852L693.23535803 565.69679013c-1.4239921-6.08432987 0.77672297-12.42756741 5.43706073-16.44063605l163.11182222-140.45740248c11.26248297-9.70903703 5.43706075-27.96202667-9.32067555-29.51547258l-216.44679901-22.00715063c-6.08432987-0.64726914-11.26248297-4.40143013-13.72210567-10.09739853l-85.43952593-197.28763258c-3.23634569-6.73159902-9.45012939-10.09739852-15.66391309-10.09739852z'],
        fill: opts.color
      }));
    },

    makeRibbon: function makeRibbon(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: '0 0 100 100',
        d: ["M76.979,12.22c-0.366-0.579-1.004-0.93-1.689-0.93H59.165c-0.768,0-1.468,0.439-1.802,1.132l-6.634,13.76l-7.117-13.808  c-0.343-0.666-1.028-1.084-1.777-1.084H24.71c-0.686,0-1.323,0.351-1.689,0.93c-0.367,0.579-0.411,1.306-0.118,1.926l15.213,32.151  c-6.585,4.021-10.99,11.274-10.99,19.538C27.125,78.448,37.387,88.71,50,88.71s22.875-10.262,22.875-22.875  c0-8.264-4.405-15.518-10.99-19.538l15.213-32.151C77.391,13.525,77.347,12.799,76.979,12.22z M27.869,15.29h12.747l14.572,28.271  C53.521,43.172,51.785,42.96,50,42.96c-2.927,0-5.724,0.559-8.299,1.564L27.869,15.29z M68.875,65.835  c0,10.407-8.468,18.875-18.875,18.875s-18.875-8.468-18.875-18.875S39.593,46.96,50,46.96S68.875,55.428,68.875,65.835z   M59.201,42.617l-6.178-11.984l7.397-15.343h11.71L59.201,42.617z M48.207,53.277l-2.999,6.074l-6.703,0.973  c-0.754,0.109-1.38,0.638-1.615,1.361s-0.039,1.519,0.506,2.051l4.852,4.728l-1.146,6.677c-0.128,0.75,0.181,1.509,0.796,1.956  c0.349,0.253,0.762,0.382,1.176,0.382c0.318,0,0.638-0.076,0.931-0.229L50,74.098l5.994,3.151c0.675,0.353,1.491,0.295,2.106-0.152  s0.924-1.206,0.796-1.956l-1.145-6.677l4.852-4.728c0.545-0.532,0.741-1.327,0.506-2.051s-0.861-1.252-1.615-1.361l-6.703-0.973  l-2.997-6.074c-0.337-0.683-1.032-1.115-1.794-1.115C49.239,52.162,48.544,52.595,48.207,53.277z M51.669,62.064  c0.292,0.591,0.855,1,1.507,1.095l3.732,0.542l-2.7,2.632c-0.472,0.46-0.687,1.122-0.576,1.771l0.638,3.72l-3.339-1.756  c-0.582-0.307-1.279-0.307-1.861,0l-3.34,1.756l0.638-3.72c0.11-0.648-0.104-1.311-0.575-1.771l-2.701-2.632l3.732-0.542  c0.651-0.095,1.215-0.504,1.506-1.095L50,58.682L51.669,62.064z"],
        fill: opts.color
      }));
    },

    makeAxis: function makeAxis(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: opts.strokeWidth,
        viewBox: '0 0 90 90',
        d: ["M89.7,85.7c0,0.2-0.1,0.3-0.2,0.4l-3.2,2.2c-0.1,0.1-0.2,0.1-0.3,0.1c-0.1,0-0.2,0-0.2-0.1c-0.2-0.1-0.3-0.3-0.3-0.4v-1.2  H13c-0.6,0-1-0.4-1-1V15.8h-1.2c-0.2,0-0.4-0.1-0.4-0.3c-0.1-0.2-0.1-0.4,0-0.5l2.2-3.2c0.2-0.3,0.6-0.3,0.8,0l2.2,3.2  c0.1,0.2,0.1,0.4,0,0.5c-0.1,0.2-0.3,0.3-0.4,0.3H14v68.9h71.4v-1.2c0-0.2,0.1-0.4,0.3-0.4c0.2-0.1,0.4-0.1,0.5,0l3.2,2.2  C89.6,85.4,89.7,85.6,89.7,85.7z"],
        fill: 'solid'
      }));
    },

    makeBomb: function makeBomb(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: opts.strokeWidth,
        viewBox: '0 0 100 100',
        d: ["M44.5,44.4v-3.9c0-1.1-0.9-2-2-2h-5.6c0-2.2,0.3-5.1,1.8-6.9c1.1-1.3,2.6-1.9,4.7-1.9c3.1,0,6.1,1.2,8.9,2.3  c5.4,2.2,11.1,4.4,16.9-1.6c0.6-0.6,0.6-1.5,0-2.1c-0.6-0.6-1.5-0.6-2.1,0c-4.4,4.6-8.5,3-13.6,0.9c-3.1-1.3-6.4-2.6-10-2.6  c-3,0-5.3,1-7,3c-2.2,2.6-2.5,6.3-2.5,8.8h-5.1c-1.1,0-2,0.9-2,2v3.9C18.3,47.9,12.3,56.3,12.3,66c0,12.9,10.4,23.3,23.3,23.3  S59,78.9,59,66C59,56.3,53,47.9,44.5,44.4z M32.9,80.3c-0.2,0.6-0.8,1.1-1.4,1.1c-0.1,0-0.3,0-0.4-0.1c-6.8-2-11.3-8.2-11.3-15.3  c0-3.5,1.1-6.9,3.3-9.7c0.5-0.7,1.4-0.8,2.1-0.3c0.7,0.5,0.8,1.4,0.3,2.1c-1.7,2.3-2.7,5-2.7,7.9c0,5.7,3.8,10.8,9.2,12.4  C32.7,78.6,33.2,79.5,32.9,80.3z", "M82.3,14.5c0.5-0.6,0.5-1.6-0.2-2.1c-0.6-0.5-1.6-0.5-2.1,0.2l-8.6,10.1c-0.5,0.6-0.5,1.6,0.2,2.1c0.3,0.2,0.6,0.4,1,0.4  c0.4,0,0.8-0.2,1.1-0.5L82.3,14.5z", "M60.7,13.9C60.7,13.9,60.7,13.9,60.7,13.9l3.9,8.7c0,0,0,0,0,0l0.5,1.1c0.3,0.6,0.8,0.9,1.4,0.9c0.2,0,0.4,0,0.6-0.1  c0.8-0.3,1.1-1.2,0.7-2l-0.5-1.1c0,0,0,0,0,0l-3.9-8.7c0,0,0,0,0,0l-0.5-1.1c-0.3-0.8-1.2-1.1-2-0.7c-0.8,0.3-1.1,1.2-0.7,2  L60.7,13.9z", "M75.5,32.4c-0.6-0.6-1.6-0.5-2.1,0.1c-0.6,0.6-0.5,1.6,0.1,2.1l9.7,9.2c0.3,0.3,0.7,0.4,1,0.4c0.4,0,0.8-0.2,1.1-0.5  c0.6-0.6,0.5-1.6-0.1-2.1L75.5,32.4z", "M86.2,26.6l-10.5,0c-0.8,0-1.5,0.7-1.5,1.5c0,0.8,0.7,1.5,1.5,1.5l10.5,0c0.8,0,1.5-0.7,1.5-1.5  C87.7,27.3,87,26.6,86.2,26.6z", "M50.9,21.7l11.6,5.4c0.2,0.1,0.4,0.1,0.6,0.1c0.6,0,1.1-0.3,1.4-0.9c0.4-0.8,0-1.6-0.7-2L52.2,19c-0.7-0.4-1.6,0-2,0.7  C49.9,20.5,50.2,21.3,50.9,21.7z", "M69.5,34.8c-0.8,0-1.5,0.7-1.5,1.5l0,11.3c0,0.8,0.7,1.5,1.5,1.5c0.8,0,1.5-0.7,1.5-1.5l0-11.3C71,35.4,70.4,34.8,69.5,34.8  z"],
        fill: opts.color
      }));
    },

    makeCheckmark: function makeCheckmark(opts) {
      var dimensions = void 0;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
      } else {
        dimensions = { x: opts.dimensions.x,
          y: opts.dimensions.y,
          width: Math.max(opts.dimensions.width, 25),
          height: Math.max(opts.dimensions.height, 25)
        };
      }
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: opts.strokeWidth,
        viewBox: '0 0 587 783.75',
        d: ["M0 303c61,65 122,129 184,194 134,-166 227,-376 403,-497 -181,160 -285,402 -400,627 -62,-108 -125,-216 -187,-324z"],
        color: '#090',
        fill: '#4f4',
        dimensions: dimensions,
        dashed: undefined
      }));
    },

    makeXmark: function makeXmark(opts) {
      var dimensions = void 0,
          strokeWidth = void 0;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 5;
        dimensions = { x: opts.dimensions.x,
          y: opts.dimensions.y,
          width: Math.max(opts.dimensions.width, 25),
          height: Math.max(opts.dimensions.height, 25)
        };
      }
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: strokeWidth,
        viewBox: '0 0 100 100',
        d: ["M10 10 L 80 80 M 80 10 L 10 80"],
        color: 'red',
        dimensions: dimensions,
        dashed: undefined
      }));
    },

    makePi: function makePi(opts) {
      var dimensions = void 0,
          strokeWidth = void 0;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 1;
        dimensions = { x: opts.dimensions.x,
          y: opts.dimensions.y,
          width: Math.max(opts.dimensions.width, 25)
        };
        dimensions.height = dimensions.width;
      }
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: strokeWidth,
        viewBox: '0 0 110 137.5',
        d: ["M21.33,40.487h-3.057c0,0,2.938-21.636,19.974-21.636s53.479,0,53.479,0v11.337H74.157c0,0-3.265,22.259-3.265,34.25  c0,11.989,7.242,14.363,10.091,14.363s7.479-5.46,7.479-6.528c0-1.069,0-2.612,0-2.612h3.265c0,0-1.009,21.487-15.848,21.487  c-14.84,0-13.415-24.93-13.296-25.761c0.118-0.831,3.087-35.021,3.087-35.021H47.15c0,0-0.514,26.395-2.256,34.151  c-1.741,7.756-3.481,26.631-13.139,26.631c-9.654,0-6.171-8.586-6.013-9.379c0.157-0.791,7.122-10.289,8.705-14.72  c1.582-4.432,3.799-36.723,3.799-36.723s-9.676-1.613-13.296,4.273C21.33,40.487,21.33,40.487,21.33,40.487z"],
        color: opts.color,
        fill: opts.color,
        dimensions: dimensions,
        dashed: undefined
      }));
    },

    makeAlpha: function makeAlpha(opts) {
      var dimensions = void 0,
          strokeWidth = void 0;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 1;
        dimensions = { x: opts.dimensions.x,
          y: opts.dimensions.y,
          width: Math.max(opts.dimensions.width, 25)
        };
        dimensions.height = dimensions.width;
      }
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: strokeWidth,
        viewBox: '0 0 1000 1250',
        d: ["M893 755c14,-17 39,-19 56,-5 17,15 19,40 4,57 -181,211 -273,23 -329,-153 -254,411 -603,196 -586,-174 16,-346 418,-629 607,-33 47,-101 88,-205 131,-308 9,-20 32,-30 52,-22 21,9 30,32 22,53 -54,130 -106,263 -172,388 37,123 74,361 215,197zm-300 -204c-166,-554 -461,-392 -476,-68 -15,337 264,458 476,68z"],
        color: opts.color,
        fill: opts.color,
        dimensions: dimensions,
        dashed: undefined
      }));
    },

    makeBeta: function makeBeta(opts) {
      var dimensions = void 0,
          strokeWidth = void 0;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 1;
        dimensions = { x: opts.dimensions.x,
          y: opts.dimensions.y,
          width: Math.max(opts.dimensions.width, 25)
        };
        dimensions.height = dimensions.width;
      }
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: strokeWidth,
        viewBox: '0 0 1000 1250',
        d: ["M291 982c-15,8 -33,2 -40,-13 -8,-14 -3,-32 12,-40 64,-34 46,-199 28,-374 -13,-118 -26,-241 -14,-338 16,-131 74,-218 227,-200 10,2 21,4 32,8 32,11 64,34 86,66 23,33 35,75 29,126 -2,16 -6,33 -12,51 -6,15 -12,30 -20,44 23,10 44,26 63,46 28,31 50,73 61,118 12,45 14,93 2,137 -28,111 -133,196 -358,138 -10,-2 -17,-9 -21,-18 5,118 -8,213 -75,249zm61 -448c6,56 12,112 15,164 5,-15 21,-24 36,-20 182,46 265,-14 286,-95 9,-34 8,-72 -2,-108 -9,-35 -25,-68 -47,-92 -17,-17 -36,-30 -58,-34 -12,13 -24,23 -36,32 -15,11 -29,18 -42,22 -19,5 -36,4 -50,-6 -8,-6 -15,-15 -18,-27 -3,-11 1,-23 9,-30l0 0c38,-35 76,-52 112,-55 11,-15 21,-33 27,-52 5,-14 8,-27 10,-39 4,-34 -4,-63 -19,-84 -15,-21 -36,-36 -57,-44 -7,-2 -13,-4 -20,-4 -107,-14 -148,50 -160,147 -11,91 2,210 14,325z"],
        color: opts.color,
        fill: opts.color,
        dimensions: dimensions,
        dashed: undefined
      }));
    },

    makeGrid: function makeGrid(opts) {
      var dimensions = void 0,
          strokeWidth = void 0;
      if (opts.iconUsage) {
        dimensions = $.extend({}, opts.dimensions);
        strokeWidth = opts.strokeWidth;
      } else {
        strokeWidth = 1;
        dimensions = { x: opts.dimensions.x,
          y: opts.dimensions.y,
          width: Math.max(opts.dimensions.width, 25)
        };
        dimensions.height = dimensions.width;
      }
      var numGridLines = 10;
      var viewBoxSize = 100;
      var gridInc = viewBoxSize / numGridLines;
      var viewBox = sticker.makeBufferedViewBox({ buffer: 5, viewBox: [0, 0, viewBoxSize, viewBoxSize] });
      var gridCtr = void 0,
          gridVal = void 0,
          d = '';
      for (gridCtr = 0; gridCtr <= numGridLines; ++gridCtr) {
        gridVal = gridCtr * gridInc;
        d += 'M 0 ' + gridVal + ' ' + 'L ' + viewBoxSize + ' ' + gridVal + ' ';
        d += 'M ' + gridVal + ' 0 ' + 'L ' + gridVal + ' ' + viewBoxSize + ' ';
      }

      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: strokeWidth,
        viewBox: viewBox,
        d: [d],
        dimensions: dimensions,
        dashed: undefined
      }));
    },

    makeRightSideMarker: function makeRightSideMarker(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 100, 50],
        d: ["M 0 25 L 25 0 L 100 0 L 100 50 L 25 50 Z"],
        fill: opts.color,
        outerClass: 'graffiti-right-side-marker',
        buffer: 0
      }));
    },

    makeAngle: function makeAngle(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 30, 35],
        transform: "translate(-390 -560)",
        d: ["M401.883,578.324l12.971-12.971l-0.707-0.707L390.793,588H419v-1h-13.524    C405.357,583.749,404.098,580.706,401.883,578.324z M393.207,587l7.969-7.969c2.026,2.192,3.183,4.984,3.3,7.969H393.207z"],
        fill: opts.color
      }));
    },

    makeTrophy: function makeTrophy(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 2,
        viewBox: [0, 0, 100, 125],
        d: ["M69.402,82.288H30.598c-0.855,0-1.548,0.692-1.548,1.548v8.462c0,0.857,0.693,1.55,1.548,1.55h38.804  c0.854,0,1.549-0.693,1.549-1.55v-8.462C70.951,82.98,70.258,82.288,69.402,82.288z", "M93.357,15.879c-1.635-2.293-5.112-4.738-12.479-4.309c0.062-1.208,0.104-2.446,0.123-3.716  c0.017-0.94-0.681-1.703-1.537-1.703H20.536c-0.856,0-1.551,0.762-1.537,1.703c0.019,1.271,0.061,2.508,0.123,3.717  c-7.363-0.43-10.845,2.013-12.479,4.307c-2.331,3.271-2.174,8,0.428,12.978c3.722,7.119,12.165,14.247,22.486,16.61  C36.188,54.68,43.49,57.225,43.49,57.225h13.021c0,0,7.301-2.545,13.934-11.759c10.32-2.365,18.764-9.492,22.486-16.61  C95.532,23.88,95.688,19.15,93.357,15.879z M11.381,26.603c-1.723-3.295-2.007-6.175-0.778-7.9c1.311-1.838,4.444-2.606,8.914-2.228  c1.002,9.551,3.36,16.971,6.236,22.688C19.17,36.406,13.945,31.507,11.381,26.603z M63.782,24.541l-6.49,6.326l1.532,8.933  c0.105,0.611-0.256,0.872-0.803,0.584L50,36.166l-8.023,4.218c-0.547,0.288-0.907,0.026-0.803-0.584l1.533-8.933l-6.49-6.326  c-0.444-0.433-0.306-0.856,0.307-0.945l8.968-1.303l4.011-8.129c0.274-0.556,0.719-0.556,0.993,0l4.011,8.129l8.968,1.303  C64.088,23.685,64.227,24.109,63.782,24.541z M88.619,26.603c-2.564,4.904-7.789,9.804-14.372,12.561  c2.876-5.717,5.233-13.137,6.235-22.688c4.472-0.379,7.604,0.39,8.914,2.228C90.626,20.428,90.342,23.308,88.619,26.603z", "M61.506,78.811c-6.724-9.961-5.283-18.379-5.283-18.379H43.777c0,0,1.44,8.418-5.284,18.379H61.506z"],
        fill: opts.color
      }));
    },

    makeButtonWithCursor: function makeButtonWithCursor(fill) {
      var buttonWithCursor = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 128 120" enable-background="new 0 0 128 128" xml:space="preserve"><path d="M120,28H8c-4.4,0-8,3.6-8,8v32c0,4.4,3.6,8,8,8h81.264l-0.955-4H8c-2.206,0-4-1.794-4-4V36c0-2.206,1.794-4,4-4h112  c2.206,0,4,1.794,4,4v32c0,1.907-1.343,3.5-3.132,3.898l0.358,0.109c1.417,0.431,2.569,1.364,3.32,2.56  C126.629,73.119,128,70.714,128,68V36C128,31.6,124.4,28,120,28z"/><path d="M114.174,81.744l5.973-2.11c0.815-0.288,1.353-1.066,1.333-1.931c-0.019-0.863-0.591-1.617-1.417-1.868l-25.48-7.748  c-0.686-0.21-1.431-0.034-1.952,0.456c-0.522,0.491-0.741,1.225-0.575,1.922l5.773,24.184c0.192,0.805,0.86,1.408,1.681,1.518  c0.82,0.106,1.623-0.297,2.02-1.023l3.009-5.509l9.558,9.766c0.391,0.398,0.909,0.601,1.431,0.601c0.452,0,0.907-0.153,1.28-0.464  l6.476-5.4c0.429-0.357,0.688-0.878,0.716-1.436c0.028-0.557-0.178-1.101-0.567-1.5L114.174,81.744z M115.662,95.281l-10.156-10.377  c-0.379-0.387-0.896-0.601-1.43-0.601c-0.091,0-0.183,0.006-0.274,0.019c-0.628,0.087-1.177,0.467-1.48,1.022l-1.811,3.315  l-3.756-15.732l16.32,4.963l-3.189,1.127c-0.645,0.228-1.128,0.768-1.282,1.434c-0.154,0.665,0.041,1.363,0.519,1.852l9.934,10.148  L115.662,95.281z"/></svg>';
      return buttonWithCursor;
    },

    makeButton: function makeButton(opts) {
      var buttonHtml = '<div class="button-icon" style="width:' + opts.width + 'px;height:' + opts.height + 'px;">' + opts.contents + '</div>';
      return buttonHtml;
    },

    makeTerminal: function makeTerminal(opts) {
      var height = parseInt(opts.width * 0.9);
      var terminalHtml = '<div class="terminal-icon" style="width:' + opts.width + 'px;height:' + height + 'px;">' + '&gt;_' + '</div>';
      return terminalHtml;
    },

    makeLock: function makeLock(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        strokeWidth: 1,
        viewBox: [0, 0, 100, 100],
        d: ["M77.9,41.2h-0.3v-8.9c0-15-11.7-27.6-26.7-28.1c-15.5-0.5-28.3,12-28.3,27.5c0,1.2,1,2.1,2.1,2.1H33c0.9,0,1.7-0.7,1.7-1.7  c0-8.3,6.4-15.5,14.7-15.9c8.9-0.4,16.2,6.7,16.2,15.4v9.4H34.7h-12h-0.6c-4,0-7.3,3.2-7.3,7.3v40c0,4,3.2,7.2,7.2,7.2h55.8  c4,0,7.3-3.2,7.3-7.3v-40C85.1,44.5,81.9,41.2,77.9,41.2z M22.9,87.7v-7l5.5,7H22.9z M34.7,87.7L22.9,72.6v-2.9h4l14.1,18H34.7z   M47.3,87.7l-14.1-18h6.3l14.1,18H47.3z M60,87.7l-14.1-18h6.3l14.1,18H60z M77.1,87.7h-4.5l-14.1-18h6.3l12.3,15.7V87.7z   M77.1,77.3l-5.9-7.6h5.9V77.3z"],
        fill: opts.color
      }));
    },

    makeRunningMan: function makeRunningMan(fill) {
      var runnerIcon = '<svg xmlns:x="http://ns.adobe.com/Extensibility/1.0/" xmlns:i="http://ns.adobe.com/AdobeIllustrator/10.0/" xmlns:graph="http://ns.adobe.com/Graphs/1.0/" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 100 85" style="enable-background:new 10 10 100 70;" xml:space="preserve"><switch><foreignObject requiredExtensions="http://ns.adobe.com/AdobeIllustrator/10.0/" x="0" y="0" width="1" height="1"/><g i:extraneous="self"><g fill-rule="evenodd" fill="' + fill + '"><path d="M48.8,57.3c-0.8-0.5-1.4-1.2-1.8-2c-1.5,4.3-3.6,9.6-4.7,12.2c-2.9,0.1-9.5-0.6-14.9-1.5c-2.3-0.4-4.5,1.2-4.8,3.5     c-0.4,2.3,1.2,4.5,3.5,4.8c0.2,0,4.6,0.7,9.2,1.2c2.5,0.3,4.6,0.4,6.4,0.4c3.9,0,6.2-0.8,7.4-3c0.9-1.6,3-7.1,4.9-12.2     c-1.2-0.8-2.5-1.7-4-2.7C49.4,57.7,49,57.4,48.8,57.3z"/><path d="M97.4,43.5c-0.5-1.7-2.2-2.8-4-2.3c-0.8,0.2-6.7,1.8-10.3,2.8c-0.1-0.4-0.3-0.8-0.4-1.1c-1.4-4.1-3.5-10.3-8.9-12.4     c-1.2-0.5-4-1.7-5.8-2.5c-7.6-3.3-20.8,0.3-22.5,0.9c-0.9,0.4-2.9,1.1-8.7,12.5C36,43,36.7,45,38.3,45.8c0.5,0.2,1,0.4,1.5,0.4     c1.2,0,2.3-0.7,2.9-1.8c1.9-3.7,4.5-8.2,5.5-9.4c1.3-0.4,4.4-1.1,7.8-1.5c-3.7,5.1-7,13.2-7.6,16.1c-0.8,4.2,1,5.6,1.6,6     c1.4,1,14.2,9.5,16.1,11.5c-0.5,2.9-3.1,11.4-5.4,18.4c-0.7,2.2,0.5,4.6,2.7,5.3c0.4,0.1,0.9,0.2,1.3,0.2c1.8,0,3.4-1.1,4-2.9     c2.2-6.8,6-18.6,5.9-22c-0.1-3.3-3.1-6.2-9.7-10.7c2.1-5.2,5.6-12.7,8.9-16.6c1.2,1.8,2.1,4.3,2.7,6.2c1,2.8,1.6,4.8,3.5,5.7     c0.5,0.3,1.1,0.4,1.6,0.4c0.4,0,0.9-0.1,1.3-0.2c1.4-0.5,8-2.3,12.1-3.4C96.8,47,97.8,45.3,97.4,43.5z"/><ellipse transform="matrix(0.3937 -0.9192 0.9192 0.3937 28.3646 78.9709)" cx="74" cy="18" rx="9" ry="9"/><path d="M10.8,34.5h20.7c1.4,0,2.5-1.1,2.5-2.5s-1.1-2.5-2.5-2.5H10.8c-1.4,0-2.5,1.1-2.5,2.5S9.5,34.5,10.8,34.5z"/><path d="M7.9,45h20.7c1.4,0,2.5-1.1,2.5-2.5s-1.1-2.5-2.5-2.5H7.9c-1.4,0-2.5,1.1-2.5,2.5S6.5,45,7.9,45z"/><path d="M28.1,53c0-1.4-1.1-2.5-2.5-2.5H5c-1.4,0-2.5,1.1-2.5,2.5c0,1.4,1.1,2.5,2.5,2.5h20.7C27,55.5,28.1,54.4,28.1,53z"/></g></g></switch></svg>';
      return runnerIcon;
    },

    makeScan: function makeScan(fill) {
      var scanIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100;" xml:space="preserve"><g><g fill-rule="evenodd" fill="' + fill + '"><path d="M23.3,62.8H9.2C6.9,62.8,5,64.7,5,67v14.2c0,2.3,1.9,4.2,4.2,4.2h14.2c2.3,0,4.2-1.9,4.2-4.2V67    C27.5,64.7,25.6,62.8,23.3,62.8z"/><path d="M90.8,62.8H76.7c-2.3,0-4.2,1.9-4.2,4.2v14.2c0,2.3,1.9,4.2,4.2,4.2h14.2c2.3,0,4.2-1.9,4.2-4.2V67    C95,64.7,93.1,62.8,90.8,62.8z"/><path d="M57.1,62.8H42.9c-2.3,0-4.2,1.9-4.2,4.2v14.2c0,2.3,1.9,4.2,4.2,4.2h14.2c2.3,0,4.2-1.9,4.2-4.2V67    C61.2,64.7,59.4,62.8,57.1,62.8z M57.1,81.1C57.1,81.1,57.1,81.1,57.1,81.1l-14.2,0c0,0,0,0,0,0l0-14.2c0,0,0,0,0,0h14.2    c0,0,0,0,0,0L57.1,81.1z"/><path d="M87.5,52.5l5-24.4l-9,3c-3.4-4.6-7.8-8.4-12.9-11.2c-6.2-3.4-13.3-5.2-20.6-5.2c-22.4,0-40.6,17-40.6,37.8    c0,1.7,1.4,3.1,3.1,3.1s3.1-1.4,3.1-3.1C15.6,35.1,31,20.9,50,20.9c10.7,0,20.7,4.6,27.2,12.2L68.8,36L87.5,52.5z"/></g></g></svg>';
      return scanIcon;
    },

    makeRabbit: function makeRabbit(fill) {
      var rabbitIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns" viewBox="0 0 100 75" version="1.1" x="0px" y="10px"><g stroke="none" stroke-width="1" fill-rule="evenodd" sketch:type="MSPage"><g sketch:type="MSArtboardGroup" transform="translate(0.000000, -7.000000)" fill="' + fill + '"><path d="M60.1164483,76.5101184 C60.1164483,77.7869765 61.1184016,79.097951 62.3543737,79.4324469 L72.798828,82.2590697 C74.9502082,82.841306 76.9428079,85.1218308 77.229578,87.3473934 L77.4381368,88.9659749 L61.2268002,86.7611761 C59.0007748,86.4584288 55.762595,85.1122528 53.9830021,83.7528954 L30.0193357,65.4480423 C18.6673757,64.6909954 9.4627489,56.133214 7.77382209,45.1160791 L4.34635739,45.1647777 C1.94608449,45.1988816 -1.83318034e-16,43.2833095 -1.07537429e-17,40.8862227 L12.0835739,27.3645101 C17.4743573,21.3386402 23.6068695,17.4194231 31.6593886,17.4194231 C32.7498041,17.4194231 33.8233498,17.4912885 34.8755022,17.6305187 C36.0956627,17.7349159 37.3050822,17.9433886 38.4888396,18.2605754 C54.0954993,22.4423673 65.570761,42.6024939 65.570761,42.6024939 C66.516058,44.0861571 68.636741,45.6806441 70.3388841,46.136732 L71.0643059,46.3311082 C72.7686884,46.7877961 75.036606,46.0402598 76.1348435,44.6627794 L79.3667959,40.6090557 L69.0683577,35.5886404 C54.9830017,29.5 58.824985,11.8109045 58.824985,11.8109045 C58.9924242,10.7260817 59.7843012,10.4649372 60.587326,11.2216236 L82.7393229,32.0953411 L64.7779732,12.0675015 C65.0289152,8.20500861 68.1652109,7 68.1652109,7 L85.5324488,34.7272898 L86.921334,36.0360295 L96.0521825,42.4677019 C98.138955,43.9376022 99.8625925,47.2144004 99.8888571,49.7773535 L100.007257,61.3310185 L99.3236978,61.8899026 C97.5857982,63.3108255 94.5445704,63.6651439 92.5224884,62.6881932 L89.3807164,61.1702742 C86.2103299,59.6385304 81.4523901,60.2321429 78.7512966,62.4950512 L69.6842316,70.0912108 C68.6969982,70.9182902 67.3970043,71.7079683 65.972973,72.3860195 C65.450814,57.828347 59.4984737,45.9574271 46.7248907,37.1161254 C45.6127483,36.4326524 43.9592431,38.4195836 44.7777067,39.1109172 C56.0407574,49.2817354 60.1164483,60.3235994 60.1164483,74.5177084 L60.1164483,76.5101184 Z M95.0509461,53.9162538 C96.1764172,53.9162538 97.0887918,53.0084656 97.0887918,51.8886521 C97.0887918,50.7688386 96.1764172,49.8610504 95.0509461,49.8610504 C93.925475,49.8610504 93.0131004,50.7688386 93.0131004,51.8886521 C93.0131004,53.0084656 93.925475,53.9162538 95.0509461,53.9162538 L95.0509461,53.9162538 Z M19.9417759,92 L19.9417759,89.8393536 C19.9417758,87.5932185 21.6918837,85.2820263 23.828826,84.6248277 C23.828826,84.6248277 35.0800582,81.8619915 38.1368268,76.9378159 C38.1368268,76.9378159 46.7248911,83.7447645 46.7248911,83.7447645 C34.7889374,89.6827409 19.9417759,92 19.9417759,92 L19.9417759,92 Z" sketch:type="MSShapeGroup"/></g></g></svg>';
      return rabbitIcon;
    },

    makeTurtle: function makeTurtle() {
      var turtleIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="0 0 75 70" enable-background="new 0 0 95 95" xml:space="preserve"><path d="M87.242,46.239c-5.27,0-9.811,1.512-10.09,1.061c-0.281-0.445,1.796-1.456,3.025-2.802  C69.529,35.867,66.388,23.76,47.223,23.76c-19.398,0-24.78,18.723-35.316,28.476l1.905,1.904c0,0-3.586,1.238-6.277,1.57  c-2.691,0.336-6.951,0.741-6.951,1.348c0,0.531,5.606,0.896,8.407,0.896c2.804,0,7.513-0.338,7.513-0.338s0.337,0.445-2.47,1.342  c-2.804,0.9-3.471,1.686-5.49,4.266c-2.014,2.578-4.215,4.748-4.215,5.713c0,1.09,0.445,1.812,2.014,1.812S9.034,71,10.551,71  c2.909,0,2.909-1.807,3.694-3.152c0.789-1.348,1.362-2.158,2.258-2.943c0.901-0.787,2.02-1.008,3.474-1.568  c1.456-0.564,3.702-1.686,3.702-1.686s3.813,1.461,10.424,1.461c6.617,0,18.836-0.34,24.327-0.34c5.493,0,6.562-2.295,7.906-2.295  c0.672,0,3.981,1.965,3.981,2.748c0,1.117-5.161,4.93-5.161,6.051c0,1.125,1.795,1.965,5.05,1.965c4.653,0,5.205-2.605,6.501-4.207  c1.401-1.734,2.572-3.363,2.572-5.383c0-2.521-5.042-4.818-5.042-4.818s1.011-1.571,3.025-1.571c2.017,0,6.056,0.45,10.428,0.45  c4.373,0,6.727,0.56,6.727-3.589C94.417,47.976,92.514,46.239,87.242,46.239z M89.167,50.5c-0.553,0-1-0.447-1-1s0.447-1,1-1  s1,0.447,1,1S89.72,50.5,89.167,50.5z"/></svg>';
      return turtleIcon;
    },

    makeSnail: function makeSnail() {
      var snailIcon = '<svg style="transform:scaleX(-1.0)" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" version="1.1" x="0px" y="5px" viewBox="0 0 75 75"><g transform="translate(0,-952.36218)"><path style="text-indent:0;text-transform:none;direction:ltr;block-progression:tb;baseline-shift:baseline;color:#000000;enable-background:accumulate;" d="m 63.748703,971.36229 c -5.43917,0.046 -12.9678,1.9026 -17.33056,4.9688 -5.33006,3.7325 -9.84923,9.9737 -12.23149,20.2812 -1.91437,7.74631 -1.56839,15.38211 1.72054,19.75001 5.65023,-0.3712 12.79569,-0.6555 19.30136,-0.4375 -5.52288,-4.5469 -7.39127,-10.3988 -7.25756,-17.56251 -0.0291,-9.4042 7.41348,-15 14.82795,-15 6.96147,0.06 12.98292,5.6893 12.88842,13 -0.0443,5.72511 -4.66524,9.92801 -9.91658,10.00001 -3.86287,-0.055 -8.81178,-2.1402 -8.91553,-7.00003 0.012,-3.41788 2.27613,-6.76628 5.94369,-6.99998 0.52311,-0.01 1.00104,0.4716 1.00104,1 0,0.5284 -0.47793,1.01 -1.00104,1 -2.58389,0.4032 -3.81164,2.1726 -3.94161,4.99998 0.0869,3.54803 4.10317,4.92403 6.91345,5.00003 4.15393,-0.085 7.88782,-3.7511 7.94578,-8.00001 -0.0251,-5.3606 -4.55816,-11 -10.91762,-11 -6.44788,0 -12.88287,4.6227 -12.85715,12.9688 -0.0323,6.38281 1.10231,13.05131 8.54015,17.68741 10.33074,0.4959 17.71944,1.8254 22.77372,2.625 3.622699,-1.5245 6.11839,-4.1742 7.789365,-8 1.71466,-3.9255 2.5026,-9.064 2.5026,-15.25001 0,-13.3656 -12.517635,-24.0313 -27.778925,-24.0312 z m -45.73514,1 c -1.65858,0 -3.00313,1.3431 -3.00313,3 0,1.6569 1.34455,3 3.00313,3 0.59787,0 1.15869,-0.1992 1.62669,-0.5 1.92801,1.5462 3.44429,3.6637 3.409799,5.9375 -0.0532,2.3056 -1.432899,5.3535 -2.09593,10.1875 -0.37363,-0.053 -0.78261,-0.094 -1.18874,-0.094 -0.58486,0.01 -1.18456,0.1249 -1.81439,0.2813 0.087,-2.7692 -0.50124,-4.9363 -1.34515,-7.0625 -0.88646,-2.2334 -2.73222,-4.4208 -5.91241,-7.5 0.18193,-0.3868 0.31283,-0.7944 0.31283,-1.25 0,-1.6569 -1.3445495,-3 -3.0031295,-3 -1.65858,0 -3.00313,1.3431 -3.00313,3 0,1.6569 1.34455,3 3.00313,3 0.46283,0 0.89106,-0.1257 1.28258,-0.3125 3.0970895,3.0036 4.7355995,4.9984 5.4431695,6.7813 0.74291,1.8716 1.40489,3.8601 1.15746,7 -0.16002,0.067 -0.31086,0.1478 -0.46924,0.2187 -0.89952,8.26371 -0.58523,17.83861 2.47133,25.28131 3.12374,7.606 8.840111,13.0022 19.30135,13.0312 l 57.810216,0 c -0.672391,-1.924 -2.13834,-4.398 -4.410841,-6.7188 -2.40769,-2.4191 -5.888875,-4.6967 -9.635035,-6 -8.34215,-1.2926 -22.74908,-3.8874 -46.07925,-2.2187 -2.51776,-0.2143 -4.76029,-1.7063 -6.06882,-3.6563 -3.74447,-5.5541 -3.29333,-13.0509 -5.25548,-19.75001 -0.18057,-0.1675 -0.39608,-0.3318 -0.65693,-0.4687 0.62315,-4.7755 2.09036,-7.7341 2.1585,-10.6875 -0.1,-3.42 -1.90212,-5.6714 -4.19187,-7.5938 0.0934,-0.2898 0.15641,-0.5852 0.15641,-0.9062 0.0525,-1.7066 -1.59672,-2.9573 -3.00312,-2.9998 z" fill="#000000" fill-opacity="1" stroke="none" marker="none" visibility="visible" display="inline" overflow="visible"/></g></svg>';
      return snailIcon;
    },

    makeSprayCanIcon: function makeSprayCanIcon() {
      var sprayCanIcon = '<span><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" style="width:20px;height:12px;" viewBox="0 0 88 88" enable-background="new 0 0 100 100" xml:space="preserve"><path d="M30.292,91.893c-0.277,0-0.552-0.114-0.75-0.338l-2.614-2.956  c-0.366-0.413-0.327-1.046,0.086-1.411c0.414-0.365,1.047-0.327,1.412,0.087l2.614,2.956c0.366,0.413,0.327,1.046-0.086,1.411  C30.764,91.81,30.528,91.893,30.292,91.893z M26.219,85.882c-0.332,0-0.656-0.165-0.847-0.466l-1.656-2.622  c-0.295-0.467-0.155-1.085,0.312-1.38c0.465-0.295,1.084-0.156,1.379,0.312l1.656,2.622c0.295,0.467,0.155,1.085-0.312,1.38  C26.586,85.832,26.402,85.882,26.219,85.882z M10.305,85.543c-0.413,0-0.799-0.257-0.943-0.668L8.17,81.488  c-0.183-0.521,0.091-1.092,0.612-1.275c0.519-0.188,1.092,0.091,1.275,0.611l1.191,3.387c0.183,0.521-0.091,1.092-0.612,1.275  C10.527,85.525,10.415,85.543,10.305,85.543z M84.585,81.594c-0.552,0-1-0.447-1-1v-2.37c0-0.553,0.448-1,1-1s1,0.447,1,1v2.37  C85.585,81.146,85.137,81.594,84.585,81.594z M23.399,79.747c-0.364,0-0.715-0.199-0.892-0.546  c-5.812-11.412-2.957-18.242-0.737-21.298c0.626-0.862,1.326-1.614,2.066-2.26c-0.73-1.527-1.142-3.388-0.999-5.575  c0.398-6.072,3.779-9.768,7.464-11.549c-0.075-0.425-0.104-0.851-0.079-1.273c0.373-6.19,3.492-11.47,9.269-15.692  c0.446-0.325,1.071-0.229,1.397,0.218c0.326,0.445,0.229,1.071-0.217,1.397c-5.273,3.854-8.117,8.631-8.453,14.198  c-0.008,0.129-0.006,0.263,0.004,0.398c0.222-0.067,0.444-0.129,0.665-0.185c3.565-0.885,6.866-0.192,8.028,1.689  c0.469,0.759,0.976,2.358-0.893,4.539c-1.135,1.327-2.825,1.668-4.636,0.935c-1.701-0.688-3.474-2.361-4.438-4.311  c-2.501,1.267-5.737,4.008-6.114,9.766c-0.107,1.637,0.158,3.044,0.651,4.221c2.304-1.447,4.773-1.989,6.625-1.696  c1.512,0.238,2.556,1.021,2.941,2.201c0.958,2.938-0.12,4.43-0.848,5.059c-1.396,1.204-3.763,1.251-6.033,0.122  c-1.153-0.574-2.318-1.482-3.266-2.72c-0.546,0.499-1.059,1.064-1.516,1.693c-3.367,4.637-3.047,11.46,0.901,19.214  c0.25,0.492,0.055,1.095-0.438,1.346C23.707,79.712,23.552,79.747,23.399,79.747z M26.495,56.169  c0.748,0.979,1.662,1.695,2.567,2.146c1.498,0.745,3.075,0.81,3.834,0.153c0.819-0.707,0.51-2.136,0.253-2.925  c-0.18-0.551-0.834-0.764-1.352-0.845C30.364,54.474,28.363,54.982,26.495,56.169z M32.819,39.677  c0.718,1.374,1.986,2.676,3.316,3.213c1.519,0.616,2.158-0.135,2.368-0.381c0.447-0.522,1.134-1.501,0.71-2.188  c-0.581-0.94-2.979-1.512-5.843-0.799C33.215,39.562,33.029,39.611,32.819,39.677z M8.299,77.702c-0.497,0-0.927-0.369-0.991-0.875  L6.76,72.481c-0.069-0.548,0.319-1.048,0.867-1.117c0.546-0.063,1.048,0.318,1.117,0.867l0.548,4.346  c0.069,0.548-0.319,1.048-0.867,1.117C8.383,77.699,8.341,77.702,8.299,77.702z M84.585,75.176c-0.552,0-1-0.447-1-1v-7.112  c0-0.553,0.448-1,1-1s1,0.447,1,1v7.112C85.585,74.729,85.137,75.176,84.585,75.176z M7.632,68.187c-0.552,0-1-0.447-1-1v-4.063  c0-0.553,0.448-1,1-1s1,0.447,1,1v4.063C8.632,67.739,8.185,68.187,7.632,68.187z M84.585,63.322c-0.552,0-1-0.447-1-1V37.405  c0-0.553,0.448-1,1-1s1,0.447,1,1v24.917C85.585,62.875,85.137,63.322,84.585,63.322z M7.658,59.402c-0.009,0-0.018,0-0.027,0  c-0.552-0.016-0.988-0.475-0.973-1.026c0.345-12.844,4.494-18.087,7.337-20.179c0.154-0.413,0.33-0.842,0.53-1.288  c3.832-8.567,13.136-16.174,25.527-20.871c0.517-0.194,1.094,0.064,1.29,0.581s-0.064,1.094-0.581,1.29  c-11.451,4.34-20.123,11.193-23.981,18.909c1.926-0.503,3.74-0.106,4.861,1.103c1.118,1.207,1.284,3.004,0.442,4.807  c-1.462,3.134-4.531,4.828-6.84,3.769c-1.321-0.604-2.312-2.105-2.115-4.675c-2.346,3.048-4.25,8.389-4.471,16.607  C8.643,58.972,8.198,59.402,7.658,59.402z M15.668,39.46c-1.003,3-0.587,4.764,0.406,5.218c1.131,0.513,3.128-0.506,4.196-2.796  c0.5-1.071,0.465-1.995-0.097-2.603c-0.686-0.739-2.026-0.88-3.414-0.357C16.398,39.058,16.033,39.236,15.668,39.46z M44.426,20.661  c-0.358,0-0.705-0.192-0.884-0.531c-0.259-0.487-0.074-1.093,0.414-1.352c1.179-0.627,2.449-1.23,3.774-1.794  c0.51-0.218,1.096,0.021,1.312,0.528c0.216,0.508-0.02,1.096-0.528,1.312c-1.272,0.542-2.49,1.12-3.619,1.72  C44.745,20.624,44.584,20.661,44.426,20.661z M43.329,16.909c-0.403,0-0.784-0.246-0.935-0.646c-0.196-0.517,0.064-1.094,0.581-1.29  c0.439-0.166,0.782-0.279,1.084-0.294c0.085-0.022,0.199-0.055,0.351-0.1c0.527-0.157,1.085,0.147,1.241,0.679  c0.156,0.53-0.148,1.085-0.678,1.241c-0.34,0.1-0.648,0.189-0.925,0.207c-0.085,0.031-0.203,0.076-0.364,0.138  C43.566,16.889,43.447,16.909,43.329,16.909z M55.574,16.296c-0.435,0-0.834-0.285-0.96-0.724c-0.153-0.531,0.154-1.085,0.685-1.237  c0.778-0.224,1.567-0.438,2.365-0.641c0.539-0.138,1.08,0.188,1.216,0.722c0.137,0.535-0.187,1.079-0.722,1.216  c-0.779,0.199-1.548,0.407-2.308,0.625C55.758,16.283,55.665,16.296,55.574,16.296z M48.571,15.53c-0.456,0-0.868-0.313-0.974-0.777  c-0.124-0.538,0.213-1.074,0.751-1.197c1.599-0.366,3.268-0.689,4.961-0.96c0.542-0.093,1.058,0.284,1.146,0.829  c0.087,0.546-0.284,1.059-0.829,1.146c-1.65,0.265-3.276,0.579-4.832,0.935C48.72,15.522,48.645,15.53,48.571,15.53z M61.835,13.657  c-0.522,0-0.962-0.406-0.997-0.935c-0.036-0.552,0.382-1.027,0.933-1.063c0.938-0.061,1.89-0.11,2.857-0.146  c0.543-0.049,1.017,0.409,1.037,0.961c0.021,0.553-0.41,1.017-0.962,1.037c-0.949,0.036-1.883,0.084-2.803,0.145  C61.879,13.656,61.857,13.657,61.835,13.657z M90.627,90.353H60.354c-2.063,0-3.74-1.578-3.74-3.519v-55.19  c0-0.67,0.2-1.297,0.547-1.831c-0.36-0.715-0.547-1.488-0.547-2.153v-1.615c0-1.949,1.587-4.036,3.95-4.036h0.668  c0.846-2.483,2.916-6.444,6.424-6.444h0.961V9.107c0-1.104,0.896-2,2-2h9.747c1.104,0,2,0.896,2,2v6.456h1.303  c3.528,0,5.423,3.941,6.154,6.444h0.243c2.424,0,4.304,2.17,4.304,4.036v1.668c0,0.616-0.217,1.336-0.606,2.014  c0.383,0.552,0.606,1.211,0.606,1.918v55.19C94.368,88.774,92.69,90.353,90.627,90.353z M60.614,86.353h29.753V32.125H60.614V86.353  z M60.795,28.125h29.177c0.135-0.088,0.331-0.344,0.395-0.516v-1.386c-0.081-0.105-0.237-0.216-0.304-0.216h-29.42  c-0.015,0.026-0.027,0.057-0.031,0.077l0.002,1.574C60.624,27.772,60.71,27.991,60.795,28.125z M65.55,22.008h20.043  c-0.534-1.222-1.322-2.444-1.926-2.444h-16.01C67.005,19.563,66.162,20.775,65.55,22.008z M72.618,15.563h5.747v-4.456h-5.747  V15.563z"/>';
      return sprayCanIcon;
    },

    makeSettingsIcon: function makeSettingsIcon(opts) {
      return sticker.makeSimplePath($.extend({}, true, opts, {
        viewBox: [0, 0, 100, 100],
        d: ["M49.71,95c-2.757,0-3.253-2.49-3.871-5.594c-0.733-3.752-2.109-5.723-4.478-6.466    c-0.056-0.018-0.139-0.054-0.214-0.094c-0.562-0.147-1.115-0.307-1.663-0.486c-2.331-0.595-4.53,0.338-7.074,3.036    c-2.354,2.489-4.2,4.437-6.758,2.393l-1.186-0.943c-0.333-0.264-0.585-0.462-2.394-1.91c-0.025-0.018-0.049-0.037-0.073-0.057    c-0.01-0.008-0.02-0.015-0.03-0.023l-2.008-1.615c-0.456-0.368-0.456-0.368-1.456-1.162l-0.12-0.096    c-2.544-2.051-1.06-4.266,0.817-7.071c2.121-3.157,2.54-5.525,1.394-7.735l0.001,0c-0.024-0.048-0.047-0.101-0.066-0.154    c-0.294-0.508-0.566-1.032-0.834-1.552c-1.227-2.076-3.449-2.978-7.166-2.882c-3.442,0.089-6.108,0.155-6.471-3.086l-0.16-1.458    c-0.049-0.451-0.075-0.697-0.345-3.105l0.961-0.217l-0.972,0.109l-0.508-4.569c-0.361-3.253,2.258-3.767,5.575-4.418    c3.736-0.741,5.708-2.121,6.453-4.485c0.015-0.05,0.045-0.118,0.077-0.182c0.133-0.503,0.305-1.122,0.513-1.732    c0.568-2.3-0.366-4.495-3.051-7.035c-2.499-2.37-4.433-4.204-2.394-6.764l2.871-3.585c0.018-0.027,0.046-0.064,0.066-0.089    l2.877-3.583c2.039-2.558,4.261-1.065,7.075,0.827c3.153,2.112,5.524,2.529,7.722,1.38c0.038-0.02,0.087-0.04,0.138-0.058    c0.542-0.31,1.052-0.571,1.571-0.833c2.074-1.219,2.98-3.443,2.882-7.181c-0.09-3.432-0.16-6.087,3.084-6.464l9.241-1.029    c3.239-0.354,3.773,2.269,4.426,5.593c0.725,3.714,2.104,5.686,4.478,6.437c0.056,0.018,0.141,0.056,0.218,0.096    c0.544,0.141,1.092,0.304,1.628,0.473c2.345,0.607,4.551-0.321,7.092-3.028c2.38-2.499,4.214-4.425,6.761-2.394l1.256,1.001    c0.307,0.243,0.642,0.509,2.327,1.858c0.018,0.013,0.035,0.027,0.052,0.042c0.02,0.015,0.038,0.031,0.053,0.043l3.58,2.864    c2.535,2.039,1.069,4.237-0.785,7.021l-0.064,0.096c-2.087,3.111-2.507,5.481-1.361,7.686c0.022,0.042,0.045,0.1,0.065,0.16    c0.26,0.453,0.498,0.918,0.741,1.393l0.021,0.04c0.008,0.012,0.016,0.025,0.023,0.038c1.246,2.152,3.475,3.058,7.215,2.955    c3.451-0.087,6.11-0.156,6.469,3.088l0.506,4.527c0.008,0.041,0.013,0.082,0.016,0.122c0.001,0.011,0.003,0.021,0.004,0.031    l0.134,1.238c0.17,1.562,0.17,1.562,0.235,2.134l0.136,1.196c0,0.002,0,0.004,0,0.006c0.348,3.233-2.248,3.751-5.535,4.407    l-0.1,0.02c-3.676,0.719-5.647,2.096-6.396,4.465c-0.018,0.057-0.06,0.151-0.1,0.229c-0.126,0.489-0.289,1.049-0.469,1.616    c-0.61,2.336,0.321,4.543,3.033,7.107c2.489,2.365,4.424,4.205,2.39,6.755c-0.684,0.853-0.836,1.045-1.038,1.301    c-0.236,0.299-0.541,0.684-1.831,2.297c-0.018,0.023-0.04,0.047-0.062,0.071l-2.883,3.598c-2.032,2.537-4.235,1.07-7.025-0.786    l-0.089-0.059c-3.109-2.091-5.479-2.513-7.687-1.368c-0.039,0.02-0.094,0.043-0.15,0.063c-0.478,0.275-1.001,0.555-1.536,0.818    c-2.089,1.218-3,3.445-2.896,7.188c0.095,3.422,0.169,6.102-3.088,6.466l-1.591,0.182c-0.389,0.046-0.814,0.096-2.977,0.339    c-0.034,0.004-0.069,0.006-0.103,0.006v0c-0.001,0-0.008,0.003-0.041,0.005c-1.837,0.205-2.403,0.266-2.773,0.306    c-0.386,0.042-0.558,0.06-1.752,0.197C50.07,94.99,49.885,95,49.71,95z M42.039,81.104c4,1.332,5.169,5.109,5.704,7.848    c0.741,3.722,1.019,4.213,2.307,4.072c1.195-0.137,1.367-0.155,1.757-0.197c0.372-0.04,0.942-0.102,2.807-0.31    c0.014-0.002,0.028-0.003,0.043-0.004c0.043-0.005,0.093-0.009,0.128-0.009c2.086-0.236,2.511-0.286,2.898-0.331l1.601-0.183    c1.291-0.145,1.455-0.684,1.351-4.438c-0.08-2.851,0.242-6.851,3.927-8.995c0.573-0.285,1.075-0.553,1.569-0.838    c0.056-0.032,0.136-0.066,0.212-0.091c3.785-1.889,7.288-0.046,9.604,1.513l0.085,0.056c3.078,2.049,3.614,2.192,4.415,1.192    l2.875-3.589c0.013-0.016,0.074-0.088,0.088-0.104c0.008-0.009,0.016-0.017,0.024-0.025l0.003-0.003    c1.239-1.552,1.543-1.936,1.778-2.234c0.204-0.258,0.357-0.451,1.045-1.309c0.803-1.006,0.539-1.502-2.173-4.079    c-2.079-1.965-4.673-5.008-3.601-9.104c0.188-0.596,0.345-1.137,0.492-1.692c0.019-0.074,0.066-0.181,0.112-0.267    c1.32-4.013,5.112-5.19,7.86-5.728l0.097-0.019c3.625-0.724,4.11-1.001,3.973-2.277l-0.136-1.191    c-0.066-0.575-0.066-0.575-0.236-2.145l-0.134-1.233c-0.002-0.013-0.003-0.026-0.005-0.039c-0.004-0.024-0.008-0.048-0.011-0.072    l-0.511-4.57c-0.141-1.279-0.675-1.445-4.392-1.349c-2.88,0.083-6.843-0.229-8.992-3.846c-0.029-0.04-0.055-0.082-0.078-0.127    l-0.063-0.123c-0.243-0.475-0.48-0.94-0.744-1.393c-0.036-0.062-0.073-0.151-0.099-0.235c-1.907-3.722-0.053-7.256,1.514-9.59    l0.063-0.094c2.045-3.068,2.19-3.604,1.189-4.409L76.8,16.676c-0.096-0.053-0.175-0.118-0.238-0.192    c-1.56-1.248-1.884-1.505-2.181-1.741l-1.261-1.006c-1.004-0.8-1.499-0.541-4.068,2.157c-3.053,3.252-6.017,4.42-9.104,3.617    c-0.592-0.185-1.151-0.35-1.701-0.49c-0.07-0.018-0.138-0.043-0.203-0.076c-0.019-0.01-0.05-0.028-0.081-0.047    c-4.002-1.32-5.176-5.11-5.712-7.857c-0.73-3.718-1.007-4.21-2.298-4.066l-9.238,1.029c-1.295,0.15-1.447,0.644-1.349,4.399    c0.076,2.885-0.248,6.876-3.9,9.019c-0.584,0.297-1.105,0.564-1.616,0.858c-0.057,0.033-0.136,0.067-0.212,0.093    c-3.699,1.921-7.246,0.064-9.588-1.507c-3.15-2.118-3.691-2.267-4.497-1.257l-2.879,3.586c0.016-0.014-0.011,0.02-0.065,0.088    l-2.87,3.584c-0.806,1.012-0.544,1.507,2.163,4.074c2.071,1.959,4.643,4.975,3.63,9.053c-0.213,0.634-0.373,1.211-0.525,1.786    c-0.019,0.071-0.058,0.165-0.101,0.246c-1.297,3.988-5.099,5.177-7.854,5.724c-3.725,0.731-4.212,1.008-4.07,2.293l0.508,4.568    l0.011,0.108c0.27,2.414,0.297,2.66,0.346,3.111l0.159,1.453c0.143,1.278,0.675,1.441,4.406,1.348    c2.867-0.079,6.849,0.247,8.999,3.893c0.296,0.574,0.57,1.101,0.868,1.609c0.042,0.071,0.074,0.146,0.097,0.225    c1.893,3.754,0.046,7.266-1.514,9.587c-2.112,3.155-2.26,3.697-1.255,4.507l0.114,0.091c1.008,0.8,1.008,0.8,1.468,1.171    l1.993,1.603c0.051,0.033,0.1,0.071,0.144,0.114c1.773,1.419,2.022,1.616,2.352,1.877l1.193,0.949    c1.012,0.809,1.511,0.545,4.099-2.19c1.935-2.052,4.959-4.639,9.06-3.588c0.61,0.198,1.165,0.356,1.729,0.502    c0.057,0.015,0.112,0.034,0.165,0.059C41.954,81.056,41.998,81.08,42.039,81.104z M21.972,84.854c0,0.001,0.002,0.002,0.006,0.005    C21.976,84.858,21.974,84.856,21.972,84.854z M41.9,81.059c0.027,0.008,0.054,0.017,0.08,0.025    C41.956,81.075,41.929,81.066,41.9,81.059z M66.309,77.644c-0.026,0.011-0.054,0.025-0.083,0.043    C66.254,77.673,66.282,77.658,66.309,77.644z M22.277,66.181c0,0,0.001,0.001,0.001,0.002    C22.278,66.182,22.277,66.181,22.277,66.181z M81.071,58.039c-0.004,0.011-0.008,0.024-0.011,0.036    C81.064,58.064,81.068,58.051,81.071,58.039z M92.594,45.606c0,0.001,0,0.001,0.001,0.002    C92.595,45.608,92.595,45.607,92.594,45.606z M92.593,45.605L92.593,45.605L92.593,45.605z M92.502,45.268    c0,0.011,0,0.028,0.003,0.051C92.504,45.301,92.503,45.283,92.502,45.268z M58.046,18.927c0.004,0.001,0.009,0.003,0.013,0.004    C58.055,18.929,58.051,18.928,58.046,18.927z M76.969,16.756C76.969,16.756,76.969,16.756,76.969,16.756    C76.969,16.756,76.969,16.756,76.969,16.756z M76.967,16.755L76.967,16.755L76.967,16.755z M76.965,16.754    C76.965,16.754,76.965,16.755,76.965,16.754C76.965,16.755,76.965,16.754,76.965,16.754z M76.963,16.754    C76.963,16.754,76.963,16.754,76.963,16.754C76.963,16.754,76.963,16.754,76.963,16.754z M76.961,16.753L76.961,16.753    L76.961,16.753z M49.964,65.65c-3.537,0-6.945-1.189-9.747-3.43c-3.266-2.611-5.318-6.337-5.777-10.491    c-0.951-8.579,5.252-16.333,13.827-17.286c4.16-0.464,8.243,0.721,11.506,3.332c3.264,2.612,5.315,6.34,5.777,10.499    c0.462,4.154-0.722,8.24-3.335,11.504s-6.339,5.315-10.492,5.774C51.134,65.617,50.547,65.65,49.964,65.65z M50.025,36.301    c-0.512,0-1.026,0.029-1.543,0.086c-7.503,0.834-12.93,7.62-12.098,15.126c0.402,3.634,2.197,6.893,5.054,9.178    c2.857,2.284,6.433,3.32,10.069,2.916c0,0,0,0,0,0c3.633-0.401,6.893-2.195,9.179-5.051c2.287-2.857,3.323-6.432,2.919-10.066    c-0.405-3.639-2.2-6.902-5.055-9.188C56.099,37.342,53.119,36.301,50.025,36.301z"],
        fill: opts.color
      }));
    },

    makeNoEntryIcon: function makeNoEntryIcon(fill) {
      var noEntryIcon = '<svg xmlns="http://www.w3.org/2000/svg" data-name="Layer 1" viewBox="0 0 100 100" x="0px" y="0px"><g fill-rule="evenodd" fill="' + fill + '"><path data-name="Compound Path" d="M50,89.11A39.11,39.11,0,1,0,22.33,77.66,39,39,0,0,0,50,89.11ZM72,72a31.17,31.17,0,0,1-41.28,2.42l43.71-43.7A31.17,31.17,0,0,1,72,72ZM28,28a31.16,31.16,0,0,1,40.72-2.86L25.14,68.71A31.17,31.17,0,0,1,28,28Z"/></g></svg>';
      return noEntryIcon;
    },

    makeTrashIcon: function makeTrashIcon(fill) {
      var trashIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 26" version="1.1" x="0px" y="0px"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g transform="scale(1.2 1.2) translate(-2 0)"><rect x="0" y="0" width="24" height="24"/><path d="M5,6 L5.73274082,20.8571429 C5.73274082,20.8571429 5.99625939,22 6.98958614,22 L11.598019,22 L12.4359159,22 L17.0443487,22 C18.0380944,22 18.301613,20.8571429 18.301613,20.8571429 L19,6 L5,6 Z M15.5,8 L15.5,8 L15.5,8 C15.2205531,8 14.9908183,8.22036187 14.9791847,8.49956654 L14.5208153,19.5004335 L14.5208153,19.5004335 C14.5097883,19.7650799 14.7153876,19.9885573 14.980034,19.9995842 C14.9866857,19.9998614 14.9933425,20 15,20 L15,20 L15,20 C15.2794469,20 15.5091817,19.7796381 15.5208153,19.5004335 L15.9791847,8.49956654 L15.9791847,8.49956654 C15.9902117,8.23492012 15.7846124,8.01144271 15.519966,8.00041578 C15.5133143,8.00013862 15.5066575,8 15.5,8 Z M9.47918818,19.5003499 L9.02097843,8.49965006 L9.02097843,8.49965006 C9.00934688,8.22039979 8.77957571,8 8.50008331,8 L8.50008331,8 L8.50008331,8 C8.23515945,8 8.02039624,8.21476322 8.02039624,8.47968707 C8.02039624,8.48634356 8.02053479,8.49299933 8.02081182,8.49965006 L8.47902157,19.5003499 L8.47902157,19.5003499 C8.49065312,19.7796002 8.72042429,20 8.99991669,20 L8.99991669,20 L8.99991669,20 C9.26484055,20 9.47960376,19.7852368 9.47960376,19.5203129 C9.47960376,19.5136564 9.47946521,19.5070007 9.47918818,19.5003499 Z M8.00719509,3 L5.11111111,3 L5.11111111,3 C4.49746139,3 4,3.49746139 4,4.11111111 L4,4.11111111 L4,5 L20,5 L20,4.11111111 C20,3.49746139 19.5025386,3 18.8888889,3 L15.9926121,3 C15.9368649,2.4385197 15.4631369,2 14.8869871,2 L9.11301289,2 C8.99358834,2 8.87494478,2.0192532 8.76164871,2.05701856 C8.33332638,2.19979267 8.04982846,2.57814658 8.00719509,3 Z M12,8 C12.2761424,8 12.5,8.22385763 12.5,8.5 L12.5,19.5 C12.5,19.7761424 12.2761424,20 12,20 C11.7238576,20 11.5,19.7761424 11.5,19.5 L11.5,8.5 C11.5,8.22385763 11.7238576,8 12,8 Z" fill="#000000"/></g></g></svg>';
      return trashIcon;
    },

    makeCompressTimeIcon: function makeCompressTimeIcon(fill) {
      var compressTimeIcon = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" x="0px" y="0px" viewBox="-434 236 90 80" style="enable-background:new -434 236 90 90;" xml:space="preserve"><g fill-rule="evenodd" fill="' + fill + '"><path d="M-354.9,251.1h-5.3h-2.6v2.6v27.8c-0.1-0.3-0.3-0.5-0.5-0.8l-29.1-29.1c-0.5-0.5-1-0.7-1.3-0.5c-0.4,0.2-0.5,0.6-0.5,1.3   v29.1c-0.1-0.3-0.3-0.5-0.5-0.8l-29.1-29.1c-0.5-0.5-1-0.7-1.3-0.5c-0.4,0.2-0.5,0.6-0.5,1.3v60.4c0,0.7,0.2,1.1,0.5,1.3   c0.4,0.2,0.8,0,1.3-0.5l29.1-29.1c0.2-0.2,0.4-0.5,0.5-0.8v29.1c0,0.7,0.2,1.1,0.5,1.3c0.4,0.2,0.8,0,1.3-0.5l29.1-29.1   c0.2-0.2,0.4-0.5,0.5-0.8v27.8v2.6h2.6h5.3h2.6v-2.6v-57.8v-2.6H-354.9z"/></g></svg>';
      return compressTimeIcon;
    },

    makeSmallUdacityIcon: function makeSmallUdacityIcon(opts) {
      var udacityHtml = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="Layer_1" x="0px" y="0px" width="' + opts.width + 'px" height="' + opts.height + 'px" viewBox="0 0 32 32" ' + 'enable-background="new 0 0 32 32">' + '<image x="0" y="0" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAABGdBTUEAALGPC/xhBQAAACBjSFJN AAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAABOFBMVEUAs+YAsuYKvOkSveo1 xezR8vv6/v6I3PQowuu+7Pn///+V4PUCu+my6Pgdv+u66/ln0/Hv+v31/P531/P9/v8At+j3/f7a 9PxLy+/+//8twuzM8Pv8/v9t1fLt+v3u+v1v1fIAtOeY4fXg9vxKy+6S3/UAuOgAtecAs+f2/P4g v+ut5/d21/NXzvCg4/ZWzvDi9/zT8vs9yO3l+PwAuenc9fuX4fWG3PPC7frD7fpHyu4zxez7/v84 xu3s+f0MvOp42POo5fdUzu/U8vxZz/CR3/Wr5vfS8vvn+P0rw+wPvOokwOv5/f606fgAuunX8/xr 1PLQ8ftSze8AtugnwuuU4PUEu+nW8/yJ3PQYv+qQ3/TP8fuq5vfh9vzB7fq/7Pn0/P5w1fI3xu2s 5/fm+PyN3vQ5x+0xxOwxFuTVAAAAAWJLR0QKaND0VgAAAAlwSFlzAAAWJQAAFiUBSVIk8AAAAAd0 SU1FB+IKHAUqGL3rdjoAAAFBSURBVDjL5dPZUsIwFAbgBMTqj6BiF0FcsGLdEaniUtwVVMR93/f3 fwPbkpS0Os5wbW7Sk/NN0ov/EEL/XIQ0AUgo0Az7QUukVRLbbe2ICqAjBns12vHOes0A6epGokf2 gCKp0HqTHkj1AbEQTXPQP4DBoQz1wLAMfcQ+9wCQHbU3DwCSQf3ArQUwRv8RUINgPAB0TIhAgRYA k5gSwTRmGEgj457nMOt+EBeQPOYYKMCsR2oeC85uwn6cFrHIE7WE5frVKxaydl1CnpJicnWNg3Vs sN/ftLC1bexgN1dGZc8L7b4lHzBR0oGq5aTtsCakOoojhQnj+MRpF059sT8rIxLmeTyvQL7gnof2 8grq9Y07C7dV3KV+Do5yb9/78PikAc8v4rA1Buf1LeE8/v5h+qZLHD0j/vlVo4HV1PD+Dr4BCLwn yyZy1tMAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMTAtMjhUMTI6NDI6MjQtMDc6MDC16UJJAAAA JXRFWHRkYXRlOm1vZGlmeQAyMDE4LTEwLTI4VDEyOjQyOjI0LTA3OjAwxLT69QAAAABJRU5ErkJg gg==" width="32" height="32"></image>' + '</svg>';
      return udacityHtml;
    },

    makeLabelHtml: function makeLabelHtml(opts) {
      var dimensions = opts.dimensions;

      var labelAttr = {
        style: 'width:' + dimensions.width + 'px;' + 'height:' + dimensions.height + 'px;' + 'left:' + dimensions.x + 'px;' + 'top:' + dimensions.y + 'px;' + 'opacity:' + opts.opacity + ';color:' + opts.color + ';padding-top:10px;'
      };

      var labelHtml = '<div class="graffiti-sticker-inner">' + sticker.makeElementHtml('div', labelAttr, '<div>' + opts.label + '</div>') + '</div>';
      return labelHtml;
    },

    // create label with SVG. legacy code in case i ever need it but now using the above fn makeLabelHtml since more efficient.
    makeLabelSvg: function makeLabelSvg(opts) {
      var dimensions = opts.dimensions;
      var buffer = opts.buffer || 4;
      var viewBoxRaw = '0 0 ' + dimensions.width + ' ' + dimensions.height;
      var viewBox = sticker.makeBufferedViewBox({ buffer: buffer, bufferAllSides: true, viewBox: viewBoxRaw });
      var shapeObj = { x: 0,
        y: 16,
        text: opts.label,
        "font-size": 18,
        width: dimensions.width,
        height: dimensions.height,
        stroke: opts.color,
        fill: opts.color,
        dashed: opts.dashed,
        "stroke-width": opts.strokeWidth,
        "fill-opacity": opts.fillOpacity
      };
      sticker.interpretDashing(opts, shapeObj);
      var theLabel = sticker.makeSvgElement('text', shapeObj);
      var parmBlock = {
        el: theLabel,
        x: dimensions.x,
        y: dimensions.y,
        width: dimensions.width,
        height: dimensions.height,
        viewBox: viewBox
      };

      var renderedSvg = sticker.renderSvg([parmBlock]);
      return renderedSvg;
    },

    makeCustom: function makeCustom(opts) {
      var dimensions = opts.dimensions;
      var customHtml = '<img src="' + opts.imageUrl + '" style="width:' + dimensions.width + 'px;height:' + dimensions.height + 'px;' + 'top:' + dimensions.y + 'px;left:' + dimensions.x + 'px;opacity:1.0;';
      if (opts.cssTransform !== undefined) {
        customHtml += 'transform:' + opts.cssTransform;
      }
      customHtml += '">';

      return customHtml;
    }

  };

  sticker.minBracketWidth = 6;
  return sticker;
});


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

define('js/localizer.js',['./state.js'], function (state) {
  var localizer = {
    defaultLanguage: 'EN',
    language: 'EN',

    getLanguage: function getLanguage() {
      return localizer.language;
    },

    setLanguage: function setLanguage(language) {
      if (language !== undefined) {
        localizer.language = language;
      } else {
        localizer.language = localizer.defaultLanguage;
      }
    },

    getString: function getString(token) {
      if (localizer.translations.hasOwnProperty(localizer.language)) {
        if (localizer.translations[localizer.language].hasOwnProperty(token)) {
          if (localizer.translations[localizer.language][token].length > 0) {
            // console.log('localized, for ' + token + ' returning ' , localizer.translations[localizer.language][token]);
            return localizer.translations[localizer.language][token];
          } else {
            // console.log('unlocalized, for ' + token + ' returning ' , localizer.translations[localizer.defaultLanguage][token]);
            return localizer.translations[localizer.defaultLanguage][token];
          }
        }
      }
      // Cant find the string, just return the token so it's obvious it needs translation
      return token;
    },

    loadLocale: function loadLocale(locale) {
      var _localizer$translatio, _localizer$translatio2;

      switch (locale) {
        case 'EN':
          localizer.translations['EN'] = (_localizer$translatio = {
            'ENABLE_GRAFFITI': 'Enable Graffiti',
            'ACTIVATE_GRAFFITI': 'Activate Graffiti',
            'GRAFFITI_PRESENT': 'Graffiti is present on this line to the left.',
            'MOVIE_UNAVAILABLE': 'Movie is not available.',
            'MOVIE_UNAVAILABLE_EXPLANATION': 'We are sorry, we could not load this movie at this time. Please contact the author of this Notebook for help.',
            'ACTIVATE_GRAFFITI_CONFIRM': 'Activate Graffiti On This Notebook?',
            'CREATE_1': 'Create',
            'CREATE_2': 'Record',
            'EDIT': 'Edit',
            'EDIT_TOOLTIP': 'Edit Tooltip / Graffiti Settings',
            'START_RECORDING': 'Start Recording',
            'END_RECORDING': 'End Recording',
            'RECORD': 'Record',
            'RECORD_MOVIE': 'Record movie',
            'RERECORD': 'Rerecord',
            'RERECORD_MOVIE': 'Rerecord movie',
            'START_PLAYBACK': 'Start playback',
            'PAUSE_PLAYBACK': 'Pause playback',
            'MUTE': 'Mute',
            'UNMUTE': 'Unmute',
            'HIGH_SPEED_PLAYBACK': 'Switch to High speed playback',
            'REGULAR_SPEED_PLAYBACK': 'Switch to Regular speed playback',
            'HIGH_SPEED_SILENCES': 'High Speed during silences',
            'REGULAR_SPEED_SILENCES': 'Regular Speed during silences',
            'SKIP_BACK': 'Skip back',
            'SKIP_FORWARD': 'Skip forward',
            'TO_PREVIOUS_SENTENCE': 'to previous sentence',
            'TO_NEXT_SENTENCE': 'to next sentence',
            'SECONDS': 'seconds',
            'SAVE_GRAFFITI': 'Save Graffiti',
            'REMOVE_GRAFFITI': 'Remove Graffiti',
            'BELOW_TYPE_MARKDOWN': "%% Below, type any markdown to display in the Graffiti tip.\n" + "%% Then run this cell to save it.\n",
            'SAMPLE_API': 'Create Sample API Calls',
            'SKIPS_API': 'Fast Forwards / Skips',
            'SKIPS_DIALOG_TITLE': 'Remove Fast Forwards & Skips on This Recording?',
            'SKIPS_DIALOG_BODY': 'This will remove all fast forwards and skips you have set. Are you positive?',
            'SKIPS_DIALOG_CONFIRM_1': 'Proceed',
            'SKIPS_DIALOG_CANCEL': 'Cancel',
            'SKIPS_HEADER': 'Fast Forwards & Skips',
            'SKIPS_COMPRESS_BTN': 'Compress time to fixed length',
            'SKIPS_2X_BTN': 'Set to fast forward at 2x speed',
            'SKIPS_3X_BTN': 'Set to fast forward at 3x speed',
            'SKIPS_4X_BTN': 'Set to fast forward at 4x speed'
          }, _defineProperty(_localizer$translatio, 'SKIPS_COMPRESS_BTN', 'Compress time to fixed length'), _defineProperty(_localizer$translatio, 'SKIPS_ABSOLUTE_BTN', 'Skip a section entirely'), _defineProperty(_localizer$translatio, 'SKIPS_CLEAR_BTN', 'Remove all skips'), _defineProperty(_localizer$translatio, 'TAKES', 'Takes'), _defineProperty(_localizer$translatio, 'SELECT_SOME_TEXT_MARKDOWN', 'Select some text in this Markdown cell to add or modify Graffiti, or click inside any existing Graffiti text to modify it.'), _defineProperty(_localizer$translatio, 'EDIT_IN_MARKDOWN_CELL', 'Edit the Markdown cell to add or modify Graffiti in the cell, or use Graffiti Extras (below)'), _defineProperty(_localizer$translatio, 'SELECT_SOME_TEXT_PLAIN', 'Select some text in a cell to create or modify Graffiti, click inside any existing Graffiti text to modify that Graffiti, ' + 'or use Graffiti Extras (below)'), _defineProperty(_localizer$translatio, 'YOU_CAN_PLAY_VIA_TOOLTIP', 'You can play this movie any time via its tooltip.'), _defineProperty(_localizer$translatio, 'NO_MOVIE_RECORDED_YET', 'No movie has been recorded for this Graffiti yet.'), _defineProperty(_localizer$translatio, 'PLEASE_WAIT_STORING_MOVIE', 'Please wait, storing this movie...'), _defineProperty(_localizer$translatio, 'YOU_CAN_FILTER', 'You can filter this Notebook\'s Graffiti by clicking on creators in the list below.'), _defineProperty(_localizer$translatio, 'PAUSE_TO_INTERACT', '<span class="graffiti-notifier-link" id="graffiti-pause-link">Pause</span> (or scroll the page) to interact with this Notebook'), _defineProperty(_localizer$translatio, 'CANCEL_MOVIE_PLAYBACK_1', '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-link">Cancel</span> movie playback (Esc)'), _defineProperty(_localizer$translatio, 'CANCEL_MOVIE_PLAYBACK_2', '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-postreset-link">Cancel</span> movie playback (Esc)'), _defineProperty(_localizer$translatio, 'CANCEL_MOVIE_PLAYBACK_3', '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-prereset-link">Cancel</span> movie playback (Esc)'), _defineProperty(_localizer$translatio, 'PLAY_MOVIE_AGAIN', '<span class="graffiti-notifier-link" id="graffiti-restart-play-link">Play movie again</span>'), _defineProperty(_localizer$translatio, 'CONTINUE_MOVIE_PLAYBACK', '<span class="graffiti-notifier-link" id="graffiti-continue-play-link">Continue</span> movie playback'), _defineProperty(_localizer$translatio, 'ENTER_AND_SAVE', 'Enter the markdown you want to be displayed in the Graffiti and then click "Save Graffiti"  (or just run the label cell).'), _defineProperty(_localizer$translatio, 'CANCEL_CHANGES_1', 'Or, <span class="graffiti-notifier-link" id="graffiti-cancel-graffiting-link">Cancel changes</span>'), _defineProperty(_localizer$translatio, 'CANCEL_CHANGES_2', 'Or, <span class="graffiti-notifier-link" id="graffiti-cancel-recording-labelling-link">Cancel changes</span>'), _defineProperty(_localizer$translatio, 'ENTER_MARKDOWN_MOVIE_DESCRIPTION', 'Enter markdown to describe your movie, then click "Start Recording" (or just run the label cell).'), _defineProperty(_localizer$translatio, 'CLICK_BEGIN_MOVIE_RECORDING', 'Click anywhere in the notebook to begin recording your movie.'), _defineProperty(_localizer$translatio, 'CANCEL_RECORDING_1', 'Or, <span class="graffiti-notifier-link" id="graffiti-cancel-recording-pending-link">Cancel recording</span>'), _defineProperty(_localizer$translatio, 'CANCEL_RECORDING_2', 'Or, <span class="graffiti-notifier-link" id="graffiti-cancel-recording-link">Cancel recording</span>'), _defineProperty(_localizer$translatio, 'RECORDING_HINT_1', 'Cmd-m ends recording.'), _defineProperty(_localizer$translatio, 'RECORDING_HINT_2', 'Cmd-m ends recording.'), _defineProperty(_localizer$translatio, 'ACTIVITIES_BEING_RECORDED', 'Your activities are being recorded.' + 'Press ⌘-M or click <span class="graffiti-notifier-link" id="graffiti-end-recording-link">End Recording</span> ' + 'to end recording.'), _defineProperty(_localizer$translatio, 'LOADING', 'Loading...'), _defineProperty(_localizer$translatio, 'LOADING_PLEASE_WAIT', 'Loading Graffiti movie, please wait...'), _defineProperty(_localizer$translatio, 'RECORDED_ON', 'Recorded'), _defineProperty(_localizer$translatio, 'PRESS_ESC_TO_END_MOVIE_PLAYBACK', 'Press ESC to end movie playback'), _defineProperty(_localizer$translatio, 'SHOW_GRAFFITI_EDITOR', 'Show Graffiti Editor'), _defineProperty(_localizer$translatio, 'HIDE_GRAFFITI_EDITOR', 'Hide Graffiti Editor'), _defineProperty(_localizer$translatio, 'ENTER_LABEL', 'Enter a label...'), _defineProperty(_localizer$translatio, 'FREEFORM_PEN_TOOL', 'Freeform pen tool'), _defineProperty(_localizer$translatio, 'HIGHLIGHTER_TOOL', 'Highlighter tool'), _defineProperty(_localizer$translatio, 'ERASER_TOOL', 'Eraser tool'), _defineProperty(_localizer$translatio, 'USE_DISAPPEARING_INK', 'Use disappearing ink'), _defineProperty(_localizer$translatio, 'USE_DASHED_LINES', 'Use dashed lines'), _defineProperty(_localizer$translatio, 'DASHED_LINES', 'Dashed lines'), _defineProperty(_localizer$translatio, 'TEMPORARY_INK', 'Temporary Ink'), _defineProperty(_localizer$translatio, 'SOLID_FILL', 'Solid Fill'), _defineProperty(_localizer$translatio, 'SHIFT_KEY_ALIGN', 'Shift-key: align items to grid / keep items square'), _defineProperty(_localizer$translatio, 'PLAY_CONFIRM', 'Are you sure you want to play this Graffiti?'), _defineProperty(_localizer$translatio, 'REPLACE_CONFIRM_BODY_1', 'This Graffiti movie may replace the contents of code cells. After this movie plays, do you want to...'), _defineProperty(_localizer$translatio, 'REPLACE_CONFIRM_BODY_2', 'Restore Cell Contents After Playback Ends'), _defineProperty(_localizer$translatio, 'REPLACE_CONFIRM_BODY_3', 'Let this Movie Permanently Set Cell Contents'), _defineProperty(_localizer$translatio, 'ACCESS_MICROPHONE_PROMPT', 'Please grant access to your browser\'s microphone.'), _defineProperty(_localizer$translatio, 'ACCESS_MICROPHONE_ADVISORY', 'You cannot record Graffiti movies unless you grant access to the microphone. ' + 'Please <a href="https://help.aircall.io/hc/en-gb/articles/115001425325-How-to-allow-Google-Chrome-to-access-your-microphone" ' + 'target="_">grant access</a> and then reload this page.'), _defineProperty(_localizer$translatio, 'ACTIVATE_GRAFFITI_ADVISORY', 'Enable Graffiti on this Notebook, so you can begin using Graffiti for the first time?<br>' + 'If you click Cancel, we will not change the notebook in any way.' + '<br><br><i>(This process merely adds some metadata to the cells, but does not otherwise change the Notebook\'s contents.)</i>'), _defineProperty(_localizer$translatio, 'SCRUB', 'scrub'), _defineProperty(_localizer$translatio, 'TOOLTIP_HINT', 'Without moving your mouse, click now to watch a movie about this.'), _defineProperty(_localizer$translatio, 'MOVIE_DURATION', 'Movie duration'), _defineProperty(_localizer$translatio, 'INSERT_GRAFFITI_BUTTON_CELL', '+ Insert Graffiti Button'), _defineProperty(_localizer$translatio, 'INSERT_GRAFFITI_BUTTON_CELL_ALT_TAG', 'Insert a Graffiti-enabled button'), _defineProperty(_localizer$translatio, 'INSERT_GRAFFITI_TERMINAL', '+ Insert Graffiti Terminal'), _defineProperty(_localizer$translatio, 'INSERT_GRAFFITI_TERMINAL_ALT_TAG', 'Insert a Graffiti-enabled terminal'), _defineProperty(_localizer$translatio, 'INSERT_GRAFFITI_TERMINAL_SUITE', '+ Insert Terminal Suite'), _defineProperty(_localizer$translatio, 'INSERT_GRAFFITI_TERMINAL_SUITE_ALT_TAG', 'Insert a code cell + terminal + button'), _defineProperty(_localizer$translatio, 'INSERT_TERMINAL_SUITE_STATUS', 'Inserting a terminal suite, please wait...'), _defineProperty(_localizer$translatio, 'CELL_EXECUTES_GRAFFITI', 'Code Cell, Executes Graffiti'), _defineProperty(_localizer$translatio, 'CELL_EXECUTE_CHOICE', 'Now click on the element that contains the Graffiti you want this cell to run...'), _defineProperty(_localizer$translatio, 'CELL_EXECUTE_CHOICE_SET', 'Your choice has been saved.'), _defineProperty(_localizer$translatio, 'ACTIVATE_LOCK_ALT_TAG', 'Lock/unlock markdown cells'), _defineProperty(_localizer$translatio, 'LOCK_VERB', 'Lock'), _defineProperty(_localizer$translatio, 'UNLOCK_VERB', 'Unlock'), _defineProperty(_localizer$translatio, 'UNLOCK_BODY', 'This will unlock all markdown cells so you can edit them (note: terminal cells are always locked).'), _defineProperty(_localizer$translatio, 'LOCK_BODY', 'This will lock all markdown cells so they can no longer be edited.'), _defineProperty(_localizer$translatio, 'LOCK_CONFIRM', 'markdown cells in notebook?'), _localizer$translatio);
          break;
        case 'CN':
          localizer.translations['CN'] = (_localizer$translatio2 = {
            'ENABLE_GRAFFITI': '启用 Graffiti',
            'ACTIVATE_GRAFFITI': '开始使用 Graffiti ',
            'GRAFFITI_PRESENT': '本行有 Graffiti ，请查阅',
            'MOVIE_UNAVAILABLE': '视频不存在',
            'MOVIE_UNAVAILABLE_EXPLANATION': '抱歉，我们目前无法加载该视频。请联系创建该 Notebook 的作者寻求帮助。',
            'ACTIVATE_GRAFFITI_CONFIRM': '是否在该 Notebook 上启用 Graffiti？',
            'CREATE_1': '创建',
            'CREATE_2': '创建',
            'EDIT': '编辑',
            'EDIT_TOOLTIP': '编辑 Graffiti 提示框',
            'START_RECORDING': '开始录屏',
            'END_RECORDING': '结束录屏',
            'RECORD': '录屏',
            'RECORD_MOVIE': '录制视频',
            'RERECORD': '重录',
            'RERECORD_MOVIE': '重新录制',
            'START_PLAYBACK': '开始回放',
            'PAUSE_PLAYBACK': '终止回放',
            'MUTE': '静音',
            'UNMUTE': '取消静音',
            'HIGH_SPEED_PLAYBACK': '快速回放',
            'REGULAR_SPEED_PLAYBACK': '正常回放',
            'HIGH_SPEED_SILENCES': '无人说话的片段快速播放',
            'REGULAR_SPEED_SILENCES': '无人说话的片段正常播放',
            'SKIP_BACK': '快退',
            'SKIP_FORWARD': '快进',
            'TO_PREVIOUS_SENTENCE': '到前一句',
            'TO_NEXT_SENTENCE': '到下一句',
            'SECONDS': '秒',
            'SAVE_GRAFFITI': '保留 Graffiti ',
            'REMOVE_GRAFFITI': '移除 Graffiti ',
            'BELOW_TYPE_MARKDOWN': '在以下输入 markdown 文本，将展示在 Graffiti 中。' + '然后运行文本以保存。',
            'SAMPLE_API': '创建示例 API Calls',
            'SKIPS_API': 'Fast Forwards / Skips',
            'SKIPS_DIALOG_TITLE': 'Remove Fast Forwards & Skips on This Recording?',
            'SKIPS_DIALOG_BODY': 'This will remove all fast forwards and skips you have set. Are you positive?',
            'SKIPS_DIALOG_CONFIRM_1': 'Proceed',
            'SKIPS_DIALOG_CANCEL': 'Cancel',
            'SKIPS_HEADER': 'Fast Forwards & Skips',
            'SKIPS_COMPRESS_BTN': 'Compress time to fixed length',
            'SKIPS_2X_BTN': 'Set to fast forward at 2x speed',
            'SKIPS_3X_BTN': 'Set to fast forward at 3x speed',
            'SKIPS_4X_BTN': 'Set to fast forward at 4x speed'
          }, _defineProperty(_localizer$translatio2, 'SKIPS_COMPRESS_BTN', 'Compress time to fixed length'), _defineProperty(_localizer$translatio2, 'SKIPS_ABSOLUTE_BTN', 'Skip a section entirely'), _defineProperty(_localizer$translatio2, 'SKIPS_CLEAR_BTN', 'Remove all skips'), _defineProperty(_localizer$translatio2, 'TAKES', '版本'), _defineProperty(_localizer$translatio2, 'SELECT_SOME_TEXT_MARKDOWN', '选择文本以创建或者修改 Graffiti，或者点击已有的 Graffiti 进行修改'), _defineProperty(_localizer$translatio2, 'EDIT_IN_MARKDOWN_CELL', 'Edit the Markdown cell to add or modify Graffiti in the cell, or use Graffiti Extras (below)'), _defineProperty(_localizer$translatio2, 'SELECT_SOME_TEXT_PLAIN', 'Select some text in a cell to create or modify Graffiti, click inside any existing Graffiti text to modify that Graffiti, ' + 'or use Graffiti Extras (below)'), _defineProperty(_localizer$translatio2, 'YOU_CAN_PLAY_VIA_TOOLTIP', '你可以通过提示框随时播放此视频'), _defineProperty(_localizer$translatio2, 'NO_MOVIE_RECORDED_YET', 'No movie has been recorded for this Graffiti yet.'), _defineProperty(_localizer$translatio2, 'PLEASE_WAIT_STORING_MOVIE', '稍等，视频存储中...'), _defineProperty(_localizer$translatio2, 'YOU_CAN_FILTER', '点击列表里的创建者，筛选 Notebook 里的 Graffiti'), _defineProperty(_localizer$translatio2, 'PAUSE_TO_INTERACT', '<span class="graffiti-notifier-link" id="graffiti-pause-link">暂停</span>（或者下拉页面），可以继续在 Notebook 上的操作'), _defineProperty(_localizer$translatio2, 'CANCEL_MOVIE_PLAYBACK_1', '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-link">取消</span>视频回放（或者使用 Esc 按键）'), _defineProperty(_localizer$translatio2, 'CANCEL_MOVIE_PLAYBACK_2', '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-postreset-link">取消</span>视频回放（或者使用 Esc 按键）'), _defineProperty(_localizer$translatio2, 'CANCEL_MOVIE_PLAYBACK_3', '<span class="graffiti-notifier-link" id="graffiti-cancel-playback-prereset-link">取消</span>视频回放（或者使用 Esc 按键）'), _defineProperty(_localizer$translatio2, 'PLAY_MOVIE_AGAIN', '<span class="graffiti-notifier-link" id="graffiti-restart-play-link">重新播放视频</span>'), _defineProperty(_localizer$translatio2, 'CONTINUE_MOVIE_PLAYBACK', '<span class="graffiti-notifier-link" id="graffiti-continue-play-link">继续</span>回放视频'), _defineProperty(_localizer$translatio2, 'ENTER_AND_SAVE', '输入你想在 Graffiti 里展示的文本内容，完成后点击“保存 Graffiti”（或者运行单元格以保存）'), _defineProperty(_localizer$translatio2, 'CANCEL_CHANGES_1', '或者<span class="graffiti-notifier-link" id="graffiti-cancel-graffiting-link">取消更改</span>'), _defineProperty(_localizer$translatio2, 'CANCEL_CHANGES_2', '或者<span class="graffiti-notifier-link" id="graffiti-cancel-recording-labelling-link">取消更改</span>'), _defineProperty(_localizer$translatio2, 'ENTER_MARKDOWN_MOVIE_DESCRIPTION', '输入视频描述文字，点击“开始录屏”（或者运行单元格以开始）'), _defineProperty(_localizer$translatio2, 'CLICK_BEGIN_MOVIE_RECORDING', '点击 Notebook 的任何一处，开始录屏'), _defineProperty(_localizer$translatio2, 'CANCEL_RECORDING_1', '或者<span class="graffiti-notifier-link" id="graffiti-cancel-recording-pending-link">取消录制</span>'), _defineProperty(_localizer$translatio2, 'CANCEL_RECORDING_2', '或者<span class="graffiti-notifier-link" id="graffiti-cancel-recording-link">取消录制</span>'), _defineProperty(_localizer$translatio2, 'RECORDING_HINT_1', 'Cmd-m ends recording.'), _defineProperty(_localizer$translatio2, 'RECORDING_HINT_2', 'Cmd-m ends recording.'), _defineProperty(_localizer$translatio2, 'ACTIVITIES_BEING_RECORDED', '录屏进行中' + '按键 ⌘-M 或者点击<span class="graffiti-notifier-link" id="graffiti-end-recording-link">结束录屏</span> ' + '以终止录制'), _defineProperty(_localizer$translatio2, 'LOADING', '加载中'), _defineProperty(_localizer$translatio2, 'LOADING_PLEASE_WAIT', '正在加载 Graffiti 视频，请稍等...'), _defineProperty(_localizer$translatio2, 'RECORDED_ON', '已录制'), _defineProperty(_localizer$translatio2, 'PRESS_ESC_TO_END_MOVIE_PLAYBACK', '按键 ESC 结束视频回放'), _defineProperty(_localizer$translatio2, 'SHOW_GRAFFITI_EDITOR', '显示 Graffiti 编辑器'), _defineProperty(_localizer$translatio2, 'HIDE_GRAFFITI_EDITOR', '隐藏 Graffiti 编辑器'), _defineProperty(_localizer$translatio2, 'ENTER_LABEL', '创建标签'), _defineProperty(_localizer$translatio2, 'FREEFORM_PEN_TOOL', '自由图形画笔'), _defineProperty(_localizer$translatio2, 'HIGHLIGHTER_TOOL', '高亮工具'), _defineProperty(_localizer$translatio2, 'ERASER_TOOL', '橡皮擦'), _defineProperty(_localizer$translatio2, 'USE_DISAPPEARING_INK', '使用渐消墨水'), _defineProperty(_localizer$translatio2, 'USE_DASHED_LINES', '使用虚线'), _defineProperty(_localizer$translatio2, 'DASHED_LINES', '虚线'), _defineProperty(_localizer$translatio2, 'TEMPORARY_INK', '渐消墨水'), _defineProperty(_localizer$translatio2, 'SOLID_FILL', '填充图形'), _defineProperty(_localizer$translatio2, 'SHIFT_KEY_ALIGN', '按住 Shift 键，图形自动对齐'), _defineProperty(_localizer$translatio2, 'PLAY_CONFIRM', '是否确认播放该 Graffiti 视频？'), _defineProperty(_localizer$translatio2, 'REPLACE_CONFIRM_BODY_1', '播放 Graffiti 视频可能会更改代码单元格内容，你可以选择在播放后'), _defineProperty(_localizer$translatio2, 'REPLACE_CONFIRM_BODY_2', '还原之前的单元格内容'), _defineProperty(_localizer$translatio2, 'REPLACE_CONFIRM_BODY_3', '允许视频更新单元格内容'), _defineProperty(_localizer$translatio2, 'ACCESS_MICROPHONE_PROMPT', '请允许使用目前浏览器的麦克风'), _defineProperty(_localizer$translatio2, 'ACCESS_MICROPHONE_ADVISORY', '请允许使用麦克风，否则无法录屏' + '请 <a href="https://help.aircall.io/hc/en-gb/articles/115001425325-How-to-allow-Google-Chrome-to-access-your-microphone" ' + 'target="_">允许使用</a>并重新加载该页面'), _defineProperty(_localizer$translatio2, 'ACTIVATE_GRAFFITI_ADVISORY', '在该 Notebook 上启用 Graffiti，就能进行录屏操作啦' + '如果点击取消，不会更改 notebook' + '<br><br><i>(该操作只会增加单元格的元数据，不会更改 Notebook 的内容)</i>'), _defineProperty(_localizer$translatio2, 'SCRUB', 'scrub'), _defineProperty(_localizer$translatio2, 'TOOLTIP_HINT', 'Click the underlined text (below) to watch a movie about this.'), _defineProperty(_localizer$translatio2, 'MOVIE_DURATION', 'Movie duration'), _defineProperty(_localizer$translatio2, 'INSERT_GRAFFITI_BUTTON_CELL', '+ Graffiti Button'), _defineProperty(_localizer$translatio2, 'INSERT_GRAFFITI_BUTTON_CELL_ALT_TAG', 'Insert a Graffiti-enabled button'), _defineProperty(_localizer$translatio2, 'INSERT_GRAFFITI_TERMINAL', '+ Terminal'), _defineProperty(_localizer$translatio2, 'INSERT_GRAFFITI_TERMINAL_ALT_TAG', 'Insert a Graffiti-enabled terminal'), _defineProperty(_localizer$translatio2, 'INSERT_GRAFFITI_TERMINAL_SUITE', '+ Terminal Suite'), _defineProperty(_localizer$translatio2, 'INSERT_GRAFFITI_TERMINAL_SUITE_ALT_TAG', 'Insert a code cell + terminal + button'), _defineProperty(_localizer$translatio2, 'INSERT_TERMINAL_SUITE_STATUS', 'Inserting a terminal suite, please wait...'), _defineProperty(_localizer$translatio2, 'CELL_EXECUTES_GRAFFITI', 'Code Cell, Executes Graffiti'), _defineProperty(_localizer$translatio2, 'CELL_EXECUTE_CHOICE', 'Now click on the element that contains the Graffiti you want this cell to run...'), _defineProperty(_localizer$translatio2, 'CELL_EXECUTE_CHOICE_SET', 'Your choice has been saved.'), _defineProperty(_localizer$translatio2, 'ACTIVATE_LOCK_ALT_TAG', 'Lock/unlock markdown cells'), _defineProperty(_localizer$translatio2, 'LOCK_VERB', 'Lock'), _defineProperty(_localizer$translatio2, 'UNLOCK_VERB', 'Unlock'), _defineProperty(_localizer$translatio2, 'UNLOCK_BODY', 'This will unlock all markdown cells so you can edit them (note: terminal cells are always locked).'), _defineProperty(_localizer$translatio2, 'LOCK_BODY', 'This will lock all markdown cells so they can no longer be edited.'), _defineProperty(_localizer$translatio2, 'LOCK_CONFIRM', 'markdown cells in notebook?'), _localizer$translatio2);
          break;
      }
    },

    init: function init() {
      localizer.translations = {};
      localizer.loadLocale('EN');
      localizer.loadLocale('CN');

      var notebook = Jupyter.notebook;
      localizer.setLanguage('EN');
      if (notebook.metadata.hasOwnProperty('graffiti')) {
        if (notebook.metadata.graffiti.hasOwnProperty('language')) {
          localizer.setLanguage(notebook.metadata.graffiti.language);
        }
      }

      // Load localized strings for China. Paths not working right now, so we're using an inline solution instead, see above
      /*      
            return new Promise((resolve) => {
              requirejs(['/nbextensions/graffiti_extension/js/locales/cn/strings.js'], function (strings) {
                console.log('Fetched lang strings');
                localizer.translations['CN'] = strings.getTranslations();
                console.log('we loaded chinese translations.');
                //localizer.setLanguage('CN');
                resolve();
              });
            });
      */

      return Promise.resolve();
    }

  };

  return localizer;
});


define('js/selectionSerializer.js',[], function () {
  // From npm package: serialize-selection, MIT license
  // restore the selection specified by the given state and reference node, and
  // return the new selection object
  var selectionSerializer = {

    // https://stackoverflow.com/questions/3169786/clear-text-selection-with-javascript
    clearWindowSelection: function clearWindowSelection() {
      if (window.getSelection) {
        if (window.getSelection().empty) {
          // Chrome
          window.getSelection().empty();
        } else if (window.getSelection().removeAllRanges) {
          // Firefox
          window.getSelection().removeAllRanges();
        }
      } else if (document.selection) {
        // IE?
        document.selection.empty();
      }
    },

    // serialize the current selection offsets using given node as a reference point
    get: function get(referenceNode) {
      referenceNode = referenceNode || document.body;

      var sel = window.getSelection();
      var range = sel.rangeCount ? sel.getRangeAt(0).cloneRange() : document.createRange();
      var startContainer = range.startContainer;
      var parentNode = startContainer.parentNode;
      var startOffset = range.startOffset;
      var state = {
        content: range.toString()
      };

      // move the range to select the contents up to the selection
      // so we can find its character offset from the reference node
      range.selectNodeContents(referenceNode);
      range.setEnd(startContainer, startOffset);

      state.start = range.toString().length;
      state.end = state.start + state.content.length;

      return {
        state: state,
        empty: state.start === state.end
      };
    },

    restore: function restore(selectionSerialized) {
      var referenceNode = selectionSerialized.referenceNode || document.body;
      var state = selectionSerialized.state;

      var currentNodeCharIndex = 0;
      var nodes = [referenceNode];
      var sel = window.getSelection();
      var existingRange = void 0;
      if (sel.rangeCount > 0) {
        //existingRange = sel.getRangeAt(0);
        //console.log('removing existing range:', existingRange);
        sel.removeAllRanges();
      }

      var range = document.createRange();
      var node = void 0;
      var nextNodeCharIndex = void 0;

      range.setStart(referenceNode, 0);
      range.collapse(true);

      while (node = nodes.pop()) {
        if (node.nodeType === 3) {
          // text_node
          nextNodeCharIndex = currentNodeCharIndex + node.length;

          // if this node contains the character at the start index, set this as the
          // starting node with the correct offset
          if (state.start >= currentNodeCharIndex && state.start <= nextNodeCharIndex) {
            range.setStart(node, state.start - currentNodeCharIndex);
          }

          // if this node contains the character at the end index, set this as the
          // ending node with the correct offset and stop looking
          if (state.end >= currentNodeCharIndex && state.end <= nextNodeCharIndex) {
            range.setEnd(node, state.end - currentNodeCharIndex);
            break;
          }

          currentNodeCharIndex = nextNodeCharIndex;
        } else {

          // get child nodes if the current node is not a text node
          var i = node.childNodes.length;
          while (i--) {
            nodes.push(node.childNodes[i]);
          }
        }
      }

      sel.addRange(range);
      return sel;
    }

  };

  return selectionSerializer;
});


define('js/udacityUser.js',['./state.js'], function (state) {
  var BELLATRIX_URL = 'https://bellatrix.udacity.com';
  var NEBULA_URL = 'https://nebula.udacity.com';

  function getToken() {
    var kernelName = Jupyter.notebook.kernel.name;
    var executeCallbackObject = function executeCallbackObject(callback) {
      return {
        iopub: {
          output: function output(data) {
            var tokenText = '';
            if (kernelName === 'ir') {
              tokenText = data.content.data && data.content.data['text/html'];
              tokenText = tokenText.replace(/'/g, "");
            } else {
              tokenText = data.content.text;
            }
            tokenText ? callback(tokenText) : null;
          }
        }
      };
    };
    return new Promise(function (resolve, reject) {
      var gcloudMetadaUrl = 'http://metadata.google.internal/computeMetadata/v1/instance/attributes/keep_alive_token';
      var bashCommand = '';
      var execOptions = {};
      if (kernelName === 'ir') {
        bashCommand = 'system(\'curl "' + gcloudMetadaUrl + '" -H "Metadata-Flavor: Google" -s --fail\', intern=TRUE)';
        execOptions = {
          silent: false
        };
      } else {
        bashCommand = '!curl "' + gcloudMetadaUrl + '" -H "Metadata-Flavor: Google" -s --fail';
      }
      Jupyter.notebook.kernel.execute(bashCommand, executeCallbackObject(function (output) {
        return resolve(output);
      }), execOptions);
    });
  }

  function getUdacityUser(token) {
    return new Promise(function (resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.open("POST", NEBULA_URL + '/api/v1/remote/me');
      xhr.setRequestHeader("Authorization", "Star " + token);
      xhr.onload = function () {
        if (this.status >= 200 && this.status < 300) {
          resolve(JSON.parse(xhr.response));
        } else {
          reject({
            status: this.status,
            statusText: xhr.statusText
          });
        }
      };
      xhr.onerror = function () {
        reject({
          status: this.status,
          statusText: xhr.statusText
        });
      };
      xhr.send();
    });
  }

  var udacityUser = {
    token: null,
    usageReportSent: false,
    getUser: function getUser() {
      return getToken().then(function (token) {
        udacityUser.token = token;
        return getUdacityUser(token);
      });
    },
    setUser: function setUser() {
      // Can't get star token if kernel is not set.
      if (!Jupyter.notebook.kernel) {
        return;
      }

      udacityUser.getUser().then(function (user) {
        state.setUserId(user.userId);
        state.setWorkspace(user);
        user.coco && $('#graffiti-setup-button').css('display', 'inline-block');
      }).catch(function (err) {
        return console.error(err);
      });
    },
    trackUsageStats: function trackUsageStats() {
      if (!udacityUser.usageReportSent) {
        var stats = state.getUsageStats();
        stats.workspace = state.getWorkspace();
        var xhr = new XMLHttpRequest();
        // Async is set to false to make this request work on unload event
        xhr.open("POST", BELLATRIX_URL + '/api/v1/graffiti/stats', false);
        xhr.setRequestHeader("Content-Type", "application/json");
        // Required to allow cookie to be set crossDomain
        xhr.withCredentials = true;
        xhr.send(JSON.stringify(stats));
        udacityUser.usageReportSent = true;
      }
    }
  };

  return udacityUser;
});


define('js/graffiti.js',['base/js/dialog', 'base/js/events', 'notebook/js/textcell', './LZString.js', './state.js', './utils.js', './audio.js', './storage.js', './sticker.js', './localizer.js', './selectionSerializer.js', './udacityUser.js', './xterm/terminals.js', 'components/marked/lib/marked'], function (dialog, events, textCell, LZString, state, utils, audio, storage, stickerLib, localizer, selectionSerializer, udacityUser, terminalLib, marked) {
  var Graffiti = function () {
    var _arguments = arguments;

    var graffiti = {

      init: function init() {
        console.log('Graffiti: Main constructor running.');

        utils.loadCss(['/nbextensions/graffiti-dist/graffiti.css', '/nbextensions/graffiti-dist/xterm.css']);

        var location = document.location;

        state.init();
        var currentAccessLevel = state.getAccessLevel();

        graffiti.LZString = LZString;
        graffiti.rewindAmt = 1; // seconds
        graffiti.rewindSkipEditAmt = 0.05; // seconds
        graffiti.CMEvents = {};
        graffiti.halfBullseye = 12;
        graffiti.sitePanel = $('#site');
        graffiti.notebookPanel = $('#notebook');
        graffiti.notebookContainer = $('#notebook-container');
        graffiti.notebookContainerPadding = parseInt(graffiti.notebookContainer.css('padding').replace('px', ''));
        graffiti.penColor = 'black';

        graffiti.recordingIntervalMs = 10; // In milliseconds, how frequently we sample the state of things while recording.
        graffiti.playbackIntervalMs = graffiti.recordingIntervalMs; // In milliseconds, loop speed for playback.  Must match recordingIntervalMs.
        graffiti.highlightMarkText = undefined;
        graffiti.cmLineHeight = 17.0001; // line height of code mirror lines as styled in Jupyter
        graffiti.cmLineFudge = 8; // buffer between lines
        graffiti.cmLineTipFudge = 6; // buffer between lines for tip display
        graffiti.tipAboveFudge = 14;
        graffiti.tokenRanges = {};
        graffiti.canvases = {
          permanent: {}, // these canvases persist drawings throughout the lifespan of the recording
          temporary: {} // these canvases get wiped a couple seconds after the person stops drawing
        };
        graffiti.stickers = {
          permanent: {}, // these stickers persist throughout the lifespan of the recording
          temporary: {} // these stickers fade out a couple seconds after the person finishes placing them
        };

        graffiti.lastUpdateControlsTime = utils.getNow();
        graffiti.notificationMsgs = {};
        graffiti.panelFadeTime = 350;
        graffiti.windowSizeCheckInterval = 250; // ms
        graffiti.windowSizeChangeTime = undefined;
        graffiti.skipActivatorKeyCombo = 0;

        graffiti.scrollNudgeSmoothIncrements = 6;
        graffiti.scrollNudgeQuickIncrements = 4;
        graffiti.scrollNudge = undefined;
        graffiti.penColors = {
          'black': '000000',
          'white': 'ffffff',
          'red': 'ff0000',
          'green': '00ff00',
          'blue': '0000ff',
          'yellow': 'ffff00',
          'orange': 'ff9900',
          'purple': '8a2be2',
          'brown': '996600'
        };
        graffiti.minimumStickerSize = 20; // pixels
        graffiti.minimumStickerSizeWithBuffer = graffiti.minimumStickerSize + 10;
        graffiti.previousActiveTakeId = undefined;
        graffiti.forcedGraffitiTooltipRefresh = false;
        graffiti.MarkdownCell = textCell.MarkdownCell;

        if (currentAccessLevel === 'create') {
          storage.ensureNotebookGetsGraffitiId();
          storage.ensureNotebookGetsFirstAuthorId();
        }

        // Init language strings
        localizer.init().then(function () {
          // Set up the button that activates Graffiti on new notebooks and controls visibility of the control panel if the notebook has already been graffiti-ized.
          graffiti.updateSetupButton();

          if (Jupyter.notebook.metadata.hasOwnProperty('graffiti')) {
            // do not try to load the manifest if this notebook has not yet been graffiti-ized.
            storage.loadManifest(currentAccessLevel).then(function () {
              utils.createApiSymlink();
              graffiti.initInteractivity();
            }).catch(function (ex) {
              console.log('Graffiti: Not setting up Graffiti because this notebook has never had any authoring done yet (no recordingId).');
              console.log(ex);
            });
          }
        });
      },

      provideAPIKeyExamples: function provideAPIKeyExamples() {
        var recorderApiKeyCell = Jupyter.notebook.insert_cell_below('code');
        var invocationLine = "# Graffiti Id: " + graffiti.recordingAPIKey + "\n\n" + "# --------------------------------------\n" + "import jupytergraffiti\n" + "# jupytergraffiti.api.play_recording('" + graffiti.recordingAPIKey + "')\n" + "# jupytergraffiti.api.play_recording_with_prompt('" + graffiti.recordingAPIKey + "', '![idea](../images/lightbulb_small.jpg) Click **here** to learn more.')\n" + "# jupytergraffiti.api.stop_playback()\n" + "# jupytergraffiti.api.remove_unused_takes('" + graffiti.recordingAPIKey + "')\n" + "# jupytergraffiti.api.remove_all_unused_takes()\n";
        recorderApiKeyCell.set_text(invocationLine);
        Jupyter.notebook.select_next();
        recorderApiKeyCell.code_mirror.focus();
      },

      bindControlPanelCallbacks: function bindControlPanelCallbacks(parent, callbacks) {
        if (callbacks !== undefined) {
          var cb = void 0,
              id = void 0,
              elem = void 0;
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = callbacks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              cb = _step.value;
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = cb.ids[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  id = _step2.value;

                  parent.find('#' + id).on(cb.event, cb.fn);
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      },

      setNotifier: function setNotifier(notificationMsg, callbacks) {
        var notifierPanel = graffiti.controlPanelIds['graffiti-notifier'];
        notifierPanel.show().children().hide();
        if (!graffiti.notificationMsgs.hasOwnProperty(notificationMsg)) {
          var notificationId = 'graffiti-notification-' + utils.generateUniqueId();
          var notificationHtml = $('<div id="' + notificationId + '">' + notificationMsg + '</div>');
          notificationHtml.appendTo(notifierPanel);
          var newNotificationDiv = notifierPanel.find('#' + notificationId);
          graffiti.notificationMsgs[notificationMsg] = newNotificationDiv;
          graffiti.bindControlPanelCallbacks(newNotificationDiv, callbacks);
        }
        graffiti.notificationMsgs[notificationMsg].show();
      },

      setJupyterMenuHint: function setJupyterMenuHint(hint) {
        if (graffiti.jupyterMenuHint === undefined) {
          var jupyterMainToolbar = $('#maintoolbar-container');
          var menuHintDiv = $('<span id="graffiti-jupyter-menu-hint"></span>');
          graffiti.jupyterMenuHint = menuHintDiv.appendTo(jupyterMainToolbar);
        }
        graffiti.jupyterMenuHint.html(hint).show();
      },

      clearJupyterMenuHint: function clearJupyterMenuHint() {
        if (graffiti.jupyterMenuHint !== undefined) {
          graffiti.jupyterMenuHint.hide();
        }
      },

      startPanelDragging: function startPanelDragging(e) {
        console.log('Graffiti: dragging control panel');
        var controlPanelPosition = graffiti.outerControlPanel.position();
        var pointerPosition = state.getPointerPosition();
        state.setControlPanelDragging(true);
        state.setControlPanelDragOffset({ left: pointerPosition.x - controlPanelPosition.left, top: pointerPosition.y - controlPanelPosition.top });
        e.preventDefault();
        e.stopPropagation();
      },

      updateSkipsBar: function updateSkipsBar() {
        if (!state.getEditingSkips()) {
          return;
        }
        var skipRecords = state.getSkipsRecords();
        var bar = $('#graffiti-skips-display-bar');
        bar.empty();
        var barWidth = bar.width();
        var barHeight = bar.height();
        var skipBarLeft = void 0,
            skipBarWidth = void 0,
            skipBarColor = void 0,
            skipBarCaption = void 0,
            rec = void 0,
            endTime = void 0;
        var duration = state.getHistoryDuration();
        for (var i = 0; i < skipRecords.length; ++i) {
          rec = skipRecords[i];
          endTime = rec.endTime !== undefined ? rec.endTime : state.getTimePlayedSoFar();
          //console.log('updateSkipsBar, endTime:', endTime);
          skipBarLeft = parseInt(rec.startTime / duration * barWidth);
          skipBarWidth = parseInt((endTime - rec.startTime) / duration * barWidth);
          if (skipBarWidth < 0) {
            skipBarLeft += skipBarWidth;
            skipBarWidth = Math.abs(skipBarWidth);
          }
          skipBarColor = state.getSkipStatusColor(rec.status);
          skipBarCaption = state.getSkipStatusCaption(rec.status);
          $('<div class="graffiti-skips-display-sub-bar" style="width:' + skipBarWidth + 'px;left:' + skipBarLeft + 'px;background:#' + skipBarColor + '"' + 'title="' + skipBarCaption + '"></div>').appendTo(bar);
        }
      },

      storeSkipRecord: function storeSkipRecord(newStatus) {
        state.storeSkipRecord(newStatus);
        graffiti.updateSkipsBar();
        graffiti.updateControlPanels();
      },

      // This function is sort of a hack. It creates a new Graffiti to be placed in this cell, wrapping the markdown in it.
      // It repeats some of the functionality of finishGraffiti() without UX interactions, which is unfortunate. Refactor really needed.
      createGraffitizedMarkdown: function createGraffitizedMarkdown(cell, markdown, tooltipCommands, tooltipDirectives) {
        var recordingKey = utils.generateUniqueId();
        var cellId = utils.getMetadataCellId(cell.metadata);
        var recordingRecord = $.extend(true, {
          cellId: cellId,
          cellType: 'markdown',
          createDate: utils.getNow(),
          inProgress: false,
          tokens: $.extend({}, graffiti.selectedTokens.tokens),
          range: $.extend({}, graffiti.selectedTokens.range),
          allTokensString: graffiti.selectedTokens.allTokensString,
          markdown: tooltipDirectives.join("\n") + "\n",
          authorId: state.getAuthorId(),
          authorType: state.getAuthorType(),
          activeTakeId: undefined, // this will be replaced with an id for the first movie recording made
          takes: [],
          hasMovie: true // this is set to true but the non-existent will be ignored because this will run a terminal command
        }, tooltipCommands);
        state.setSingleManifestRecording(cellId, recordingKey, recordingRecord);
        storage.storeManifest();
        var spanOpenTag = '<span class="graffiti-highlight graffiti-' + cellId + '-' + recordingKey + '"><i></i>';
        var graffizedContents = spanOpenTag + markdown + '</span>';
        return {
          recordingKey: recordingKey,
          markdown: graffizedContents
        };
      },

      // Create a button with a graffiti that doesn't do anything, but is ready to attach a recording to. This is merely to help
      // authors who don't know much html create buttons more easily.
      createGraffitiButtonAboveSelectedCell: function createGraffitiButtonAboveSelectedCell() {
        var selectedCellIndex = Jupyter.notebook.get_selected_index();
        var buttonCell = Jupyter.notebook.insert_cell_above('markdown', selectedCellIndex);
        var buttonCellId = utils.getMetadataCellId(buttonCell.metadata);
        var buttonCellIndex = utils.findCellIndexByCellId(buttonCellId);
        Jupyter.notebook.select(buttonCellIndex); // critical step, otherwise, the cell will not render correctly
        var cm = buttonCell.code_mirror;
        cm.execCommand('selectAll');
        var params = { cell: buttonCell, clear: true };
        graffiti.refreshGraffitiHighlights(params);
        graffiti.selectedTokens = utils.findSelectionTokens(buttonCell, graffiti.tokenRanges, state);

        tooltipCommands = {
          autoPlay: 'never',
          playOnClick: false,
          hideTooltip: false,
          narratorName: undefined,
          narratorPicture: undefined,
          stickerImageUrl: undefined
        };
        var tooltipDirectives = ['%%button_name No Movie Here Yet', 'Edit this markdown cell to customize the Graffiti for this button, and to record a new movie.<br><br>' + '_(NB: The default movie that was created with this button is a *placeholder* and it will *not* play.)_'];
        var rawButtonMarkdown = '<button>Graffiti Sample Button (edit me)</button>';
        var graffitizedData = graffiti.createGraffitizedMarkdown(buttonCell, rawButtonMarkdown, tooltipCommands, tooltipDirectives);
        buttonCell.set_text(graffitizedData.markdown);
        buttonCell.render();

        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltips();

        return buttonCell;
      },

      createTerminalSuiteAboveSelectedCell: function createTerminalSuiteAboveSelectedCell() {
        graffiti.setJupyterMenuHint(localizer.getString('INSERT_TERMINAL_SUITE_STATUS'));
        var terminalSuite = {};
        var selectedCellIndex = Jupyter.notebook.get_selected_index();

        var codeCell = Jupyter.notebook.insert_cell_above('code', selectedCellIndex);
        var codeCommentString = utils.getCodeCommentString();
        codeCell.set_text(codeCommentString + "\n" + codeCommentString + ' ' + "Paste code here. It will execute the graffiti associated with the button when shift-enter is pressed.\n" + codeCommentString + "\n");
        terminalSuite.codeCellId = utils.getMetadataCellId(codeCell.metadata);

        var terminalCell = terminalLib.createTerminalCellAboveSelectedCell(selectedCellIndex + 1);
        terminalSuite.terminalCellId = terminalCell.term.id; // initially the term id is the same as the cellId of the cell it lives in.

        var buttonCell = Jupyter.notebook.insert_cell_below('markdown', selectedCellIndex + 1);
        var buttonCellId = utils.getMetadataCellId(buttonCell.metadata);
        var buttonCellIndex = utils.findCellIndexByCellId(buttonCellId);
        Jupyter.notebook.select(buttonCellIndex); // critical step, otherwise, the cell will not render correctly
        var cm = buttonCell.code_mirror;
        cm.execCommand('selectAll');
        var params = { cell: buttonCell, clear: true };
        graffiti.refreshGraffitiHighlights(params);
        graffiti.selectedTokens = utils.findSelectionTokens(buttonCell, graffiti.tokenRanges, state);

        tooltipCommands = {
          autoPlay: 'never',
          playOnClick: true,
          hideTooltip: true,
          narratorName: undefined,
          narratorPicture: undefined,
          stickerImageUrl: undefined,
          saveToFile: [{ cellId: terminalSuite.codeCellId, path: './graffiti_sample.txt' }],
          terminalCommand: { terminalId: terminalSuite.terminalCellId, command: 'cat ./graffiti_sample.txt' }
        };
        var tooltipDirectives = ['%%play_on_click', '%%hide_tooltip', '%%save_to_file' + ' ' + terminalSuite.codeCellId + ' "' + tooltipCommands.saveToFile[0].path + '"', '%%terminal_command' + ' ' + terminalSuite.terminalCellId + ' "' + tooltipCommands.terminalCommand.command + '"'];
        var rawButtonMarkdown = '<button>Run Code</button>';
        var graffitizedData = graffiti.createGraffitizedMarkdown(buttonCell, rawButtonMarkdown, tooltipCommands, tooltipDirectives);
        buttonCell.set_text(graffitizedData.markdown);
        buttonCell.render();
        terminalSuite.buttonCellId = utils.getMetadataCellId(buttonCell.metadata);

        // Wire up the code cell to execute the button graffiti when shift-enter/ctrl-enter is pressed in it.
        var targetGraffitiId = utils.composeGraffitiId(terminalSuite.buttonCellId, graffitizedData.recordingKey);
        utils.setCellGraffitiConfigEntry(codeCell, 'executeCellViaGraffiti', targetGraffitiId);

        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltips();

        graffiti.clearJupyterMenuHint();
        return terminalSuite;
      },

      setupOneControlPanel: function setupOneControlPanel(elemId, elemHtml, callbacks) {
        if (graffiti.controlPanelIds === undefined) {
          graffiti.controlPanelIds = {};
        }
        var fullHtml = '<div class="graffiti-control-panel" id="' + elemId + '">' + elemHtml + '</div>';
        var elem = $(fullHtml);
        elem.appendTo(graffiti.controlPanelsShell);
        graffiti.controlPanelIds[elemId] = graffiti.controlPanelsShell.find('#' + elemId);
        graffiti.bindControlPanelCallbacks(graffiti.controlPanelIds[elemId], callbacks);
      },

      setupControlPanels: function setupControlPanels() {
        var previousPlayState = void 0;
        if ($('#graffiti-outer-control-panel').length == 0) {
          var outerControlPanel = $('<div id="graffiti-outer-control-panel">' + '  <div id="graffiti-inner-control-panel">' + '    <div class="graffiti-small-dot-pattern" id="graffiti-drag-handle">&nbsp;</div>' + '    <div id="graffiti-control-panels-shell"></div>' + '  </div>' + '</div>');
          //const header = $('#header');
          outerControlPanel.appendTo($('body'));
          var graffitiCursor = $('<div id="graffiti-cursor" name="cursor" class="graffiti-cursor">' + '  <div id="graffiti-cursor-normal-cells">' + '     <img src="/nbextensions/graffiti-dist/transparent_bullseye2.png">' + '  </div>' + '  <div id="graffiti-cursor-terminal-cells"></div>' + '</div>');
          graffitiCursor.appendTo(header);
        }

        graffiti.graffitiCursorShell = $('#graffiti-cursor');
        graffiti.graffitiNormalCursor = $('#graffiti-cursor-normal-cells');
        graffiti.graffitiTerminalCursor = $('#graffiti-cursor-terminal-cells');
        graffiti.outerControlPanel = $('#graffiti-outer-control-panel');
        graffiti.outerControlPanel.hide();
        graffiti.controlPanelsShell = $('#graffiti-control-panels-shell');

        $('body').on('mouseup', function (e) {
          if (state.getControlPanelDragging()) {
            console.log('Graffiti: no longer dragging control panel');
            state.setControlPanelDragging(false);
            e.preventDefault();
            e.stopPropagation();
          }
        });

        var logoText = 'Graffiti'.split('').join('&nbsp;&nbsp;&nbsp;&nbsp;');
        graffiti.setupOneControlPanel('graffiti-control-panel-title', '<div>' + stickerLib.makeSmallUdacityIcon({ width: 20, height: 20 }) + '</div><div>' + logoText + '</div>');

        var dragHandle = $('#graffiti-drag-handle,#graffiti-control-panel-title');
        dragHandle.on('mousedown', function (e) {
          graffiti.startPanelDragging(e);
        });

        graffiti.windowResizeHandler = function (opts) {
          //console.log('Graffiti: windowResizeHandler');
          if (opts === undefined || opts !== undefined && opts.force) {
            graffiti.resizeCanvases();
            if (graffiti.outerControlPanel.is(':visible')) {
              var windowWidth = $(window).width();
              var windowHeight = $(window).height();
              var controlPanelPosition = graffiti.outerControlPanel.position();
              var maxLeft = windowWidth - graffiti.outerControlPanel.width() - 20;
              var maxTop = windowHeight - graffiti.outerControlPanel.height() - 20;
              // need to redraw all current stickers here if playing
              var activity = state.getActivity();
              if (activity === 'playing' || activity === 'playbackPaused') {
                graffiti.wipeAllStickerDomCanvases();
                graffiti.redrawAllDrawings();
              }
              graffiti.updateControlPanelPosition({ left: Math.max(0, Math.min(controlPanelPosition.left, maxLeft)),
                top: Math.max(0, Math.min(maxTop, controlPanelPosition.top)) });
              state.setControlPanelDragging(false);
            }
            graffiti.refreshAllGraffitiSideMarkers();
          }
        };

        // Debounce is no longer needed as we're handling resizes of the notebook container with setTimeout calls, below this.
        //const windowResizeDebounced = _.debounce(graffiti.windowResizeHandler, 100);

        // Watch the notebook container width. If it changes, we will need to handle a resize to redraw many elements.
        graffiti.notebookContainerWidth = graffiti.notebookContainer.width();
        graffiti.performWindowResizeCheck = function () {
          var newWidth = graffiti.notebookContainer.width();
          if (newWidth !== graffiti.notebookContainerWidth) {
            graffiti.notebookContainerWidth = newWidth;
            var now = utils.getNow();
            // Sort of simple debounce technique
            if (graffiti.windowSizeChangeTime === undefined) {
              graffiti.windowResizeHandler();
              graffiti.windowSizeChangeTime = now;
            } else if (now - graffiti.windowSizeChangeTime > 100) {
              //  try not to resize more frequently than every 100ms
              graffiti.windowResizeHandler();
              graffiti.windowSizeChangeTime = now;
            }
          }
          setTimeout(graffiti.performWindowResizeCheck, graffiti.windowSizeCheckInterval);
        };
        setTimeout(graffiti.performWindowResizeCheck, graffiti.windowSizeCheckInterval);

        var iconConfiguration = {
          dimensions: { x: 0, y: 0, width: 8, height: 8 },
          color: 'black',
          strokeWidth: 1,
          fillOpacity: 0
        };

        var settingsIcon = stickerLib.makeSettingsIcon(iconConfiguration);

        graffiti.setupOneControlPanel('graffiti-record-controls', '  <button class="btn btn-default" id="graffiti-create-btn" title="' + localizer.getString('CREATE_1') + '">' + '<i class="fa fa-edit"></i>&nbsp; <span>' + localizer.getString('CREATE_1') + '</span></button>' + '  <button class="btn btn-default" id="graffiti-edit-btn" title="' + localizer.getString('EDIT_TOOLTIP') + '">' + '  <span style="position:absolute;margin-top:4px;margin-left:2px;">' + settingsIcon + '</span> ' + '  <span style="padding-left:16px;">' + localizer.getString('EDIT') + '</span></button>' + '  <button class="btn btn-default" id="graffiti-begin-recording-btn" title="' + localizer.getString('RECORD_MOVIE') + '">' + '<i class="fa fa-film graffiti-recorder-button"></i>&nbsp;<span>' + localizer.getString('RECORD') + '</span></button>' + '  <button class="btn btn-default" id="graffiti-begin-rerecording-btn" title="' + localizer.getString('RERECORD_MOVIE') + '">' + '<i class="fa fa-film graffiti-recorder-button"></i>&nbsp;<span>' + localizer.getString('RERECORD') + '</span></button>' + '  <button class="btn btn-default" id="graffiti-remove-btn" title="' + localizer.getString('REMOVE_GRAFFITI') + '">' + '<i class="fa fa-trash"></i></button>', [{
          ids: ['graffiti-create-btn', 'graffiti-edit-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.editGraffiti();
          }
        }, {
          ids: ['graffiti-begin-recording-btn', 'graffiti-begin-rerecording-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.beginMovieRecordingProcess();
          }
        }, {
          ids: ['graffiti-remove-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.removeGraffitiWithPrompt();
          }
        }]);

        graffiti.setupOneControlPanel('graffiti-finish-edit-controls', '<button class="btn btn-default" id="finish-graffiti-btn" title="' + localizer.getString('SAVE_GRAFFITI') + '">' + localizer.getString('SAVE_GRAFFITI') + '</button>', [{
          ids: ['finish-graffiti-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.finishGraffiti(true);
          }
        }]);

        graffiti.setupOneControlPanel('graffiti-start-recording-controls', '<button class="btn btn-default" id="btn-start-recording" title="' + localizer.getString('START_RECORDING') + '">' + '<i class="fa fa-pause recorder-start-button"></i>&nbsp;' + localizer.getString('START_RECORDING') + '</button>', [{
          ids: ['btn-start-recording', 'btn-restart-recording'],
          event: 'click',
          fn: function fn(e) {
            graffiti.finishGraffiti(true);
          }
        }]);

        graffiti.setupOneControlPanel('graffiti-recording-controls', '<button class="btn btn-default" id="btn-end-recording" title="' + localizer.getString('END_RECORDING') + '">' + '<i class="fa fa-pause recorder-stop-button"></i>&nbsp;' + localizer.getString('END_RECORDING') + '</button>' + '<div id="graffiti-recording-status">' + '  <div id="graffiti-recording-flash-icon"></div>' + '  <div id="graffiti-time-display-recording"></div>' + '</div>', [{
          ids: ['btn-end-recording'],
          event: 'click',
          fn: function fn(e) {
            graffiti.toggleRecording();
          }
        }]);

        // controls which recording takes are the activeTake
        graffiti.setupOneControlPanel('graffiti-takes-controls', '<div id="graffiti-takes-controls-outer">' + '  <div id="graffiti-takes-title">' + localizer.getString('TAKES') + ':</div>' + '  <div id="graffiti-takes-list"></div>' + '</div>', [{
          ids: ['graffiti-takes-list'],
          event: 'click',
          fn: function fn(e) {
            var target = $(e.target);
            var choice = void 0;
            if (target.attr('id') === 'graffiti-takes-list') {
              choice = target.find('.graffiti-take-item:first');
            } else {
              choice = target;
            }
            if (choice.length > 0) {
              var newTakeId = choice.attr('id');
              var recordingCellId = choice.attr('recordingCellId');
              var _recordingKey = choice.attr('recordingKey');
              graffiti.updateActiveTakeId(recordingCellId, _recordingKey, newTakeId);
            }
          }
        }]);

        var runnerOnIcon = stickerLib.makeRunningMan('black');
        var runnerOffIcon = stickerLib.makeRunningMan('white');

        graffiti.setupOneControlPanel('graffiti-playback-controls', '<div id="graffiti-narrator-info">' + '  <div id="graffiti-narrator-pic"></div>' + '  <div id="graffiti-narrator-details">' + '    <div>Presenter: </div><div id="graffiti-narrator-name"></div>' + '  </div>' + '</div>' + '<div id="graffiti-playback-buttons">' + '  <button class="btn btn-default btn-play" id="graffiti-play-btn" title="' + localizer.getString('START_PLAYBACK') + '">' + '    <i class="fa fa-play"></i>' + '  </button>' + '  <button class="btn btn-default" id="graffiti-pause-btn" title="' + localizer.getString('PAUSE_PLAYBACK') + '">' + '    <i class="fa fa-pause"></i>' + '  </button>' + '  <div id="graffiti-skip-buttons">' + '    <button class="btn btn-default btn-rewind" id="graffiti-rewind-btn" title="' + localizer.getString('SKIP_BACK') + ' ' + (state.scanningIsOn() ? localizer.getString('TO_PREVIOUS_SENTENCE') : graffiti.rewindAmt + ' ' + localizer.getString('SECONDS')) + '">' + '      <i class="fa fa-backward"></i>' + '    </button>' + '    <button class="btn btn-default btn-forward" id="graffiti-forward-btn" title="' + localizer.getString('SKIP_FORWARD') + ' ' + (state.scanningIsOn() ? localizer.getString('TO_NEXT_SENTENCE') : graffiti.rewindAmt + ' ' + localizer.getString('SECONDS')) + '">' + '      <i class="fa fa-forward"></i>' + '    </button>' + '  </div>' + '  <div id="graffiti-sound-buttons">' + '    <button class="btn btn-default btn-sound-on" id="graffiti-sound-on-btn" title="' + localizer.getString('MUTE') + '">' + '       <i class="fa fa-volume-up"></i>' + '   </button>' + '   <button class="btn btn-default btn-sound-off" id="graffiti-sound-off-btn" title="' + localizer.getString('UNMUTE') + '">' + '     <i class="fa fa-volume-off"></i>' + '   </button>' + '  </div>' + '  <div id="graffiti-rapidplay-buttons">' + '    <button class="btn btn-default btn-rapidplay-on" id="graffiti-rapidplay-on-btn" title="' + localizer.getString('HIGH_SPEED_PLAYBACK') + '">' + runnerOnIcon + '   </button>' + '   <button class="btn btn-default btn-rapidplay-off" id="graffiti-rapidplay-off-btn" title="' + localizer.getString('REGULAR_SPEED_PLAYBACK') + '">' + runnerOffIcon + '   </button>' + '  </div>' + '</div>' + '<div id="graffiti-scrub-controls">' + '  <div id="graffiti-playback-range">' + '    <div id="graffiti-skips-display-bar"></div>' + '    <input type="range" min="0" max="1000" value="0" id="graffiti-recorder-range"></input>' + '  </div>' + '  <div id="graffiti-time-display-playback">00:00</div>' + '</div>', [{
          ids: ['graffiti-play-btn', 'graffiti-pause-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.togglePlayback();
          }
        }, {
          ids: ['graffiti-forward-btn', 'graffiti-rewind-btn'],
          event: 'click',
          fn: function fn(e) {
            //console.log('Graffiti: forward-btn/rewind-btn clicked');
            var direction = 1;
            if ($(e.target).attr('id') === 'graffiti-rewind-btn' || $(e.target).hasClass('fa-backward')) {
              direction = -1;
            }
            graffiti.jumpPlayback(direction, state.getEditingSkips() ? graffiti.rewindSkipEditAmt : graffiti.rewindAmt);
          }
        }, {
          ids: ['graffiti-sound-on-btn', 'graffiti-sound-off-btn'],
          event: 'click',
          fn: function fn(e) {
            if (state.getMute()) {
              state.setMute(false);
              graffiti.updateControlPanels();
              if (state.getActivity() === 'playing') {
                audio.startPlayback(state.getTimePlayedSoFar());
              }
            } else {
              state.setMute(true);
              graffiti.updateControlPanels();
              if (state.getActivity() === 'playing') {
                audio.pausePlayback();
              }
            }
          }
        }, {
          ids: ['graffiti-rapidplay-on-btn', 'graffiti-rapidplay-off-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.toggleRapidPlay({ scan: false });
          }
        }, {
          ids: ['graffiti-rapidscan-on-btn', 'graffiti-rapidscan-off-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.toggleRapidPlay({ scan: true });
          }
        }, {
          ids: ['graffiti-recorder-range'],
          event: 'mousedown',
          fn: function fn(e) {
            //console.log('slider:mousedown');
            previousPlayState = state.getActivity();
            graffiti.pausePlayback(); // stop playback if playing when you start to scrub
            graffiti.changeActivity('scrubbing');
          }
        }, {
          ids: ['graffiti-recorder-range'],
          event: 'mouseup',
          fn: function fn(e) {
            //console.log('slider:mouseup')
            graffiti.handleSliderDrag(); // rerun slider drag on mouseup because we may not have gotten the last input event.
            graffiti.changeActivity('playbackPaused');
            if (previousPlayState === 'playing') {
              graffiti.startPlayback();
            }
            graffiti.updateAllGraffitiDisplays();
          }
        }, {
          ids: ['graffiti-recorder-range'],
          event: 'input',
          fn: function fn(e) {
            graffiti.handleSliderDragDebounced();
          }
        }]);

        graffiti.setupOneControlPanel('graffiti-notifier', '<div id="graffiti-notifier"></div>');

        // These two SVGs come from fontawesome-5.2.0: fas fa-highlighter and fas fa-pen-alt, respectively. However, we can't use them without importing the latest
        // fontawesome and that collides with Jupyter's use of fontawesome.

        graffiti.setupOneControlPanel('graffiti-recording-pen-controls', '<div id="graffiti-recording-pens-shell">' + ' <button class="btn btn-default" id="graffiti-line-pen" title="' + localizer.getString('FREEFORM_PEN_TOOL') + '">' + '<svg class="svg-inline--fa fa-pen-alt fa-w-16" aria-hidden="true" data-prefix="fa" data-icon="pen-alt" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" data-fa-i2svg=""><path fill="currentColor" d="M497.94 74.17l-60.11-60.11c-18.75-18.75-49.16-18.75-67.91 0l-56.55 56.55 128.02 128.02 56.55-56.55c18.75-18.75 18.75-49.15 0-67.91zm-246.8-20.53c-15.62-15.62-40.94-15.62-56.56 0L75.8 172.43c-6.25 6.25-6.25 16.38 0 22.62l22.63 22.63c6.25 6.25 16.38 6.25 22.63 0l101.82-101.82 22.63 22.62L93.95 290.03A327.038 327.038 0 0 0 .17 485.11l-.03.23c-1.7 15.28 11.21 28.2 26.49 26.51a327.02 327.02 0 0 0 195.34-93.8l196.79-196.79-82.77-82.77-84.85-84.85z"></path></svg>' + '</button>' + ' <button class="btn btn-default" id="graffiti-highlight-pen" title="' + localizer.getString('HIGHLIGHTER_TOOL') + '">' + '<svg class="svg-inline--fa fa-highlighter fa-w-17" aria-hidden="true" data-prefix="fa" data-icon="highlighter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 544 512" data-fa-i2svg=""><path fill="currentColor" d="M0 479.98L99.92 512l35.45-35.45-67.04-67.04L0 479.98zm124.61-240.01a36.592 36.592 0 0 0-10.79 38.1l13.05 42.83-50.93 50.94 96.23 96.23 50.86-50.86 42.74 13.08c13.73 4.2 28.65-.01 38.15-10.78l35.55-41.64-173.34-173.34-41.52 35.44zm403.31-160.7l-63.2-63.2c-20.49-20.49-53.38-21.52-75.12-2.35L190.55 183.68l169.77 169.78L530.27 154.4c19.18-21.74 18.15-54.63-2.35-75.13z"></path></svg>' + '</button>' + ' <button class="btn btn-default" id="graffiti-eraser-pen" title="' + localizer.getString('ERASER_TOOL') + '">' + '<svg aria-hidden="true" data-prefix="fas" data-icon="eraser" class="svg-inline--fa fa-eraser fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M497.941 273.941c18.745-18.745 18.745-49.137 0-67.882l-160-160c-18.745-18.745-49.136-18.746-67.883 0l-256 256c-18.745 18.745-18.745 49.137 0 67.882l96 96A48.004 48.004 0 0 0 144 480h356c6.627 0 12-5.373 12-12v-40c0-6.627-5.373-12-12-12H355.883l142.058-142.059zm-302.627-62.627l137.373 137.373L265.373 416H150.628l-80-80 124.686-124.686z"></path></svg>' + '</button>' + '</div>' + '<div id="graffiti-recording-colors-shell">' + Object.keys(graffiti.penColors).map(function (key) {
          return '<div id="graffiti-recording-color-' + key + '" colorVal="' + key + '"></div>';
        }).join('') + '</div>' + '<div id="graffiti-line-style-controls">' + '  <div id="graffiti-temporary-ink" title="' + localizer.getString('USE_DISAPPEARING_INK') + '">' + '   <input type="checkbox" id="graffiti-temporary-ink-control" checked />' + '   <label id="graffiti-temporary-ink-label" for="graffiti-temporary-ink-control">' + localizer.getString('TEMPORARY_INK') + '</label>' + '  </div>' + '  <div id="graffiti-dashed-line" title="' + localizer.getString('USE_DASHED_LINES') + '">' + '   <input type="checkbox" id="graffiti-dashed-line-control" />' + '   <label id="graffiti-dashed-line-label" for="graffiti-dashed-line-control">' + localizer.getString('DASHED_LINES') + '</label>' + '  </div>' + '</div>', [{
          ids: ['graffiti-highlight-pen'],
          event: 'click',
          fn: function fn(e) {
            console.log('Graffiti: you picked highlighter tool.');
            graffiti.setGraffitiPenColor('yellow');
            graffiti.toggleGraffitiPen('highlight');
          }
        }, {
          ids: ['graffiti-line-pen'],
          event: 'click',
          fn: function fn(e) {
            console.log('Graffiti: you picked line tool.');
            graffiti.toggleGraffitiPen('line');
          }
        }, {
          ids: ['graffiti-eraser-pen'],
          event: 'click',
          fn: function fn(e) {
            console.log('Graffiti: you picked eraser tool.');
            graffiti.toggleGraffitiPen('eraser');
            $('#graffiti-temporary-ink-control').attr({ checked: false });
            state.updateDrawingState([{ change: 'drawingModeActivated', data: true }, { change: 'permanence', data: 'permanent' }, { change: 'penType', data: 'eraser' }]);
          }
        }, {
          ids: Object.keys(graffiti.penColors).map(function (key) {
            return 'graffiti-recording-color-' + key;
          }),
          event: 'click',
          fn: function fn(e) {
            var target = $(e.target);
            var colorVal = target.attr('colorVal');
            graffiti.setGraffitiPenColor(colorVal);
            // Turn on the pen/highlighter if you change pen color and not stickering
            var activePenType = state.getDrawingPenAttribute('type');
            if (activePenType !== 'sticker') {
              graffiti.activateGraffitiPen(state.getDrawingPenAttribute('type'));
            }
          }
        }, {
          ids: ['graffiti-temporary-ink-control', 'graffiti-temporary-ink-label'],
          event: 'click',
          fn: function fn(e) {
            var permanence = $('#graffiti-temporary-ink-control').is(':checked') ? 'temporary' : 'permanent';
            console.log('You set temporary ink to:', permanence);
            state.updateDrawingState([{ change: 'permanence', data: permanence }]);
            // Turn on the pen/highlighter if you switch temporary ink status and it's not already on, unless stickering
            var activePenType = state.getDrawingPenAttribute('type');
            if (activePenType !== 'sticker') {
              graffiti.activateGraffitiPen(state.getDrawingPenAttribute('type'));
            }
          }
        }, {
          ids: ['graffiti-dashed-line-control', 'graffiti-dashed-line-label'],
          event: 'click',
          fn: function fn(e) {
            var dashedLine = $('#graffiti-dashed-line-control').is(':checked') ? 'dashed' : 'solid';
            console.log('You set dashed line to:', dashedLine);
            state.updateDrawingState([{ change: 'dash', data: dashedLine }]);
            // Turn on the pen/highlighter if you switch dashed line status and not stickering
            var activePenType = state.getDrawingPenAttribute('type');
            if (activePenType !== 'sticker') {
              graffiti.activateGraffitiPen(state.getDrawingPenAttribute('type'));
            }
          }
        }]);

        var iconSize = 22;
        var iconColor = '#666';
        var iconStrokeWidth = 1;
        var iconFatStrokeWidth = 2;
        var iconMargin = 6;
        var smallIconMargin = 2;
        var iconDimensions = { x: iconMargin, y: iconMargin, width: iconSize - iconMargin, height: iconSize - iconMargin };
        var largeIconDimensions = { x: smallIconMargin, y: smallIconMargin, width: iconSize + smallIconMargin, height: iconSize + smallIconMargin };
        var defaultIconConfiguration = {
          dimensions: iconDimensions,
          color: iconColor,
          iconUsage: true,
          strokeWidth: iconStrokeWidth,
          fillOpacity: 0
        };
        var solidIconConfiguration = $.extend({}, defaultIconConfiguration, { fillOpacity: 1 });
        var solidFatIconConfiguration = $.extend({}, true, solidIconConfiguration, { strokeWidth: iconFatStrokeWidth });
        var largeIconConfiguration = $.extend({}, true, defaultIconConfiguration, { buffer: 1, dimensions: largeIconDimensions });
        var roundRectConfiguration = $.extend({}, true, largeIconConfiguration, { rx: 6, ry: 6 });

        var rightTriangle = stickerLib.makeRightTriangle(defaultIconConfiguration);
        var isocelesTriangle = stickerLib.makeIsocelesTriangle(defaultIconConfiguration);
        var rectangle = stickerLib.makeRectangle(largeIconConfiguration);
        var roundRectangle = stickerLib.makeRectangle(roundRectConfiguration);
        var checkMark = stickerLib.makeCheckmark(solidFatIconConfiguration);
        var xMark = stickerLib.makeXmark(solidFatIconConfiguration);
        var ribbon = stickerLib.makeRibbon(solidIconConfiguration);
        var axis = stickerLib.makeAxis(solidIconConfiguration);
        var grid = stickerLib.makeGrid(solidIconConfiguration);
        var bomb = stickerLib.makeBomb(defaultIconConfiguration);
        var trophy = stickerLib.makeTrophy(defaultIconConfiguration);
        var smiley = stickerLib.makeSmiley(solidIconConfiguration);
        var horizontalBrackets = stickerLib.makeHorizontalBrackets(defaultIconConfiguration);
        var verticalBrackets = stickerLib.makeVerticalBrackets(defaultIconConfiguration);
        var ellipse = stickerLib.makeEllipse(largeIconConfiguration);
        var bullsEye = stickerLib.makeBullsEye(largeIconConfiguration);
        var pi = stickerLib.makePi(solidIconConfiguration);
        var alpha = stickerLib.makeAlpha(solidIconConfiguration);
        var beta = stickerLib.makeBeta(solidIconConfiguration);
        var sigma = stickerLib.makeSigma(solidIconConfiguration);
        var theta = stickerLib.makeTheta(solidIconConfiguration);
        var angle = stickerLib.makeAngle(defaultIconConfiguration);
        var curlyBraces = stickerLib.makeSymmetricCurlyBraces(solidIconConfiguration);
        var lineWithArrow = stickerLib.makeLine({
          color: 'black',
          dimensions: iconDimensions,
          endpoints: { p1: { x: -2, y: iconSize - 2 }, p2: { x: iconSize - 2, y: -2 } },
          lineStartOffset: { x: iconMargin - 2, y: iconMargin - 2 },
          strokeWidth: iconStrokeWidth,
          dashed: 'solid',
          usesArrow: true,
          arrowHeadSize: 10
        });

        var stickersExpando = '<div id="graffiti-stickers-expando" class="graffiti-expando graffiti-expando-closed"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" x="0px" y="0px"><title>triangolo</title><g data-name="Livello 11"><polygon points="50 87.5 6.7 87.5 28.35 50 50 12.5 71.65 50 93.3 87.5 50 87.5"/></g></svg></div>';

        graffiti.setupOneControlPanel('graffiti-stickers-controls', '<div id="graffiti-stickers-shell">' + '  <div id="graffiti-stickers-header">' + stickersExpando + '<div>Stickers <span>(Select, then click & drag)</span></div></div>' + '  <div id="graffiti-stickers-body">' + '    <div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-lineWithArrow" title="Line with arrow at tip">' + lineWithArrow + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-horizontalBrackets" title="Horizontal brackets">' + horizontalBrackets + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-verticalBrackets" title="Vertical brackets">' + verticalBrackets + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-curlyBraces" title="Curly braces">' + curlyBraces + '</div>' + '    </div>' + '    <div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-rectangle" title="Rectangle">' + rectangle + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-roundRectangle" title="Rounded corners rectangle">' + roundRectangle + '</div>' +
        //'      <div class="graffiti-stickers-button" id="graffiti-sticker-ellipse" title="Ellipse">' + ellipse + '</div>' +
        '      <div class="graffiti-stickers-button" id="graffiti-sticker-ellipse" title="Ellipse">' + bullsEye + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-rightTriangle" title="Right triangle">' + rightTriangle + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-isocelesTriangle" title="Isoceles triangle">' + isocelesTriangle + '</div>' + '    </div>' + '    <div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-checkmark" title="Checkmark">' + checkMark + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-xmark" title="X mark">' + xMark + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-smiley" title="Smiley face">' + smiley + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-bomb" title="Bomb">' + bomb + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-trophy" title="Trophy">' + trophy + '</div>' + '    </div>' + '    <div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-pi" title="Pi symbol">' + pi + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-alpha"  title="Alpha symbol">' + alpha + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-beta" title="Beta symbol">' + beta + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-sigma" title="Sigma symbol">' + sigma + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-theta"  title="Theta symbol">' + theta + '</div>' + '    </div>' + '    <div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-axis" title="X-y axis">' + axis + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-grid" title="Square grid">' + grid + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-angle" title="Angle">' + angle + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-label" title="Text label">' + 'Tt' + '</div>' + '      <div class="graffiti-stickers-button" id="graffiti-sticker-custom" title="Custom sticker">' + 'Cs' + '</div>' + '    </div>' + '  </div>' + '  <div id="graffiti-sticker-style-controls">' + '    <div id="graffiti-sticker-fill">' + '     <input type="checkbox" id="graffiti-sticker-fill-control" />' + '     <label id="graffiti-sticker-fill-control-label" for="graffiti-sticker-fill-control" title="Fill shapes with chosen color">' + localizer.getString('SOLID_FILL') + '</label>' + '    </div>' + '    <div id="graffiti-sticker-hint">' + localizer.getString('SHIFT_KEY_ALIGN') + '</div>' + '  </div>' + '</div>', [{
          ids: ['graffiti-sticker-rightTriangle', 'graffiti-sticker-isocelesTriangle', 'graffiti-sticker-rectangle', 'graffiti-sticker-roundRectangle', 'graffiti-sticker-lineWithArrow', 'graffiti-sticker-checkmark', 'graffiti-sticker-xmark', 'graffiti-sticker-grid', 'graffiti-sticker-angle', 'graffiti-sticker-ribbon', 'graffiti-sticker-alpha', 'graffiti-sticker-beta', 'graffiti-sticker-sigma', 'graffiti-sticker-theta', 'graffiti-sticker-axis', 'graffiti-sticker-bomb', 'graffiti-sticker-trophy', 'graffiti-sticker-smiley', 'graffiti-sticker-horizontalBrackets', 'graffiti-sticker-verticalBrackets', 'graffiti-sticker-curlyBraces', 'graffiti-sticker-ellipse', 'graffiti-sticker-pi', 'graffiti-sticker-label', 'graffiti-sticker-custom'],
          event: 'click',
          fn: function fn(e) {
            var stickerId = $(e.target).attr('id');
            if (stickerId === undefined) {
              stickerId = $(e.target).parents('.graffiti-stickers-button').attr('id');
            }
            var cleanStickerId = stickerId.replace('graffiti-sticker-', '');
            console.log('Sticker chosen:', cleanStickerId);
            graffiti.toggleGraffitiSticker(cleanStickerId);
          }
        }, {
          ids: ['graffiti-stickers-header'],
          event: 'click',
          fn: function fn(e) {
            $('#graffiti-stickers-body,#graffiti-sticker-style-controls').slideToggle(200);
            if ($('#graffiti-stickers-expando').hasClass('graffiti-expando-closed')) {
              $('#graffiti-stickers-expando').removeClass('graffiti-expando-closed').addClass('graffiti-expando-open');
              setTimeout(function () {
                graffiti.windowResizeHandler({ force: true });
              }, 400);
            } else {
              $('#graffiti-stickers-expando').removeClass('graffiti-expando-open').addClass('graffiti-expando-closed');
            }
          }
        }, {
          ids: ['graffiti-sticker-fill-control', 'graffiti-sticker-fill-control-label'],
          event: 'click',
          fn: function fn(e) {
            state.updateDrawingState([{ change: 'fillOpacity',
              data: $('#graffiti-sticker-fill-control').is(':checked') ? 1 : 0 }]);
          }
        }]);

        graffiti.setupOneControlPanel('graffiti-access-skips', '<button class="btn btn-default" id="graffiti-access-skips-btn" title="' + localizer.getString('SKIPS_API') + '"></i>&nbsp; <span>' + localizer.getString('SKIPS_API') + '&nbsp; </span></button>', [{
          ids: ['graffiti-access-skips-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.editSkips();
          }
        }]);

        var compressTimeOnIcon = stickerLib.makeCompressTimeIcon('black');
        var compressTimeOffIcon = stickerLib.makeCompressTimeIcon('white');
        var absoluteSkipOnIcon = stickerLib.makeScan('black');
        var absoluteSkipOffIcon = stickerLib.makeScan('white');
        //const clearSkipsIcon = stickerLib.makeNoEntryIcon('red');
        var clearSkipsIcon = stickerLib.makeTrashIcon('black');

        graffiti.setupOneControlPanel('graffiti-skips-controls', '<div id="graffiti-skips-controls">' + '  <div id="graffiti-skips-controls-header"><span>' + localizer.getString('SKIPS_HEADER') + '</span></div>' + '  <div id="graffiti-skips-controls-body">' + '    <button class="btn btn-default graffiti-skips-on-btn" id="graffiti-skips-2x-on-btn" title="' + localizer.getString('SKIPS_2X_BTN') + '">2x</button>' + '    <button class="btn btn-default graffiti-skips-off-btn" id="graffiti-skips-2x-off-btn" title="' + localizer.getString('SKIPS_2X_BTN') + '">2x</button>' + '    <button class="btn btn-default graffiti-skips-on-btn" id="graffiti-skips-3x-on-btn" title="' + localizer.getString('SKIPS_3X_BTN') + '">3x</button>' + '    <button class="btn btn-default graffiti-skips-off-btn" id="graffiti-skips-3x-off-btn" title="' + localizer.getString('SKIPS_3X_BTN') + '">3x</button>' + '    <button class="btn btn-default graffiti-skips-on-btn" id="graffiti-skips-4x-on-btn" title="' + localizer.getString('SKIPS_4X_BTN') + '">4x</button>' + '    <button class="btn btn-default graffiti-skips-off-btn" id="graffiti-skips-4x-off-btn" title="' + localizer.getString('SKIPS_4X_BTN') + '">4x</button>' + '    <button class="btn btn-default graffiti-skips-on-btn" id="graffiti-skips-compress-on-btn" title="' + localizer.getString('SKIPS_COMPRESS_BTN') + '">' + compressTimeOnIcon + '</button>' + '    <button class="btn btn-default graffiti-skips-off-btn" id="graffiti-skips-compress-off-btn" title="' + localizer.getString('SKIPS_COMPRESS_BTN') + '">' + compressTimeOffIcon + '</button>' + '    <button class="btn btn-default graffiti-skips-on-btn" id="graffiti-skips-absolute-on-btn" title="' + localizer.getString('SKIPS_ABSOLUTE_BTN') + '">' + absoluteSkipOnIcon + '</button>' + '    <button class="btn btn-default graffiti-skips-off-btn" id="graffiti-skips-absolute-off-btn" title="' + localizer.getString('SKIPS_ABSOLUTE_BTN') + '">' + absoluteSkipOffIcon + '</button>' + '    <button class="btn btn-default" id="graffiti-skips-clear-btn" title="' + localizer.getString('SKIPS_CLEAR_BTN') + '">' + clearSkipsIcon + '</button>' + '  </div>' + '</div>', [{
          ids: ['graffiti-skips-2x-on-btn', 'graffiti-skips-2x-off-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.storeSkipRecord(state.SKIP_STATUS_2X);
          }
        }, {
          ids: ['graffiti-skips-3x-on-btn', 'graffiti-skips-3x-off-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.storeSkipRecord(state.SKIP_STATUS_3X);
          }
        }, {
          ids: ['graffiti-skips-4x-on-btn', 'graffiti-skips-4x-off-btn'],
          event: 'click',
          fn: function fn(e) {
            graffiti.storeSkipRecord(state.SKIP_STATUS_4X);
          }
        }, {
          ids: ['graffiti-skips-compress-on-btn', 'graffiti-skips-compress-off-btn'], // compress time to 2s
          event: 'click',
          fn: function fn(e) {
            graffiti.storeSkipRecord(state.SKIP_STATUS_COMPRESS);
          }
        }, {
          ids: ['graffiti-skips-absolute-on-btn', 'graffiti-skips-absolute-off-btn'], // absolutely skip over a section
          event: 'click',
          fn: function fn(e) {
            graffiti.storeSkipRecord(state.SKIP_STATUS_ABSOLUTE);
          }
        }, {
          ids: ['graffiti-skips-clear-btn'], // clear all skips
          event: 'click',
          fn: function fn(e) {
            graffiti.clearAllSkipsWithConfirm();
          }
        }]);

        graffiti.setupOneControlPanel('graffiti-access-api', '<button class="btn btn-default" id="graffiti-access-api-btn" title="' + localizer.getString('SAMPLE_API') + '"></i>&nbsp; <span>' + localizer.getString('SAMPLE_API') + '</span></button>', [{
          ids: ['graffiti-access-api-btn'],
          event: 'click',
          fn: function fn(e) {
            console.log('Graffiti: API key is:', graffiti.recordingAPIKey);
            graffiti.provideAPIKeyExamples();
          }
        }]);

        var lockConfigOn = $.extend({}, true, defaultIconConfiguration, { color: 'red' });
        var lockConfigOff = $.extend({}, true, defaultIconConfiguration, { color: 'green' });

        graffiti.setupOneControlPanel('graffiti-terminal-builder', '<div id="graffiti-terminal-builder-header"><div>Extras</div></div>' + '<div id="graffiti-terminal-builder-body">' + '  <div id="graffiti-insert-terminal-cell" title="' + localizer.getString('INSERT_GRAFFITI_TERMINAL_ALT_TAG') + '">' + stickerLib.makeTerminal({ width: 25 }) + '  </div>' + '  <div id="graffiti-insert-btn-cell" title="' + localizer.getString('INSERT_GRAFFITI_BUTTON_CELL_ALT_TAG') + '">' + stickerLib.makeButton({ width: 27, height: 22, contents: 'Run' }) + '  </div>' + '  <div id="graffiti-insert-terminal-suite" title="' + localizer.getString('INSERT_GRAFFITI_TERMINAL_SUITE_ALT_TAG') + '">' + '    <div>' + stickerLib.makeTerminal({ width: 25 }) + '</div> + ' + '    <div>' + stickerLib.makeButton({ width: 27, height: 22, contents: 'Run' }) + '</div>' + '  </div>' + '  <div class="graffiti-stickers-button" id="graffiti-toggle-markdown-lock" title="' + localizer.getString('ACTIVATE_LOCK_ALT_TAG') + '">' + '<span id="graffiti-locked-on">' + stickerLib.makeLock(lockConfigOn) + '</span>' + '<span id="graffiti-locked-off">' + stickerLib.makeLock(lockConfigOff) + '</span>' + '</div>' + '</div>', [{
          ids: ['graffiti-insert-btn-cell'],
          event: 'click',
          fn: function fn(e) {
            console.log('inserting graffiti button cell');
            var suite = graffiti.createGraffitiButtonAboveSelectedCell();
            utils.saveNotebook();
          }
        }, {
          ids: ['graffiti-insert-terminal-cell'],
          event: 'click',
          fn: function fn(e) {
            console.log('inserting graffiti terminal cell');
            var suite = terminalLib.createTerminalCellAboveSelectedCell();
            utils.saveNotebook();
          }
        }, {
          ids: ['graffiti-insert-terminal-suite'],
          event: 'click',
          fn: function fn(e) {
            console.log('inserting graffiti terminal suite');
            var suite = graffiti.createTerminalSuiteAboveSelectedCell();
            utils.saveNotebook();
          }
        }, {
          ids: ['graffiti-toggle-markdown-lock'],
          event: 'click',
          fn: function fn(e) {
            console.log('Toggle markdown lock');
            graffiti.toggleMarkdownLock();
            utils.saveNotebook();
          }
        }]);

        // Will return to this code soon. It simulates multiple creators (e.g. students) and switching between their different sets of Graffiti.
        /*
           const creatorsTitle = 'Graffitis by:'.split('').join('&nbsp;');
           graffiti.setupOneControlPanel('graffiti-creators-chooser',
           '<div id="graffiti-creators-chooser">' +
           ' <div id="graffiti-creators-chooser-title">' + creatorsTitle + '</div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h1.jpeg"></div>' +
           '    <div>Stacy M.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h2.jpeg"></div>' +
           '    <div>Bobby P.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h3.jpeg"></div>' +
           '    <div>Akarnam J.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h4.jpeg"></div>' +
           '    <div>James R.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h5.jpeg"></div>' +
           '    <div>Amanda M.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h6.jpeg"></div>' +
           '    <div>Aimee E.</div>' +
           ' </div>' +
           ' <div class="graffiti-creator">' +
           '    <div><img src="images/headshots/h7.jpeg"></div>' +
           '    <div>Lena Y.</div>' +
           ' </div>' +
           ' <div id="graffiti-creators-chooser-show-all">' +
           '  <input type="checkbox" id="chooser-show-all" /><label for="chooser-show-all">&nbsp;Show All Graffitis</label>' +
           ' </div>' +
           '</div>'
           );
         */
      },

      setupMarkdownLocks: function setupMarkdownLocks() {
        graffiti.oldUnrender = graffiti.MarkdownCell.prototype.unrender;
        graffiti.MarkdownCell.prototype.unrender = function () {
          console.log('Unrender fired.');
          var cell = Jupyter.notebook.get_selected_cell();
          if (cell !== undefined) {
            var cellId = utils.getMetadataCellId(cell.metadata);
            var markdownLocked = utils.getNotebookGraffitiConfigEntry('markdownLocked');
            if (markdownLocked === true || terminalLib.isTerminalCell(cellId)) {
              console.log('Not unrendering markdown cell, since Graffiti lock in place or is terminal cell.');
            } else {
              graffiti.oldUnrender.apply(cell, _arguments);
            }
          }
        };
      },

      toggleMarkdownLock: function toggleMarkdownLock() {
        var markdownLocked = utils.getNotebookGraffitiConfigEntry('markdownLocked');
        var isLocked = markdownLocked === true ? true : false;
        var verb = isLocked ? localizer.getString('UNLOCK_VERB') : localizer.getString('LOCK_VERB');
        var bodyText = isLocked ? localizer.getString('UNLOCK_BODY') : localizer.getString('LOCK_BODY');
        dialog.modal({
          title: verb + ' ' + localizer.getString('LOCK_CONFIRM'),
          body: bodyText,
          sanitize: false,
          buttons: {
            'OK': {
              click: function click(e) {
                console.log('Graffiti: You clicked ok, you want to toggle the lock');
                var markdownLocked = utils.getNotebookGraffitiConfigEntry('markdownLocked');
                var isLocked = markdownLocked === true ? true : false;
                if (isLocked) {
                  $('#graffiti-locked-off').show();
                  $('#graffiti-locked-on').hide();
                } else {
                  $('#graffiti-locked-off').hide();
                  $('#graffiti-locked-on').show();
                }
                utils.setNotebookGraffitiConfigEntry('markdownLocked', !isLocked);
                utils.saveNotebook();
              }
            },
            'Cancel': { click: function click(e) {
                console.log('Graffiti: you cancelled:', $(e.target).parent());
              } }
          }
        });
      },

      setSitePanelScrollTop: function setSitePanelScrollTop(scrollTop) {
        // console.log('Setting sitepanel to scrolltop:', newScrollTop);
        graffiti.sitePanel.scrollTop(scrollTop);
      },

      showControlPanels: function showControlPanels(panels) {
        graffiti.controlPanelsShell.children().hide();
        graffiti.controlPanelIds['graffiti-control-panel-title'].css({ display: 'flex' }); // the title bar is always shown
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = panels[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            controlPanelId = _step3.value;

            // console.log('Graffiti: showing panel:', controlPanelId);
            graffiti.controlPanelIds[controlPanelId].show();
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      },

      updateActiveTakeId: function updateActiveTakeId(recordingCellId, recordingKey, activeTakeId) {
        storage.updateSingleManifestRecordingField(recordingCellId, recordingKey, 'activeTakeId', activeTakeId);
        state.setPlayableMovie('cursorActivity', recordingCellId, recordingKey);
        graffiti.updateTakesPanel(recordingCellId, recordingKey);
      },

      updateTakesPanel: function updateTakesPanel(recordingCellId, recordingKey) {
        var recording = state.getManifestSingleRecording(recordingCellId, recordingKey);
        var activeTakeId = recording.activeTakeId;
        if (activeTakeId === undefined || recording.takes === undefined) {
          return false;
        }
        //console.log('we got these takes:', recording.takes);
        var renderedTakes = '';
        var sortedRecs = _.sortBy($.map(recording.takes, function (val, key) {
          return $.extend(true, {}, val, { key: key });
        }), 'createDate');
        //console.log('sorted recs are:', sortedRecs);
        var recIndex = void 0,
            recIndexZerobased = void 0,
            createDateFormatted = void 0,
            renderedDate = void 0,
            rec = void 0,
            takeClass = void 0;
        for (recIndex = sortedRecs.length; recIndex > 0; --recIndex) {
          recIndexZerobased = recIndex - 1;
          rec = sortedRecs[recIndexZerobased];
          renderedDate = localizer.getString('RECORDED_ON') + ': ' + new Date(rec.createDate);
          takeClass = rec.key === activeTakeId ? 'graffiti-take-selected' : 'graffiti-take-unselected';
          renderedTakes += '<div ' + 'class="' + takeClass + ' graffiti-take-item" ' + 'id="' + rec.key + '" ' + 'recordingCellId="' + recordingCellId + '" ' + 'recordingKey="' + recordingKey + '" ' + 'title="' + renderedDate + '">' + recIndex + '</div>';
        }
        $('#graffiti-takes-list').html(renderedTakes);
        return true;
      },

      updateControlPanels: function updateControlPanels(cm) {
        // When we transition to a new state, control panel tweaks need to be made
        var activity = state.getActivity();
        // console.log('Graffiti: updateControlPanels, activity:', activity);
        var accessLevel = state.getAccessLevel();
        var outerControlHidden = graffiti.outerControlPanel.css('display') === 'none';
        if (accessLevel === 'view') {
          if (activity !== 'idle') {
            if (outerControlHidden) {
              //console.trace('fadeIn 1');
              // fadeins/fadeouts cause race conditions when you interrupt a movie in progress
              //graffiti.outerControlPanel.fadeIn(graffiti.panelFadeTime);
              graffiti.outerControlPanel.show();
            }
          } else if (state.getPlayableMovie('tip') === undefined && state.getPlayableMovie('api') === undefined && state.getPlayableMovie('cursorActivity') === undefined || activity !== 'notifying') {
            if (!outerControlHidden) {
              //console.trace('fadeout');
              // fadeins/fadeouts cause race conditions when you interrupt a movie in progress
              //graffiti.outerControlPanel.fadeOut(graffiti.panelFadeTime);
              graffiti.outerControlPanel.hide();
            }
            return;
          }
        } else {
          if (outerControlHidden) {
            //console.trace('fadeIn 2');
            // fadeins/fadeouts cause race conditions when you interrupt a movie in progress
            //graffiti.outerControlPanel.fadeIn(graffiti.panelFadeTime);
            graffiti.outerControlPanel.show();
          }
        }

        // These controls will need to be updated in a variety of activities so easiest just to do their updates in all cases.
        if (state.getMute()) {
          graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-sound-on-btn').hide().parent().find('#graffiti-sound-off-btn').show();
        } else {
          graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-sound-off-btn').hide().parent().find('#graffiti-sound-on-btn').show();
        }
        var currentPlaySpeed = state.getCurrentPlaySpeed();
        graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rewind-btn').attr({ title: localizer.getString('SKIP_BACK') + ' ' + graffiti.rewindAmt + localizer.getString('SECONDS') });
        graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-forward-btn').attr({ title: localizer.getString('SKIP_FORWARD') + ' ' + graffiti.rewindAmt + ' ' + localizer.getString('SECONDS') });
        switch (currentPlaySpeed) {
          case 'scanActive':
          case 'scanInactive':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidscan-on-btn').hide().parent().find('#graffiti-rapidscan-off-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidplay-off-btn').hide().parent().find('#graffiti-rapidplay-on-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rewind-btn').attr({ title: localizer.getString('SKIP_BACK') + ' ' + localizer.getString('TO_PREVIOUS_SENTENCE') });
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-forward-btn').attr({ title: localizer.getString('SKIP_FORWARD') + ' ' + localizer.getString('TO_NEXT_SENTENCE') });
            break;
          case 'rapid':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidscan-off-btn').hide().parent().find('#graffiti-rapidscan-on-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidplay-on-btn').hide().parent().find('#graffiti-rapidplay-off-btn').show();
            break;
          case 'regular':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidplay-off-btn').hide().parent().find('#graffiti-rapidplay-on-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-rapidscan-off-btn').hide().parent().find('#graffiti-rapidscan-on-btn').show();
            break;
        }

        if (state.getEditingSkips()) {
          graffiti.controlPanelIds['graffiti-skips-controls'].find('.graffiti-skips-off-btn').hide().parent().find('.graffiti-skips-on-btn').show();
          var skipStatus = state.getSkipStatus();
          //console.log('skipStatus:', skipStatus);
          switch (skipStatus) {
            case state.SKIP_STATUS_COMPRESS:
              graffiti.controlPanelIds['graffiti-skips-controls'].find('#graffiti-skips-compress-off-btn').show().parent().find('#graffiti-skips-compress-on-btn').hide();
              break;
            case state.SKIP_STATUS_2X:
              graffiti.controlPanelIds['graffiti-skips-controls'].find('#graffiti-skips-2x-off-btn').show().parent().find('#graffiti-skips-2x-on-btn').hide();
              break;
            case state.SKIP_STATUS_3X:
              graffiti.controlPanelIds['graffiti-skips-controls'].find('#graffiti-skips-3x-off-btn').show().parent().find('#graffiti-skips-3x-on-btn').hide();
              break;
            case state.SKIP_STATUS_4X:
              graffiti.controlPanelIds['graffiti-skips-controls'].find('#graffiti-skips-4x-off-btn').show().parent().find('#graffiti-skips-4x-on-btn').hide();
              break;
            case state.SKIP_STATUS_ABSOLUTE:
              graffiti.controlPanelIds['graffiti-skips-controls'].find('#graffiti-skips-absolute-off-btn').show().parent().find('#graffiti-skips-absolute-on-btn').hide();
              break;
          }
        }

        var visibleControlPanels = void 0;
        switch (activity) {
          case 'idle':
            // Check if anchor or head of current selection is inside an existing recording token set. Controls will be different if so.
            var activeCell = void 0;
            if (cm === undefined) {
              activeCell = Jupyter.notebook.get_selected_cell();
            } else {
              activeCell = utils.findCellByCodeMirror(cm);
            }
            graffiti.selectedTokens = utils.findSelectionTokens(activeCell, graffiti.tokenRanges, state);
            var selectedTokens = graffiti.selectedTokens;
            //console.log('Graffiti: selectedTokens:', selectedTokens);
            graffiti.highlightIntersectingGraffitiRange();
            var isMarkdownCell = activeCell.cell_type === 'markdown';
            if (isMarkdownCell && !selectedTokens.isIntersecting) {
              // swap out the CREATE and RECORD strings depending on what type of new Graffiti could possibly be made
              $('#graffiti-create-btn').attr({ title: localizer.getString('CREATE_2') });
              $('#graffiti-create-btn span').text(localizer.getString('CREATE_2'));
            } else {
              $('#graffiti-create-btn').attr({ title: localizer.getString('CREATE_1') });
              $('#graffiti-create-btn span').text(localizer.getString('CREATE_1'));
            }

            if (selectedTokens.noTokensPresent || !isMarkdownCell && selectedTokens.range.selectionStart === selectedTokens.range.selectionEnd && !selectedTokens.isIntersecting || isMarkdownCell && activeCell.rendered) {
              //console.log('Graffiti: no tokens present, or no text selected.');
              visibleControlPanels = ['graffiti-notifier', 'graffiti-terminal-builder']; // hide all control panels if in view only mode and not play mode
              if (isMarkdownCell) {
                if (!activeCell.rendered) {
                  graffiti.setNotifier('<div>' + localizer.getString('SELECT_SOME_TEXT_MARKDOWN') + '</div>');
                } else {
                  graffiti.setNotifier('<div>' + localizer.getString('EDIT_IN_MARKDOWN_CELL') + '</div>');
                }
              } else {
                graffiti.setNotifier('<div>' + localizer.getString('SELECT_SOME_TEXT_PLAIN') + '</div>');
              }
            } else if (accessLevel === 'view') {
              console.log('Graffiti: view only');
              visibleControlPanels = ['graffiti-playback-controls']; // hide all control panels if in view only mode and not play mode
            } else {
              visibleControlPanels = ['graffiti-record-controls'];
              graffiti.controlPanelIds['graffiti-record-controls'].find('#graffiti-begin-recording-btn').hide().parent().find('#graffiti-begin-rerecording-btn').hide().parent().find('#graffiti-remove-btn').hide();
              graffiti.controlPanelIds['graffiti-record-controls'].find('#graffiti-create-btn').show().parent().find('#graffiti-edit-btn').hide();
              if (selectedTokens.isIntersecting) {
                // console.log('Graffiti: updating recording controls');
                graffiti.highlightIntersectingGraffitiRange();
                graffiti.controlPanelIds['graffiti-record-controls'].find('#graffiti-create-btn').hide().parent().find('#graffiti-edit-btn').show().parent().find('#graffiti-begin-recording-btn').show().parent().find('#graffiti-remove-btn').show();
                //console.log('selectedTokens:', selectedTokens);
                state.clearPlayableMovie('cursorActivity');
                if (selectedTokens.hasMovie) {
                  var recordingCellId = selectedTokens.recordingCellId;
                  var _recordingKey2 = selectedTokens.recordingKey;
                  state.setPlayableMovie('cursorActivity', recordingCellId, _recordingKey2);
                  graffiti.recordingAPIKey = utils.composeGraffitiId(recordingCellId, _recordingKey2);
                  visibleControlPanels.push('graffiti-access-skips');
                  visibleControlPanels.push('graffiti-access-api');
                  visibleControlPanels.push('graffiti-notifier');
                  if (graffiti.updateTakesPanel(recordingCellId, _recordingKey2)) {
                    visibleControlPanels.push('graffiti-takes-controls');
                    graffiti.setNotifier('<div>' + localizer.getString('YOU_CAN_PLAY_VIA_TOOLTIP') + '</div>');
                  } else {
                    graffiti.setNotifier('<div>' + localizer.getString('NO_MOVIE_RECORDED_YET') + '</div>');
                  }

                  //console.log('this recording has a movie');
                  graffiti.controlPanelIds['graffiti-record-controls'].find('#graffiti-begin-recording-btn').hide().parent().find('#graffiti-begin-rerecording-btn').show();
                  // This "play" link is not reliable because its info is only updated by mousing over tooltips, yet you may be editing
                  // a graffiti that you did not show the tooltip on, making it play the wrong movie. Therefore we instruct users to use the tooltip to play the movie.
                  /*
                  graffiti.setNotifier('<div>You can <span class="graffiti-notifier-link" id="graffiti-idle-play-link">play</span> this movie any time.</div>',
                                       [
                                         {
                                           ids: ['graffiti-idle-play-link'],
                                           event: 'click',
                                           fn: (e) => {
                                             state.setPlayableMovie('cursorActivity', recordingCellId, recordingKey);
                                             graffiti.loadAndPlayMovie('cursorActivity');
                                           }
                                         },
                                       ]);
                  */
                }
              }
            }
            graffiti.showControlPanels(visibleControlPanels);
            break;
          case 'playing':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-play-btn').hide().parent().find('#graffiti-pause-btn').show();
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-narrator-info').hide();
            var narratorName = state.getNarratorInfo('name');
            var narratorPicture = state.getNarratorInfo('picture');
            if (narratorName !== undefined || narratorPicture !== undefined) {
              graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-narrator-info').show();
              if (narratorPicture !== undefined) {
                graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-narrator-pic').html('<img src="' + narratorPicture + '" />');
              }
              if (narratorName !== undefined) {
                graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-narrator-name').html(narratorName);
              }
            }
            visibleControlPanels = ['graffiti-playback-controls'];
            $('#graffiti-skips-display-bar').hide();
            if (state.getEditingSkips()) {
              visibleControlPanels.push('graffiti-skips-controls');
              $('#graffiti-skips-display-bar').show();
            }
            graffiti.showControlPanels(visibleControlPanels);
            graffiti.setNotifier('<div>' + localizer.getString('PAUSE_TO_INTERACT') + '</div>' + '<div>' + localizer.getString('CANCEL_MOVIE_PLAYBACK_1') + '</div>', [{
              ids: ['graffiti-pause-link'],
              event: 'click',
              fn: function fn(e) {
                graffiti.togglePlayback();
              }
            }, {
              ids: ['graffiti-cancel-playback-link'],
              event: 'click',
              fn: function fn(e) {
                graffiti.cancelPlayback({ cancelAnimation: true });
              }
            }]);
            break;
          case 'playbackPaused':
            graffiti.controlPanelIds['graffiti-playback-controls'].find('#graffiti-pause-btn').hide().parent().find('#graffiti-play-btn').show();
            visibleControlPanels = ['graffiti-playback-controls'];
            $('#graffiti-skips-display-bar').hide();
            if (state.getEditingSkips()) {
              visibleControlPanels.push('graffiti-skips-controls');
              $('#graffiti-skips-display-bar').show();
            }
            graffiti.showControlPanels(visibleControlPanels);
            if (state.getSetupForReset()) {
              graffiti.setNotifier('<div>' + localizer.getString('PLAY_MOVIE_AGAIN') + '</div>' + '<div>' + localizer.getString('CANCEL_MOVIE_PLAYBACK_2') + '</div>', [{
                ids: ['graffiti-restart-play-link'],
                event: 'click',
                fn: function fn(e) {
                  graffiti.togglePlayback();
                }
              }, {
                ids: ['graffiti-cancel-playback-postreset-link'],
                event: 'click',
                fn: function fn(e) {
                  graffiti.cancelPlayback({ cancelAnimation: true });
                }
              }]);
            } else {
              graffiti.setNotifier('<div>' + localizer.getString('CONTINUE_MOVIE_PLAYBACK') + '</div>' + '<div>' + localizer.getString('CANCEL_MOVIE_PLAYBACK_3') + '</div>', [{
                ids: ['graffiti-continue-play-link'],
                event: 'click',
                fn: function fn(e) {
                  graffiti.togglePlayback();
                }
              }, {
                ids: ['graffiti-cancel-playback-prereset-link'],
                event: 'click',
                fn: function fn(e) {
                  graffiti.cancelPlayback({ cancelAnimation: true });
                }
              }]);
            }
            break;
          case 'graffiting':
            graffiti.showControlPanels(['graffiti-finish-edit-controls']);
            graffiti.setNotifier('<div>' + localizer.getString('ENTER_AND_SAVE') + '</div>' + '<div>' + localizer.getString('CANCEL_CHANGES_1') + '</div>', [{
              ids: ['graffiti-cancel-graffiting-link'],
              event: 'click',
              fn: function fn(e) {
                graffiti.finishGraffiti(false);
              }
            }]);
            break;
          case 'recordingPending':
            graffiti.showControlPanels([]);
            graffiti.setNotifier('<div>' + localizer.getString('CLICK_BEGIN_MOVIE_RECORDING') + '</div>' + '<div>' + localizer.getString('CANCEL_RECORDING_1') + '</div>', [{
              ids: ['graffiti-cancel-recording-pending-link'],
              event: 'click',
              fn: function fn(e) {
                graffiti.finishGraffiti(false);
              }
            }, {
              ids: ['graffiti-cancel-recording-pending-link'],
              event: 'click',
              fn: function fn(e) {
                graffiti.cancelPendingRecording();
              }
            }]);
            break;
          case 'recording':
            graffiti.showControlPanels(['graffiti-recording-controls', 'graffiti-recording-pen-controls', 'graffiti-stickers-controls']);
            graffiti.setNotifier('<div>' + localizer.getString('ACTIVITIES_BEING_RECORDED') + '</div>' + '<div>' + localizer.getString('CANCEL_RECORDING_2') + '</div>', [{
              ids: ['graffiti-end-recording-link'],
              event: 'click',
              fn: function fn(e) {
                graffiti.toggleRecording();
              }
            }, {
              ids: ['graffiti-cancel-recording-link'],
              event: 'click',
              fn: function fn(e) {
                graffiti.cancelRecording();
              }
            }]);
            break;
          case 'notifying':
            // Just showing notifier alone. Used when prompting user to play a graffiti with the notifier
            graffiti.showControlPanels(['graffiti-notifier']);
            break;
          case 'scrubbing':
            // do nothing special while scrubbing
            break;
          default:
            console.log('Graffiti: updateControlPanels hit unknown activity:', activity);
            break;
        }

        graffiti.performWindowResizeCheck();
      },

      updateControlPanelPosition: function updateControlPanelPosition(hardPosition) {
        if (hardPosition !== undefined) {
          var newPositionPx = { top: hardPosition.top + 'px', left: hardPosition.left + 'px' };
          graffiti.outerControlPanel.css(newPositionPx);
        } else {
          if (state.getControlPanelDragging()) {
            var position = state.getPointerPosition();
            var offset = state.getControlPanelDragOffset();
            var controlPanelWidth = graffiti.outerControlPanel.width();
            var controlPanelHeight = graffiti.outerControlPanel.height();
            var panelBbox = graffiti.sitePanel[0].getBoundingClientRect();
            var constrainedLeft = Math.min(panelBbox.right - controlPanelWidth - 20, Math.max(0, position.x - offset.left));
            var constrainedTop = Math.min(panelBbox.bottom - controlPanelHeight - 20, Math.max(0, position.y - offset.top));
            var newPosition = { left: constrainedLeft, top: constrainedTop };
            var _newPositionPx = { top: newPosition.top + 'px', left: newPosition.left + 'px' };
            graffiti.outerControlPanel.css(_newPositionPx);
          }
        }
      },

      initInteractivity: function initInteractivity() {
        graffiti.notebookContainer.click(function (e) {
          // console.log('Graffiti: clicked container');
          if (state.getActivity() === 'recordingPending') {
            console.log('Graffiti: Now starting movie recording');
            graffiti.toggleRecording();
          }
          return false;
        });
        audio.setAudioStorageCallback(storage.storeMovie);
        graffiti.addCMEvents();
        setTimeout(function () {
          graffiti.setupBackgroundEvents();
        }, 500); // this timeout avoids too-early rendering of hidden recorder controls

        graffiti.refreshGraffitiTooltipsDebounced = _.debounce(graffiti.refreshGraffitiTooltips, 100, false);
        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltipsDebounced();
        graffiti.setupControlPanels();
        graffiti.updateControlPanels();
        graffiti.setupDrawingScreen();
        graffiti.setupSavingScrim();
        graffiti.playAutoplayGraffiti(); // play any autoplay graffiti if there is one set up
        graffiti.setupMarkdownLocks();

        terminalLib.init(graffiti.handleTerminalsEvents);

        /*
                let body = '<div>Enter the Graffiti Hub Key to import Graffiti into this notebook.</div>';
                body += '<div style="font-weight:bold;margin-top:15px;">Key: <input type="text" value="R5a7Hb"/ width="60"></div>';
                body += '<div style="font-style:italic; color:green;">(Author: N. Vishalyam)</div>';
                dialog.modal({
                  title: 'Import Graffiti from GraffitiHub?',
                  body: body,
                  sanitize:false,
                  buttons: {
                    'Import': {
                      click: (e) => {
                        console.log('Graffiti: You clicked Import');
                      }
                    },
                    'Cancel': {
                      click: (e) => {
                        console.log('Graffiti: You clicked Cancel');
                      }
                    }
                  }
                });
        */
      },

      setGraffitiPenColor: function setGraffitiPenColor(colorVal) {
        var activePenType = state.getDrawingPenAttribute('type');
        if (activePenType === 'highlight') {
          if (colorVal === 'black') {
            console.log('Graffiti: black is not choosable when using the highlighter');
            return;
          }
        }

        $('#graffiti-recording-colors-shell div').removeClass('graffiti-recording-color-active');
        console.log('Graffiti: you clicked color:', colorVal);
        state.updateDrawingState([{ change: 'color', data: colorVal }]);
        $('#graffiti-recording-color-' + colorVal).addClass('graffiti-recording-color-active');
      },

      activateGraffitiPen: function activateGraffitiPen(penType) {
        if (!(state.getActivity() == 'recording')) {
          return; // Pens can only be used while recording
        }
        if (penType === undefined) {
          penType = 'line';
        }
        graffiti.showDrawingScreen();
        $('.graffiti-active-pen').removeClass('graffiti-active-pen');
        var penControl = $('#graffiti-' + penType + '-pen');
        if (penControl.length > 0 && !penControl.hasClass('btn')) {
          penControl = penControl.parents('.btn');
        }
        penControl.addClass('graffiti-active-pen');
        // Turn on drawing (if it's not already on), and activate this pen type
        state.updateDrawingState([{ change: 'drawingModeActivated', data: true }, { change: 'stickerType', data: undefined }, { change: 'penType', data: penType }]);
      },

      deactivateAllPens: function deactivateAllPens() {
        graffiti.setGraffitiPenColor('black');
        state.updateDrawingState([{ change: 'drawingModeActivated', data: false }, { change: 'stickerType', data: undefined }, { change: 'penType', data: undefined }]);
        $('.graffiti-active-sticker').removeClass('graffiti-active-sticker');
        $('.graffiti-active-pen').removeClass('graffiti-active-pen');
      },

      toggleGraffitiPen: function toggleGraffitiPen(penType) {
        if (!(state.getActivity() == 'recording')) {
          return; // Pens can only be used while recording
        }
        var activePenType = state.getDrawingPenAttribute('type');
        graffiti.hideLabelInputBoxes();
        if (activePenType !== penType) {
          // Activate a new active pen, unless this pen is already active, in which case, deactivate it
          graffiti.activateGraffitiPen(penType);
          $('.graffiti-active-sticker').removeClass('graffiti-active-sticker');
        } else {
          // turn off the active pen and drawing
          $('.graffiti-active-pen').removeClass('graffiti-active-pen');
          // Disable drawing
          state.updateDrawingState([{ change: 'drawingModeActivated', data: false }, { change: 'stickerType', data: undefined }, { change: 'penType', data: undefined }]);
          graffiti.hideDrawingScreen();
        }

        if (activePenType === 'highlight') {
          // When switching from highlight to pen or eraser, always go to black color because
          // usual color for highlighter is yellow which looks crappy in the line mode.
          graffiti.setGraffitiPenColor('black');
        }
      },

      toggleGraffitiSticker: function toggleGraffitiSticker(stickerType) {
        if (!(state.getActivity() == 'recording')) {
          return; // Stickers can only be used while recording
        }
        var activePenType = state.getDrawingPenAttribute('type');
        var activeStickerType = state.getDrawingPenAttribute('stickerType');
        if (activeStickerType !== stickerType) {
          // Activate a new sticker, unless sticker is already active, in which case, deactivate it
          graffiti.hideLabelInputBoxes();
          graffiti.clearAnyActiveStickerStages();
          graffiti.showDrawingScreen();
          // Deactivate any active pen
          $('.graffiti-active-pen').removeClass('graffiti-active-pen');
          var stickerControl = $('#graffiti-sticker-' + stickerType);
          $('.graffiti-active-sticker').removeClass('graffiti-active-sticker');
          stickerControl.addClass('graffiti-active-sticker');
          state.updateDrawingState([{ change: 'drawingModeActivated', data: true }, { change: 'stickerType', data: stickerType }, { change: 'penType', data: 'sticker' }]);
          if (activePenType === 'highlight') {
            // If we were highlighting, it was probably yellow. we probably don't want that color
            // when switching back to stickering.
            graffiti.setGraffitiPenColor('black');
          }
        } else {
          // Turn off the active sticker control.
          graffiti.hideLabelInputBoxes();
          $('.graffiti-active-sticker').removeClass('graffiti-active-sticker');
          // Disable stickering
          state.updateDrawingState([{ change: 'drawingModeActivated', data: false }, { change: 'stickerType', data: undefined }, { change: 'penType', data: undefined }]);
          graffiti.hideDrawingScreen();
        }
      },

      cancelRapidPlay: function cancelRapidPlay() {
        console.log('Graffiti: cancelRapidPlay');
        state.setCurrentPlaySpeed('regular');
        audio.updateAudioPlaybackRate();
        graffiti.updateControlPanels();
      },

      toggleRapidPlay: function toggleRapidPlay(opts) {
        var forceOn = false;
        if (state.rapidIsOn() && !opts.scan || state.scanningIsOn() && opts.scan) {
          graffiti.cancelRapidPlay();
        } else {
          console.log('Graffiti: activating rapidPlay/rapidScan');
          if (opts.scan) {
            var currentSpeakingStatus = state.scanForSpeakingStatus();
            if (currentSpeakingStatus) {
              state.setCurrentPlaySpeed('scanInactive');
            } else {
              state.setCurrentPlaySpeed('scanActive'); // turn on rapid scan immediately if rabbit icon is activated during a silent period
            }
          } else {
            state.setCurrentPlaySpeed('rapid');
          }
          audio.updateAudioPlaybackRate();
          graffiti.updateControlPanels();
        }
      },

      dimGraffitiCursor: function dimGraffitiCursor() {
        graffiti.graffitiCursorShell.css({ opacity: 0.1 });
      },

      undimGraffitiCursor: function undimGraffitiCursor() {
        graffiti.graffitiCursorShell.show().css({ opacity: 1.0 });
      },

      activateTerminalGraffitiCursor: function activateTerminalGraffitiCursor() {
        if (graffiti.graffitiNormalCursor.is(':visible')) {
          //console.log('activate terminal cursor');
          graffiti.graffitiTerminalCursor.show();
          graffiti.graffitiNormalCursor.hide();
        }
      },

      activateNormalGraffitiCursor: function activateNormalGraffitiCursor() {
        if (graffiti.graffitiTerminalCursor.is(':visible')) {
          //console.log('activate normal cursor');
          graffiti.graffitiNormalCursor.show();
          graffiti.graffitiTerminalCursor.hide();
        }
      },

      drawingScreenHandler: function drawingScreenHandler(e) {
        var drawingActivity = state.getDrawingStateField('drawingActivity');
        if (state.getActivity() === 'recording') {
          if (e.type === 'mousedown') {
            console.log('Graffiti: drawingScreenHandler: mousedown');
            var wasFading = state.getDrawingStateField('drawingActivity') === 'fade';
            // console.log('Graffiti: wasFading:', wasFading);
            graffiti.resetTemporaryCanvases();
            state.disableDrawingFadeClock();
            var stickerType = state.getDrawingPenAttribute('stickerType');
            drawingActivity = 'draw';
            var viewInfo = state.getViewInfo();
            if (stickerType !== undefined) {
              // console.log('Graffiti: mousedown with stickerType:', stickerType);
              drawingActivity = 'sticker';
              if (wasFading) {
                // terminate any fading in progress when drawing a new sticker
                graffiti.resetStickerCanvases('temporary');
                graffiti.wipeTemporaryStickerDomCanvases();
              }
              var currentPointerPosition = state.getPointerPosition();
              var penType = state.getDrawingPenAttribute('type');
              var minSize = penType === 'lineWithArrow' ? 1 : graffiti.minimumStickerSize;
              state.updateDrawingState([{ change: 'mouseDownPosition',
                data: {
                  x: currentPointerPosition.x,
                  y: currentPointerPosition.y
                }
              }, { change: 'positions',
                data: {
                  positions: {
                    start: { x: currentPointerPosition.x, y: currentPointerPosition.y },
                    end: { x: currentPointerPosition.x + minSize, y: currentPointerPosition.y + minSize }
                  }
                }
              }, { change: 'cellId',
                data: viewInfo.cellId
              }]);

              // If we are using a label-type sticker, then put the label input box where the mousedown happened.
              if (stickerType === 'label') {
                graffiti.showLabelInputBox();
              }
            }
            state.updateDrawingState([{ change: 'drawingModeActivated', data: true }, { change: 'isDown', data: true }, { change: 'drawingActivity', data: drawingActivity }, { change: 'opacity', data: state.getMaxDrawingOpacity() }, { change: 'downInMarkdown', data: viewInfo.inMarkdownCell }, { change: 'downInPromptArea', data: viewInfo.inPromptArea }]);
          } else if (e.type === 'mouseup' || e.type === 'mouseleave') {
            // console.log('Graffiti: drawingScreenHandler: ', e.type);
            if (drawingActivity === 'sticker' && e.type === 'mouseup') {
              graffiti.clearAnyActiveStickerStages();
            }
            if (state.getDrawingPenAttribute('isDown')) {
              state.updateDrawingState([{ change: 'isDown', data: false }]);
              if (state.getDrawingPenAttribute('permanence') === 'temporary') {
                state.startDrawingFadeClock();
              }
            }
          } else if (e.type === 'keydown') {
            console.log('Graffiti: drawingScreen got key:', e);
          }
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      },

      resetDrawingColor: function resetDrawingColor() {
        $('#graffiti-recording-colors-shell div').removeClass('graffiti-recording-color-active');
        $('#graffiti-recording-color-black').addClass('graffiti-recording-color-active');
        state.updateDrawingState([{ change: 'color', data: 'black' }]);
      },

      resetDrawingPen: function resetDrawingPen() {
        $('.graffiti-active-pen').removeClass('graffiti-active-pen');
        graffiti.toggleGraffitiPen(undefined, 'deactivate'); // turn off the active pen
      },

      showDrawingScreen: function showDrawingScreen() {
        graffiti.drawingScreen.show().focus();
      },

      hideDrawingScreen: function hideDrawingScreen() {
        graffiti.drawingScreen.hide();
      },

      // Inspired by https://www.codicode.com/art/how_to_draw_on_a_html5_canvas_with_a_mouse.aspx
      // and : http://perfectionkills.com/exploring-canvas-drawing-techniques/
      setupDrawingScreen: function setupDrawingScreen() {
        // Note that the tabindex is the key to capture the keydown/up events, 
        // cf https://stackoverflow.com/questions/3149362/capture-key-press-or-keydown-event-on-div-element
        var graffitiDrawingScreen = $('<div tabindex="0" id="graffiti-drawing-screen"></div>');
        graffiti.drawingScreen = graffitiDrawingScreen.prependTo(graffiti.notebookContainer);
        var notebookHeight = $('#notebook').outerHeight(true);
        graffiti.drawingScreen.css({ height: notebookHeight + 'px' });
        graffiti.drawingScreen.bind('mousedown mouseup mouseleave keydown keyup', function (e) {
          graffiti.drawingScreenHandler(e);
        });
      },

      placeLabelInputBox: function placeLabelInputBox() {
        var viewInfo = state.getViewInfo();
        var cell = utils.findCellByCellId(viewInfo.cellId);
        var elem = $(cell.element[0]);
        var labelInputBox = elem.find('.graffiti-label-input');
        if (labelInputBox.length === 0) {
          labelInputBoxElem = $('<div tabindex="0" class="graffiti-label-input"><input type="text" maxlength="50" placeholder="' + localizer.getString('ENTER_LABEL') + '"/></div>');
          labelInputBox = labelInputBoxElem.appendTo(elem);
          labelInputBox.bind('keydown keyup', function (e) {
            graffiti.handleLabelInput(e);
          });
        }
        var penColor = state.getDrawingPenAttribute('color');
        if (penColor === 'white') {
          labelInputBox.find('input').css({ color: 'black' });
        } else {
          labelInputBox.find('input').css({ color: penColor });
        }
        return labelInputBox;
      },

      showLabelInputBox: function showLabelInputBox() {
        graffiti.clearAnyActiveStickerStages();
        graffiti.hideLabelInputBoxes();
        var labelInputBox = graffiti.placeLabelInputBox(); // make sure there is a label box
        var currentPointerPosition = state.getPointerPosition();
        var viewInfo = state.getViewInfo();
        var adjustedPosition = utils.subtractCoords(viewInfo.outerCellRect, currentPointerPosition);
        var verticalAdjust = parseInt(labelInputBox.height() / 2);
        adjustedPosition.y = adjustedPosition.y - verticalAdjust;
        labelInputBox.show().css({ left: adjustedPosition.x + 'px', top: adjustedPosition.y + 'px' }).find('input').val('').focus();
        var outerCellRect = viewInfo.outerCellRect;
        var mouseDownPosition = state.getDrawingPenAttribute('mouseDownPosition');
        state.updateDrawingState([{ change: 'positions',
          data: {
            positions: {
              start: { x: mouseDownPosition.x - outerCellRect.left, y: mouseDownPosition.y - outerCellRect.top - verticalAdjust },
              end: { x: mouseDownPosition.x + 1 - outerCellRect.left, y: mouseDownPosition.y + 1 - outerCellRect.top - verticalAdjust }
            }
          }
        }, { change: 'downInPromptArea',
          data: viewInfo.inPromptArea
        }, { change: 'downInMarkdown',
          data: viewInfo.downInMarkdown
        }, { change: 'promptWidth',
          data: viewInfo.promptWidth
        }]);
      },

      hideLabelInputBoxes: function hideLabelInputBoxes() {
        console.log('Graffiti: Ending labelling');
        $('.graffiti-label-input').val('').hide();
      },

      handleLabelInput: function handleLabelInput(e) {
        if (e.which === 9) {
          e.preventDefault(); // don't let tab key buble up
        }
        e.stopPropagation(); // make sure keystrokes in the label input box don't bubble up to jupyter
        if (e.type === 'keyup') {
          if (state.getActivity() === 'recording') {
            // If user hits return tab, we "accept" this label, which simply means hide the input box. The rendered label should be underneath.
            state.disableDrawingFadeClock();
            var inputBox = $(e.target);
            var labelText = inputBox.val();
            state.updateDrawingState([{ change: 'label', data: '' + labelText }]);
            var drawingPermanence = state.getDrawingPenAttribute('permanence');
            graffiti.updateStickerDisplayWhenRecording(drawingPermanence);
            state.storeHistoryRecord('stickers');
            //console.log('keycode',e.which);
            if (e.which === 13 || e.which === 9) {
              graffiti.hideLabelInputBoxes();
              state.startDrawingFadeClock();
            }
          }
        }
      },

      setupSavingScrim: function setupSavingScrim() {
        var graffitiSavingScrim = $('<div id="graffiti-saving-scrim"><div>Saving Graffiti Recording. Please wait...</div></div>');
        graffiti.savingScrim = graffitiSavingScrim.prependTo(graffiti.notebookContainer);
      },

      showSavingScrim: function showSavingScrim() {
        graffiti.savingScrim.css({ display: 'flex' });
      },

      hideSavingScrim: function hideSavingScrim() {
        graffiti.savingScrim.css({ display: 'none' });
      },

      resizeCanvases: function resizeCanvases() {
        var canvasTypes = ['permanent', 'temporary'];
        var cellElement = void 0,
            cellRect = void 0,
            canvasStyle = void 0,
            canvas = void 0,
            cellCanvas = void 0;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = canvasTypes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var canvasType = _step4.value;
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = Object.keys(graffiti.canvases[canvasType])[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var cellId = _step5.value;

                cell = utils.findCellByCellId(cellId);
                if (cell !== undefined) {
                  canvas = graffiti.canvases[canvasType][cellId];
                  cellCanvas = canvas.canvas;
                  cellElement = cell.element[0];
                  cellRect = cellElement.getBoundingClientRect();
                  if (parseInt(cellRect.width) !== parseInt(cellCanvas.width) || parseInt(cellRect.height) !== parseInt(cellCanvas.height)) {
                    canvasStyle = {
                      width: cellRect.width + 'px',
                      height: cellRect.height + 'px'
                    };
                    canvas.div.css(canvasStyle);
                    cellCanvas.width = cellRect.width;
                    cellCanvas.height = cellRect.height;
                    canvas.cellRect = cellRect;
                    //console.trace('resized height of ',cellId, 'to ', cellRect.height);
                  }
                }
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        var notebookHeight = $('#notebook').outerHeight(true);
        graffiti.drawingScreen.css({ height: notebookHeight + 'px' });
      },

      // Remove "active" attribute from whatever sticker might have rt now.
      // Pretty inefficient, good enough for time being though.
      clearAnyActiveStickerStages: function clearAnyActiveStickerStages() {
        var stickerStage = void 0,
            stickerIndex = void 0,
            sticker = void 0,
            canvasTypes = ['temporary', 'permanent'];
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = canvasTypes[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var canvasType = _step6.value;
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = Object.keys(graffiti.stickers[canvasType])[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var cellId = _step7.value;

                stickerStage = graffiti.stickers[canvasType][cellId];
                if (stickerStage.stickers !== undefined) {
                  for (var _stickerIndex = 0; _stickerIndex < stickerStage.stickers.length; ++_stickerIndex) {
                    sticker = stickerStage.stickers[_stickerIndex];
                    if (sticker.active) {
                      stickerStage.stickers[_stickerIndex].active = false;
                    }
                  }
                }
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7.return) {
                  _iterator7.return();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6.return) {
              _iterator6.return();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      },

      resetGraffitiStickerStage: function resetGraffitiStickerStage(cellId, stickerPermanence) {
        if (!graffiti.stickers[stickerPermanence].hasOwnProperty(cellId)) {
          graffiti.stickers[stickerPermanence][cellId] = {
            stickers: [],
            canvas: undefined
          };
        }
      },

      placeStickerCanvas: function placeStickerCanvas(cellId, stickerPermanence) {
        graffiti.resetGraffitiStickerStage(cellId, stickerPermanence); // put the sticker stage record into memory if we need to before placing a canvas in the dom
        if (graffiti.stickers[stickerPermanence][cellId].canvas !== undefined) {
          return;
        }
        var cell = utils.findCellByCellId(cellId);
        var cellElement = cell.element[0];
        var cellRect = cellElement.getBoundingClientRect();

        // Note that we inline all these styles because to include them from a stylesheet causes rendering jumps.
        var stickerDivId = 'graffiti-sticker-' + cellId;
        graffiti.stickers[stickerPermanence][cellId].canvas = $('<div class="graffiti-sticker-outer graffiti-canvas-type-' + stickerPermanence + '" id="' + stickerDivId + '" ' + 'style="width:' + parseInt(cellRect.width) + 'px;' + 'height:' + parseInt(cellRect.height) + 'px;' + 'position:absolute;left:0;top:0;">' + '</div>').appendTo(cellElement);
      },

      placeCanvas: function placeCanvas(cellId, drawingPermanence) {
        var cell = utils.findCellByCellId(cellId);
        var cellElement = $(cell.element[0]);
        var cellRect = cellElement[0].getBoundingClientRect();
        if (graffiti.canvases[drawingPermanence][cellId] !== undefined) {
          //console.log('not adding ' + drawingPermanence + ' canvas to this cell, already exists.');
          return cellRect;
        }
        // console.log('Graffiti: placing ', drawingPermanence, 'canvas for cellId:', cellId);
        $('<div class="graffiti-canvas-outer graffiti-canvas-type-' + drawingPermanence + '"><canvas /></div>').appendTo(cellElement);
        var newCellCanvasDiv = cellElement.find('.graffiti-canvas-outer:last');
        var newCellCanvas = newCellCanvasDiv.find('canvas')[0];
        var ctx = newCellCanvas.getContext("2d");

        var canvasStyle = {
          width: cellRect.width + 'px',
          height: cellRect.height + 'px'
        };
        newCellCanvasDiv.css(canvasStyle);
        newCellCanvas.width = cellRect.width;
        newCellCanvas.height = cellRect.height;

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.lineJoin = "round";
        ctx.lineCap = "round";

        graffiti.canvases[drawingPermanence][cellId] = {
          div: newCellCanvasDiv,
          canvas: newCellCanvas,
          ctx: ctx,
          cellRect: cellRect
        };
        return cellRect;
      },

      setCanvasStyle: function setCanvasStyle(cellId, penType, penDashStyle, canvasColor, canvasPermanence) {
        var canvas = graffiti.canvases[canvasPermanence][cellId];
        var ctx = canvas.ctx;
        if (canvasColor === undefined) {
          canvasColor = 'black'; // default to black lines if not set in older recordings before color was supported.
        }
        if (penType === 'highlight') {
          if (canvasColor === 'black') {
            canvasColor = 'yellow';
          }
          ctx.lineWidth = 15;
          ctx.shadowBlur = 35;
          ctx.globalAlpha = 0.5;
        } else {
          // lines are default although if erase activated, we will ignore this style and use clearRect
          //console.log('canvas color:', canvasColor);
          ctx.shadowBlur = 1;
          ctx.lineWidth = 1.75;
          ctx.globalAlpha = 1.0;
          ctx.setLineDash([]);
          if (penDashStyle === 'dashed') {
            ctx.setLineDash([2, 10]); /* first parm = dash, second parm = spaces btwn */
            ctx.lineDashOffset = 2;
            ctx.lineWidth = 3;
            ctx.globalAlpha = 0.5;
          }
        }
        var rawColorVal = '#' + graffiti.penColors[canvasColor];
        // Hack test
        if (rawColorVal === undefined) {
          console.log('Graffiti: warning, rawColorVal is undefined');
          rawColorVal = '#000000';
        }
        ctx.strokeStyle = rawColorVal;
        ctx.shadowColor = rawColorVal;
      },

      clearCanvas: function clearCanvas(canvasType, cellId) {
        var canvas = graffiti.canvases[canvasType][cellId];
        var ctx = canvas.ctx;
        var cellRect = canvas.cellRect;
        ctx.clearRect(0, 0, cellRect.width, cellRect.height);
      },

      clearCanvases: function clearCanvases(canvasType) {
        //console.log('clearCanvases');
        if (canvasType === 'all') {
          var _iteratorNormalCompletion8 = true;
          var _didIteratorError8 = false;
          var _iteratorError8 = undefined;

          try {
            for (var _iterator8 = Object.keys(graffiti.canvases)[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
              var _canvasType = _step8.value;
              var _iteratorNormalCompletion9 = true;
              var _didIteratorError9 = false;
              var _iteratorError9 = undefined;

              try {
                for (var _iterator9 = Object.keys(graffiti.canvases[_canvasType])[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                  var cellId = _step9.value;

                  graffiti.clearCanvas(_canvasType, cellId);
                }
              } catch (err) {
                _didIteratorError9 = true;
                _iteratorError9 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion9 && _iterator9.return) {
                    _iterator9.return();
                  }
                } finally {
                  if (_didIteratorError9) {
                    throw _iteratorError9;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError8 = true;
            _iteratorError8 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion8 && _iterator8.return) {
                _iterator8.return();
              }
            } finally {
              if (_didIteratorError8) {
                throw _iteratorError8;
              }
            }
          }
        } else {
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = undefined;

          try {
            for (var _iterator10 = Object.keys(graffiti.canvases[canvasType])[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var _cellId = _step10.value;

              graffiti.clearCanvas(canvasType, _cellId);
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10.return) {
                _iterator10.return();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }
        }
        $('.graffiti-canvas-type-temporary').css({ opacity: state.getMaxDrawingOpacity() });
      },

      resetTemporaryCanvases: function resetTemporaryCanvases() {
        console.log('Graffiti: resetTemporaryCanvases.');
        var opacity = state.getDrawingStateField('opacity');
        var maxOpacity = state.getMaxDrawingOpacity();
        if (opacity < maxOpacity) {
          console.log('Graffiti: Clearing temp canvases, since fade was in progress.');
          graffiti.clearCanvases('temporary');
          state.updateDrawingState([{ change: 'drawingActivity', data: 'wipe' }]);
          state.storeHistoryRecord('drawings');
          state.updateDrawingState([{ change: 'opacity', data: maxOpacity }]);
          state.disableDrawingFadeClock();
        }
      },

      // If a cell is deleted by jupyter we need to forget any the canvases we were tracking for it.
      removeCanvasRecordsForCell: function removeCanvasRecordsForCell(cellId) {
        delete graffiti.canvases['permanent'][cellId];
        delete graffiti.stickers['permanent'][cellId];
        delete graffiti.canvases['temporary'][cellId];
        delete graffiti.stickers['temporary'][cellId];
      },

      updateDrawingOpacity: function updateDrawingOpacity() {
        var maxOpacity = state.getMaxDrawingOpacity();
        // Check for fadeouts
        var currentOpacity = state.getDrawingStateField('opacity');
        var opacityInfo = state.calculateDrawingOpacity();
        switch (opacityInfo.status) {
          case 'max':
            if (currentOpacity !== maxOpacity) {
              // only go to max if not already set to max
              var drawingActivity = state.getDrawingStateField('drawingActivity');
              state.updateDrawingState([{ change: 'drawingActivity', data: drawingActivity }, { change: 'opacity', data: maxOpacity }]);
            }
            break;
          case 'fade':
            state.updateDrawingState([{ change: 'drawingActivity', data: 'fade' }, { change: 'opacity', data: opacityInfo.opacity }]);
            state.storeHistoryRecord('drawings');
            $('.graffiti-canvas-type-temporary').css({ opacity: opacityInfo.opacity });
            break;
          case 'fadeDone':
            graffiti.resetTemporaryCanvases();
            graffiti.resetStickerCanvases('temporary');
            break;
        }
      },

      updateDrawingDisplay: function updateDrawingDisplay(cellId, ax, ay, bx, by, drawingPenType, drawingPermanence) {
        //console.log('updateDrawingDisplay, drawingPermanence:', drawingPermanence);
        if (graffiti.canvases[drawingPermanence].hasOwnProperty(cellId)) {
          var ctx = graffiti.canvases[drawingPermanence][cellId].ctx;
          if (drawingPenType === 'eraser') {
            var eraseBuffer = 25;
            ctx.clearRect(ax - eraseBuffer / 2, ay - eraseBuffer / 2, eraseBuffer, eraseBuffer);
          } else {
            //console.log('updateDrawingDisplay:', ax, ay, bx, by);
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(bx, by);
            ctx.closePath();
            ctx.stroke();
          }
        }
      },

      wipeTemporaryStickerDomCanvases: function wipeTemporaryStickerDomCanvases() {
        $('.graffiti-sticker-outer.graffiti-canvas-type-temporary').empty();
      },

      wipeAllStickerDomCanvases: function wipeAllStickerDomCanvases() {
        //console.log('wipeAllStickerDomCanvases');
        $('.graffiti-sticker-outer').empty();
      },

      resetStickerCanvases: function resetStickerCanvases(typeOverride) {
        var sticker = void 0,
            canvasTypes = typeOverride === undefined ? ['temporary', 'permanent'] : [typeOverride];
        var _iteratorNormalCompletion11 = true;
        var _didIteratorError11 = false;
        var _iteratorError11 = undefined;

        try {
          for (var _iterator11 = canvasTypes[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
            var canvasType = _step11.value;
            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
              for (var _iterator12 = Object.keys(graffiti.stickers[canvasType])[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var cellId = _step12.value;

                sticker = graffiti.stickers[canvasType][cellId];
                if (sticker.canvas !== undefined) {
                  sticker.canvas.empty();
                }
                sticker.stickers = [];
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError11 = true;
          _iteratorError11 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion11 && _iterator11.return) {
              _iterator11.return();
            }
          } finally {
            if (_didIteratorError11) {
              throw _iteratorError11;
            }
          }
        }
      },

      processPositionsForCellTypeScaling: function processPositionsForCellTypeScaling(record, type) {
        var positions = void 0,
            scalarX = void 0,
            scalarY = void 0,
            positionsRaw = void 0,
            cell = void 0,
            cellId = void 0,
            cellRects = void 0,
            denomWidth = void 0,
            denomHeight = void 0;
        // console.log('scalarX', scalarX, 'scalarY', scalarY);
        if (type === 'cursor') {
          // Scale the cursor position. The cell the cursor is hovering over is in the cellId field, unless the
          // drawingActivity was 'sticker' when this record was made, in which case we'll scale to the cell under
          // the starting coordinates of the sticker to match what happens when we scale the sticker itself.
          if (record.stickerInfo !== undefined) {
            cellId = record.stickerInfo.cellId;
            denomWidth = record.stickerInfo.width;
            denomHeight = record.stickerInfo.height;
          } else {
            cellId = record.cellId;
            denomWidth = record.innerCellRect.width;
            denomHeight = record.innerCellRect.height;
          }
          cell = utils.findCellByCellId(cellId);
          cellRects = utils.getCellRects(cell);
          scalarX = cellRects.innerCellRect.width / denomWidth;
          scalarY = cellRects.innerCellRect.height / denomHeight;
          positionsRaw = { x: record.x, y: record.y };
          if (!record.inMarkdownCell) {
            // in code cells, or if pen went down in prompt area, just use positions verbatim
            positions = { start: { x: positionsRaw.x, y: positionsRaw.y } };
          } else {
            if (record.inPromptArea || record.downInPromptArea) {
              // in prompt area only scale y value
              positions = { start: { x: positionsRaw.x, y: positionsRaw.y * scalarY } };
            } else {
              // in markdown area, scale full position.
              positions = { start: { x: (positionsRaw.x - record.promptWidth) * scalarX + cellRects.promptRect.width,
                  y: positionsRaw.y * scalarY } };
            }
          }
          //if (record.drawingActivity === 'sticker') {
          //console.log('cellId', cellId, 'hoverCellId', record.hoverCell.metadata.graffitiCellId, 'positions', positions.start.y, 'scalarX', scalarX, 'scalarY', scalarY);
          //}
        } else {
          //
          // Drawing and sticker scaling code begins here.
          //
          positionsRaw = { start: { x: record.positions.start.x, y: record.positions.start.y },
            end: { x: record.positions.end.x, y: record.positions.end.y } };
          cell = utils.findCellByCellId(record.cellId);
          cellRects = utils.getCellRects(cell);
          scalarX = cellRects.innerCellRect.width / record.innerCellRect.width;
          scalarY = cellRects.innerCellRect.height / record.innerCellRect.height;
          // If this drawing/sticker started in a markdown cell, we will attempt to scale both x and y coords in the inner_cell rect area but 
          // NOT the prompt area.
          if (record.pen.downInMarkdown) {
            if (record.pen.downInPromptArea) {
              //console.log('inPromptArea and did not start in prompt area');
              // if pen went down in prompt area of a markdown cell, scale the Y value only. 
              positions = { start: { x: positionsRaw.start.x,
                  y: positionsRaw.start.y * scalarY },
                end: { x: positionsRaw.end.x,
                  y: positionsRaw.end.y * scalarY }
              };
            } else {
              if (record.pen.inPromptArea) {
                scalarX = 1;
              }
              // In the inner_cell, scale both x and y. First subtract the historical prompt width, then scale the value up/down, and then
              // add the current prompt width to calculate the final X (UNLESS we are drawing in the prompt area, then do not scale in X).
              // Y is just scaled by change in cell height.
              positions = { start: { x: (positionsRaw.start.x - record.promptWidth) * scalarX + cellRects.promptRect.width,
                  y: positionsRaw.start.y * scalarY },
                end: { x: (positionsRaw.end.x - record.promptWidth) * scalarX + cellRects.promptRect.width,
                  y: positionsRaw.end.y * scalarY }
              };
            }
          } else {
            // we don't scale anything if we started in a code cell. Just leave everything as recorded.
            positions = {
              start: { x: positionsRaw.start.x, y: positionsRaw.start.y },
              end: { x: positionsRaw.end.x, y: positionsRaw.end.y }
            };
          }
        }
        return positions;
      },

      // calculate correct offsets based on innerCellRect / dx, dy etc
      drawStickersForCell: function drawStickersForCell(cellId, record) {
        var activity = state.getActivity();
        var currentlyRecording = activity === 'recording';
        var canvasTypes = ['temporary', 'permanent'],
            canvasElements = {};
        var canvasType = void 0,
            newInnerHtml = {},
            finalInnerHtml = void 0;
        var _iteratorNormalCompletion13 = true;
        var _didIteratorError13 = false;
        var _iteratorError13 = undefined;

        try {
          for (var _iterator13 = canvasTypes[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
            canvasType = _step13.value;

            graffiti.placeStickerCanvas(cellId, canvasType);
            canvasElements[canvasType] = { elem: graffiti.stickers[canvasType][cellId].canvas };
            canvasElements[canvasType].opacityOverride = canvasElements[canvasType].elem.css('opacity');
            newInnerHtml[canvasType] = [];
          }
        } catch (err) {
          _didIteratorError13 = true;
          _iteratorError13 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion13 && _iterator13.return) {
              _iterator13.return();
            }
          } finally {
            if (_didIteratorError13) {
              throw _iteratorError13;
            }
          }
        }

        var stickerPermanence = void 0,
            stickerX = void 0,
            stickerY = void 0,
            fillOpacity = void 0,
            width = void 0,
            height = void 0,
            stickerWidth = void 0,
            stickerHeight = void 0,
            generatedStickerHtml = void 0,
            generatedStickerElem = void 0,
            pen = void 0,
            type = void 0,
            positions = void 0,
            p1x = void 0,
            p1y = void 0,
            p2x = void 0,
            p2y = void 0,
            stickersRecords = void 0,
            dimensions = void 0,
            stickerProcessingRecord = void 0;
        if (record !== undefined) {
          stickersRecords = record.stickersRecords;
        } else {
          stickerPermanence = state.getDrawingPenAttribute('permanence');
          stickersRecords = graffiti.stickers[stickerPermanence][cellId].stickers;
        }
        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = stickersRecords[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var stickerRecord = _step14.value;

            pen = stickerRecord.pen;
            type = pen.stickerType;
            stickerPermanence = pen.permanence;
            if (currentlyRecording) {
              positions = stickerRecord.positions;
              fillOpacity = state.getDrawingPenAttribute('fillOpacity');
              //console.log('Recording, Computed fillOpacity:', fillOpacity);
            } else {
              stickerRecord.cellId = cellId;
              // console.log('Graffiti: sticker rendering.  record', record, 'stickerRecord', stickerRecord, 'stickerProcessingRecord', stickerProcessingRecord);
              positions = graffiti.processPositionsForCellTypeScaling(stickerRecord, 'positions');
              fillOpacity = stickerRecord.pen.fillOpacity;
            }
            if (type === 'lineWithArrow') {
              stickerX = positions.start.x;
              stickerY = positions.start.y;
            } else {
              stickerX = Math.min(positions.start.x, positions.end.x);
              stickerY = Math.min(positions.start.y, positions.end.y);
            }
            stickerWidth = Math.abs(positions.end.x - positions.start.x);
            stickerHeight = Math.abs(positions.end.y - positions.start.y);
            var transformX = Math.sign(positions.end.x - positions.start.x);
            var transformY = Math.sign(positions.end.y - positions.start.y);
            var cssTransform = 'scale(' + transformX + ',' + transformY + ')';
            if (stickerRecord.stickerOnGrid) {
              // Make things square when shift key is down, except for certain items,
              // where shift key means align with a fixed grid and fixed graffiti size.
              if (type === 'checkmark' || type === 'xmark' || type === 'bomb' || type === 'trophy' || type === 'smiley' || type === 'pi' || type === 'alpha' || type === 'beta' || type === 'sigma' || type == 'theta' || type === 'angle') {
                stickerX = parseInt(positions.start.x / graffiti.minimumStickerSizeWithBuffer) * graffiti.minimumStickerSizeWithBuffer;
                stickerY = parseInt(positions.start.y / graffiti.minimumStickerSizeWithBuffer) * graffiti.minimumStickerSizeWithBuffer;
                stickerWidth = graffiti.minimumStickerSize;
                cssTransform = undefined; // don't allow transforms while on the fixed grid
              }
              stickerHeight = stickerWidth;
            }
            dimensions = {
              x: stickerX,
              y: stickerY,
              width: stickerWidth,
              height: stickerHeight
            };
            //console.log('Processing stickerRecord:', stickerRecord);
            //console.log('Drawing to dimensions:', dimensions);
            generatedStickerHtml = undefined;
            //console.log('processing type:', type);
            switch (type) {
              case 'rectangle':
                generatedStickerHtml = stickerLib.makeRectangle({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  strokeWidth: 4,
                  dimensions: dimensions,
                  fillOpacity: fillOpacity
                });
                break;
              case 'roundRectangle':
                generatedStickerHtml = stickerLib.makeRectangle({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  strokeWidth: 4,
                  rx: 8,
                  ry: 8,
                  dimensions: dimensions,
                  fillOpacity: fillOpacity
                });
                break;
              case 'isocelesTriangle':
                generatedStickerHtml = stickerLib.makeIsocelesTriangle({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  strokeWidth: 4,
                  dimensions: dimensions,
                  cssTransform: cssTransform,
                  fillOpacity: fillOpacity
                });
                break;
              case 'rightTriangle':
                generatedStickerHtml = stickerLib.makeRightTriangle({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  strokeWidth: 4,
                  cssTransform: cssTransform,
                  fillOpacity: fillOpacity
                });
                break;
              case 'ellipse':
                generatedStickerHtml = stickerLib.makeEllipse({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  strokeWidth: 3,
                  dimensions: dimensions,
                  fillOpacity: fillOpacity,
                  buffer: 4
                });
                break;
              case 'checkmark':
                generatedStickerHtml = stickerLib.makeCheckmark({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions
                });
                break;
              case 'xmark':
                generatedStickerHtml = stickerLib.makeXmark({
                  strokeWidth: 2,
                  color: 'red',
                  dashed: pen.dash,
                  dimensions: dimensions
                });
                break;
              case 'grid':
                generatedStickerHtml = stickerLib.makeGrid({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  cssTransform: cssTransform,
                  strokeWidth: 1
                });
                break;
              case 'axis':
                generatedStickerHtml = stickerLib.makeAxis({
                  strokeWidth: 2,
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'bomb':
                generatedStickerHtml = stickerLib.makeBomb({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'trophy':
                generatedStickerHtml = stickerLib.makeTrophy({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'smiley':
                generatedStickerHtml = stickerLib.makeSmiley({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  cssTransform: cssTransform,
                  strokeWidth: 2
                });
                break;
              case 'ribbon':
                generatedStickerHtml = stickerLib.makeRibbon({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  strokeWidth: 2,
                  dimensions: dimensions
                });
                break;
              case 'horizontalBrackets':
                generatedStickerHtml = stickerLib.makeHorizontalBrackets({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  strokeWidth: 3,
                  dimensions: dimensions
                });
                break;
              case 'verticalBrackets':
                generatedStickerHtml = stickerLib.makeVerticalBrackets({
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  strokeWidth: 3,
                  dimensions: dimensions
                });
                break;
              case 'curlyBraces':
                generatedStickerHtml = stickerLib.makeSymmetricCurlyBraces({
                  color: pen.color,
                  dashed: pen.dash,
                  strokeWidth: 3,
                  dimensions: dimensions
                });
                break;
              case 'pi':
                generatedStickerHtml = stickerLib.makePi({
                  color: pen.color,
                  dashed: pen.dash,
                  strokeWidth: 2,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'alpha':
                generatedStickerHtml = stickerLib.makeAlpha({
                  color: pen.color,
                  dashed: pen.dash,
                  strokeWidth: 2,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'beta':
                generatedStickerHtml = stickerLib.makeBeta({
                  color: pen.color,
                  dashed: pen.dash,
                  strokeWidth: 2,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'sigma':
                generatedStickerHtml = stickerLib.makeSigma({
                  strokeWidth: 1,
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'theta':
                generatedStickerHtml = stickerLib.makeTheta({
                  strokeWidth: 1,
                  color: pen.color,
                  fill: pen.fill,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'angle':
                generatedStickerHtml = stickerLib.makeAngle({
                  strokeWidth: 1,
                  fill: pen.fill,
                  color: pen.color,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  cssTransform: cssTransform
                });
                break;
              case 'lineWithArrow':
                generatedStickerHtml = stickerLib.makeLine({
                  color: pen.color,
                  dashed: pen.dash,
                  dimensions: dimensions,
                  endpoints: { p1: { x: positions.start.x, y: positions.start.y }, p2: { x: positions.end.x, y: positions.end.y } },
                  lineStartOffset: { x: 0, y: 0 },
                  usesArrow: true,
                  arrowHeadSize: 6
                });
                break;
              case 'label':
                // If we are recording, on mouseup, we will put a centered input box on screen. Otherwise render this label.
                // If not recording, render a text label scaled by the size of this box.
                if (pen.label !== undefined) {
                  dimensions.width = 15 * pen.label.length; // large enough for the label
                  dimensions.height = 18;
                  generatedStickerHtml = stickerLib.makeLabelHtml({
                    color: pen.color,
                    label: pen.label,
                    dimensions: dimensions,
                    opacity: 1.0
                  });
                  //console.log('generatedStickerHtml:', generatedStickerHtml);
                }
                break;
              case 'custom':
                var stickerImageUrl = void 0;
                if (currentlyRecording) {
                  var recordingCellInfo = state.getRecordingCellInfo();
                  stickerImageUrl = recordingCellInfo.recordingRecord.stickerImageUrl;
                } else {
                  stickerImageUrl = state.getStickerImageUrl();
                }
                if (stickerImageUrl !== undefined) {
                  generatedStickerHtml = stickerLib.makeCustom({
                    dimensions: dimensions,
                    imageUrl: stickerImageUrl,
                    cssTransform: cssTransform
                  });
                  canvasElements[stickerPermanence].opacityOverride = 1.0; // make parent opacity maximum so child images are fully visible
                } else {
                  // Sticker not set or not found; just draw grey rect to let user know
                  generatedStickerHtml = stickerLib.makeRectangle({
                    color: 'lightgrey',
                    fill: pen.fill,
                    dashed: 'dashed',
                    strokeWidth: 3,
                    dimensions: dimensions,
                    fillOpacity: 0
                  });
                }
                break;
            }
            if (generatedStickerHtml !== undefined) {
              newInnerHtml[stickerPermanence].push(generatedStickerHtml);
            }
          }
          // Finally, render all sticker html now that it's built.
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14.return) {
              _iterator14.return();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }

        var _iteratorNormalCompletion15 = true;
        var _didIteratorError15 = false;
        var _iteratorError15 = undefined;

        try {
          for (var _iterator15 = canvasTypes[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
            canvasType = _step15.value;

            if (newInnerHtml[canvasType].length > 0) {
              // only redraw canvas that has elements drawn during this frame
              canvasElements[canvasType].elem.empty();
              finalInnerHtml = newInnerHtml[canvasType].join('');
              canvasElements[canvasType].elem.html(finalInnerHtml);
              canvasElements[canvasType].elem.css({ opacity: canvasElements[canvasType].opacityOverride });
            }
          }
        } catch (err) {
          _didIteratorError15 = true;
          _iteratorError15 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion15 && _iterator15.return) {
              _iterator15.return();
            }
          } finally {
            if (_didIteratorError15) {
              throw _iteratorError15;
            }
          }
        }
      },

      updateStickerDisplayWhenRecording: function updateStickerDisplayWhenRecording(stickerPermanence) {
        var cellId = state.getDrawingStateField('cellId');
        graffiti.resetGraffitiStickerStage(cellId, stickerPermanence);

        // Replace active sticker if there is one, or add a new active sticker
        var stickers = graffiti.stickers[stickerPermanence][cellId].stickers;
        var stickerRecord = state.createStickerRecord();
        // console.log('stickerRecord', stickerRecord);
        //console.log('stickerRecordEnd:', stickerRecord.positions.start.x, stickerRecord.positions.start.y, stickerRecord.positions.end.x, stickerRecord.positions.end.y);
        stickerRecord.active = true;
        var replaced = false;
        if (stickers.length > 0) {
          var lastSticker = stickers.length - 1;
          if (stickers[lastSticker].active) {
            graffiti.stickers[stickerPermanence][cellId].stickers[lastSticker] = stickerRecord;
            replaced = true;
          }
        }
        if (!replaced) {
          stickers.push(stickerRecord);
        }

        // Store the state for later redrawing.
        state.storeStickersStateForCell(graffiti.stickers[stickerPermanence][cellId].stickers, cellId);
        // Now rerender all stickers for this cell
        graffiti.drawStickersForCell(cellId);
      },

      // This fn is called on mousemove, which means fade counts always reset, and we clear the temporary ink completely if it was part way through a fade
      updateDrawingDisplayWhenRecording: function updateDrawingDisplayWhenRecording(ax, ay, bx, by, viewInfo) {
        if (state.getActivity() === 'recording') {
          if (state.getDrawingPenAttribute('isDown')) {
            var drawingActivity = state.getDrawingStateField('drawingActivity');
            var drawingPermanence = state.getDrawingPenAttribute('permanence');
            var cellId = drawingActivity === 'sticker' ? state.getDrawingStateField('cellId') : viewInfo.cellId;
            var cellRect = graffiti.placeCanvas(cellId, drawingPermanence);
            var drawingRecordType = void 0;
            if (drawingActivity === 'sticker') {
              drawingRecordType = 'stickers';
              var mouseDownPosition = state.getDrawingPenAttribute('mouseDownPosition');
              state.updateDrawingState([{ change: 'positions',
                data: {
                  positions: {
                    start: { x: mouseDownPosition.x - cellRect.left, y: mouseDownPosition.y - cellRect.top },
                    end: { x: bx - cellRect.left, y: by - cellRect.top }
                  }
                }
              }, { change: 'inPromptArea',
                data: viewInfo.inPromptArea
              }, { change: 'promptWidth',
                data: viewInfo.promptWidth
              }]
              // note that we don't change the sticker cellId during mousemove. It's set once at mousedown and kept constant until mouse up.
              );
              graffiti.updateStickerDisplayWhenRecording(drawingPermanence);
            } else {
              drawingRecordType = 'drawings';
              var drawingPenType = state.getDrawingPenAttribute('type');
              var drawingPenDash = state.getDrawingPenAttribute('dash');
              var drawingPenColor = state.getDrawingPenAttribute('color');
              // console.log('drawingActivity', drawingActivity, drawingPenType);
              graffiti.setCanvasStyle(viewInfo.cellId, drawingPenType, drawingPenDash, drawingPenColor, drawingPermanence);
              graffiti.updateDrawingDisplay(viewInfo.cellId, ax - cellRect.left, ay - cellRect.top, bx - cellRect.left, by - cellRect.top, drawingPenType, drawingPermanence);
              state.updateDrawingState([{ change: 'positions',
                data: {
                  positions: {
                    start: { x: ax - cellRect.left, y: ay - cellRect.top },
                    end: { x: bx - cellRect.left, y: by - cellRect.top }
                  }
                }
              }, { change: 'cellId',
                data: viewInfo.cellId
              }, { change: 'inPromptArea',
                data: viewInfo.inPromptArea
              }, { change: 'promptWidth',
                data: viewInfo.promptWidth
              }]);
            }
            state.storeHistoryRecord(drawingRecordType);
          }
        }
      },

      // Rerun all drawings up to time t. Used after scrubbing.
      redrawAllDrawings: function redrawAllDrawings(targetTime) {
        if (targetTime === undefined) {
          targetTime = state.getTimePlayedSoFar();
        }
        graffiti.clearCanvases('all');
        var lastDrawFrameIndex = state.getIndexUpToTime('drawings', targetTime);
        if (lastDrawFrameIndex !== undefined) {
          // First, final last opacity reset before the target time. We will start redrawing drawings from this point forward.
          var record = void 0;
          for (var index = 0; index < lastDrawFrameIndex; ++index) {
            record = state.getHistoryItem('drawings', index);
            graffiti.updateDrawingCore(record);
          }
        }
      },

      redrawAllDrawingsWhenRecording: function redrawAllDrawingsWhenRecording() {
        if (state.getActivity() !== 'recording') {
          return;
        }
        var lastDrawFrameIndex = state.getLastFrameIndex('drawings');
        if (lastDrawFrameIndex !== undefined) {
          var record = void 0;
          for (var index = 0; index < lastDrawFrameIndex; ++index) {
            record = state.getHistoryItem('drawings', index);
            graffiti.updateDrawingCore(record);
          }
        }
      },

      // Extract any tooltip commands. Here's some examples:
      //
      // %%button_name Watch Movie
      // %%narrator_pic images/adarsh_pic.png
      // %%narrator_name Adarsh
      // %%caption_pic ![Adarsh](images/adarsh_pic.png)
      // %%caption  What is Naive Bayes?
      //

      extractTooltipCommands: function extractTooltipCommands(markdown) {
        //const commandParts = markdown.match(/^\s*%%(([^\s]*)(\s*)(.*))$/mig);
        var commandParts = markdown.split(/\n/);
        var partsRecord = void 0,
            part = void 0,
            subParts = void 0,
            cleanedPart = void 0;
        if (commandParts === null) return undefined;
        if (commandParts.length > 0) {
          partsRecord = {
            buttonName: undefined,
            captionPic: '',
            captionVideo: undefined,
            caption: '',
            playback_pic: undefined,
            autoplay: 'never',
            hideTooltip: false,
            playOnClick: false,
            saveToFile: undefined // may be array of save_to_file directives
          };
          for (var i = 0; i < commandParts.length; ++i) {
            part = $.trim(commandParts[i]);
            //console.log('part:', part);
            if (part.indexOf('%%') === 0 && part.indexOf('%% ') !== 0) {
              cleanedPart = part.replace('%%', '');
              subParts = $.trim(cleanedPart).split(/\s+/);
              if (subParts.length > 0) {
                var subPart0 = subParts[0];
                if (subPart0 === 'button_name' || subPart0 === 'caption' || subPart0 === 'caption_pic' || subPart0 === 'caption_video_id' || subPart0 === 'narrator_name' || subPart0 === 'narrator_pic' || subPart0 === 'custom_sticker') {
                  if (subParts.length === 1) {
                    // not enough parameters given, silently ignore
                    continue;
                  }
                }
                var subPart1 = subParts[1];
                var subPart1ToEnd = subParts.slice(1).join(' ');
                switch (subPart0) {
                  case 'comment':
                    break; // we just ignore these. Used to instruct content creators how to use the editing tip cells.
                  case 'title_tag':
                    state.setTooltipTitleTag(subPart1ToEnd);
                    break;
                  case 'button_name':
                    partsRecord.buttonName = subPart1ToEnd;
                    break;
                  case 'caption':
                    // you can make a special caption for this tip
                    partsRecord.caption = subPart1ToEnd;
                    break;
                  case 'caption_pic':
                    // you can put a tiny pic next to the caption (use markdown)
                    partsRecord.captionPic = utils.renderMarkdown(subPart1);
                    break;
                  case 'caption_video_id':
                    // you can put a tiny video next to the caption
                    if (subPart1.indexOf('images/') === 0) {
                      partsRecord.captionVideo = '<video width="150" height="75" autoplay><source src="' + subPart1 + '" type="video/mp4"></video>';
                    } else {
                      partsRecord.captionVideo = '<iframe width="100" height=80 src="https://www.youtube.com/embed/' + subPart1 + '?rel=0&amp;controls=0&amp;showinfo=0" frameborder="0"></iframe>';
                    }
                    break;
                  case 'narrator_name':
                    // set the name of the narrator to display in the control panel during playback
                    if (subPart1 !== undefined) {
                      partsRecord.narratorName = subPart1ToEnd;
                    }
                    break;
                  case 'narrator_pic':
                    // specify a picture to display in the control panel during playback
                    if (subPart1 !== undefined) {
                      partsRecord.narratorPicture = subPart1;
                    }
                    break;
                  case 'hide_player_after_playback_complete':
                    state.setHidePlayerAfterPlayback(true);
                    break;
                  case 'dont_restore_cell_contents_after_playback':
                    // if the user hasn't changed cell contents, don't restore the cell contents when playback finishes
                    state.setDontRestoreCellContentsAfterPlayback(true);
                    break;
                  case 'autoplay':
                    // 'never' (optional), 'once', 'always'
                    if (subPart1 !== undefined) {
                      // if not passed in then its considered to be 'never'
                      partsRecord.autoplay = subPart1.toLowerCase();
                    }
                    break;
                  case 'play_on_click': // if present, we will make a click on the target initiate playback.
                  case 'click_to_play':
                    partsRecord.playOnClick = true;
                    break;
                  case 'hide_tooltip':
                    // if present, we will not render tooltip.
                    partsRecord.hideTooltip = true;
                    break;
                  case 'hide_play_button':
                    // if present, we will render the tooltip but we will not show the play button. 
                    // Used in conjunction with clickToPlay on text graffiti
                    partsRecord.hidePlayButton = true;
                    break;
                  case 'custom_sticker':
                    // Path to an image or svg that will be a custom sticker.
                    partsRecord.stickerImageUrl = subPart1;
                    break;
                  case 'save_to_file':
                    // Param 1: id of cell to save; param 2: path of file to save cell contents to. You can have more than one of these in a tooltip
                    if (partsRecord.saveToFile === undefined) {
                      partsRecord.saveToFile = [];
                    }
                    var saveFile = subParts[2].replace(/^"/, '').replace(/"$/, '');
                    var sourceCell = subPart1;
                    partsRecord.saveToFile.push({ cellId: sourceCell, path: saveFile });
                    break;
                  case 'terminal_command':
                    // pass a shell command to execute, enclosed by double quotes. The outside quotes will be removed.
                    var command = subParts.slice(2).join(' ').replace(/^"/, '').replace(/"$/, '');
                    partsRecord.terminalCommand = { terminalId: subPart1, command: command };
                    break;
                }
              }
            }
          }
        }
        return partsRecord;
      },

      refreshGraffitiSideMarkers: function refreshGraffitiSideMarkers(cell) {
        var element = $(cell.element[0]);
        var elemOffset = element.offset();
        element.find('.graffiti-right-side-marker').unbind('mouseenter mouseleave').remove(); // remove all previous markers for this cell
        var markers = element.find('.graffiti-highlight');
        var yBuffer = 2;
        var i = void 0,
            marker = void 0,
            offset = void 0,
            makerIcon = void 0,
            rect = void 0,
            yDiff = void 0,
            className = void 0,
            idMatch = void 0,
            metaData = void 0;
        if (markers.length > 0) {
          //console.log('markers:', markers);
          for (i = 0; i < markers.length; ++i) {
            marker = markers[i];
            className = marker.className;
            // extract the recording tag so we can highlight it later
            idMatch = className.match(/graffiti-(id_.[^\-]+-id_[^\s]+)/);
            metaData = idMatch !== null ? idMatch[1] : undefined;
            offset = $(marker).offset();
            yDiff = offset.top - elemOffset.top;
            markerIcon = stickerLib.makeRightSideMarker({ color: 'rgb(47,147,107)',
              dimensions: { x: element.width() + 20,
                y: yDiff - yBuffer,
                width: 18,
                height: 12
              },
              metaTag: 'graffiti-id|' + metaData,
              title: localizer.getString('GRAFFITI_PRESENT')
            });
            $(markerIcon).appendTo(element);
          }
        }
        var markerIcons = element.find('.graffiti-right-side-marker');
        if (markerIcons.length > 0) {
          markerIcons.bind('mouseenter mouseleave', function (e) {
            var target = $(e.target);
            if (!target.hasClass('graffiti-right-side-marker')) {
              target = target.parents('.graffiti-right-side-marker');
            }
            var graffitiId = target.attr('graffiti-id');
            var cellElement = target.parents('.cell');
            var graffitiElement = cellElement.find('.graffiti-' + graffitiId);
            if (e.type === 'mouseenter') {
              //console.log('entered right-side-marker:', graffitiId);
              graffitiElement.addClass('graffiti-highlight-extra');
            } else {
              //console.log('left right-side-marker', graffitiId);
              graffitiElement.removeClass('graffiti-highlight-extra');
            }
          });
        }
      },

      // Refresh the markDoc calls for any particular cell based on recording data
      refreshGraffitiHighlights: function refreshGraffitiHighlights(params) {
        params.cellId = utils.getMetadataCellId(params.cell.metadata);

        if (params.cell.cell_type !== 'code') {
          return; // We don't refresh highlights in markdown cells because markdown cells do their highlights with plain html markup.
        }
        var recordings = state.getManifestRecordingsForCell(params.cellId);
        var cm = params.cell.code_mirror;
        var marks = cm.getAllMarks();
        var markClasses = void 0;
        if (params.clear) {
          var _iteratorNormalCompletion16 = true;
          var _didIteratorError16 = false;
          var _iteratorError16 = undefined;

          try {
            for (var _iterator16 = marks[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
              var mark = _step16.value;

              mark.clear();
            }
          } catch (err) {
            _didIteratorError16 = true;
            _iteratorError16 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion16 && _iterator16.return) {
                _iterator16.return();
              }
            } finally {
              if (_didIteratorError16) {
                throw _iteratorError16;
              }
            }
          }
        } else {
          markClasses = marks.map(function (mark) {
            return mark.className;
          }).join(' ').replace(/graffiti-highlight /g, '');
        }
        var allTokens = utils.collectCMTokens(cm);
        graffiti.tokenRanges[params.cellId] = {};
        if (recordings !== undefined) {
          if (Object.keys(recordings).length > 0) {
            var keyParts = void 0,
                recording = void 0,
                _recordingKey3 = void 0,
                tokens = void 0,
                firstToken = void 0,
                marker = void 0,
                range = void 0;
            var _iteratorNormalCompletion17 = true;
            var _didIteratorError17 = false;
            var _iteratorError17 = undefined;

            try {
              for (var _iterator17 = Object.keys(recordings)[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
                _recordingKey3 = _step17.value;

                recording = recordings[_recordingKey3];
                tokens = recording.tokens;
                //console.log('recordingKey:', recordingKey);
                range = utils.getCMTokenRange(cm, tokens, allTokens);
                if (range !== undefined) {
                  // Store computed character ranges for checking selections against recording ranges.
                  graffiti.tokenRanges[params.cellId][_recordingKey3] = range;
                  if (params.clear || !params.clear && markClasses !== undefined && markClasses.indexOf(_recordingKey3) === -1) {
                    // don't call markText twice on a previously marked range
                    marker = 'graffiti-' + recording.cellId + '-' + _recordingKey3;
                    cm.markText({ line: range.start.line, ch: range.start.ch }, { line: range.end.line, ch: range.end.ch }, { className: 'graffiti-highlight ' + marker });
                  }
                }
              }
            } catch (err) {
              _didIteratorError17 = true;
              _iteratorError17 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion17 && _iterator17.return) {
                  _iterator17.return();
                }
              } finally {
                if (_didIteratorError17) {
                  throw _iteratorError17;
                }
              }
            }
          }
        }
      },

      refreshAllGraffitiSideMarkers: function refreshAllGraffitiSideMarkers() {
        var activity = state.getActivity();
        if (activity === 'playing' || activity === 'recording' || activity === 'scrubbing') {
          return; // don't update these during playback, recording or scrubbing... too slow
        }
        var cells = Jupyter.notebook.get_cells();
        var _iteratorNormalCompletion18 = true;
        var _didIteratorError18 = false;
        var _iteratorError18 = undefined;

        try {
          for (var _iterator18 = cells[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
            var _cell = _step18.value;

            graffiti.refreshGraffitiSideMarkers(_cell);
          }
        } catch (err) {
          _didIteratorError18 = true;
          _iteratorError18 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion18 && _iterator18.return) {
              _iterator18.return();
            }
          } finally {
            if (_didIteratorError18) {
              throw _iteratorError18;
            }
          }
        }
      },

      refreshAllGraffitiHighlights: function refreshAllGraffitiHighlights() {
        var cells = Jupyter.notebook.get_cells();
        var params = void 0;
        var _iteratorNormalCompletion19 = true;
        var _didIteratorError19 = false;
        var _iteratorError19 = undefined;

        try {
          for (var _iterator19 = cells[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
            var _cell2 = _step19.value;

            params = { cell: _cell2, clear: true };
            graffiti.refreshGraffitiHighlights(params);
            graffiti.refreshGraffitiSideMarkers(_cell2);
          }
        } catch (err) {
          _didIteratorError19 = true;
          _iteratorError19 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion19 && _iterator19.return) {
              _iterator19.return();
            }
          } finally {
            if (_didIteratorError19) {
              throw _iteratorError19;
            }
          }
        }
      },

      updateRefreshableCell: function updateRefreshableCell() {
        var highlightRefreshCellId = state.getHighlightsRefreshCellId();
        if (highlightRefreshCellId !== undefined) {
          var highlightRefreshCell = utils.findCellByCellId(highlightRefreshCellId);
          graffiti.refreshGraffitiHighlights({ cell: highlightRefreshCell, clear: true });
          graffiti.refreshGraffitiSideMarkers(highlightRefreshCell);
          state.clearHighlightsRefreshableCell();
        }
      },

      hideTip: function hideTip(tip) {
        graffiti.notebookContainer.find('.graffiti-tip .headline').remove();
        graffiti.notebookContainer.find('.graffiti-tip').hide();
        // I think this is messing up clickable images.
        //state.clearPlayableMovie('tip');
      },

      refreshGraffitiTooltipsCore: function refreshGraffitiTooltipsCore(e) {
        //console.log('Graffiti: handling mousenter/mouseleave:', e.type);
        var activity = state.getActivity();
        var highlightElem = $(e.target);
        if (!highlightElem.hasClass('graffiti-highlight')) {
          highlightElem = highlightElem.parents('.graffiti-highlight');
        }
        var highlightElemRect = highlightElem[0].getBoundingClientRect();
        var highlightElemMaxDimension = Math.max(highlightElemRect.width, highlightElemRect.height);
        var highlightElemMaxDimensionSquared = highlightElemMaxDimension * highlightElemMaxDimension;
        var idMatch = highlightElem.attr('class').match(/graffiti-(id_.[^\-]+)-(id_[^\s]+)/);
        if (idMatch !== null) {
          var cellId = idMatch[1];
          var _recordingKey4 = idMatch[2];
          var hoverCell = utils.findCellByCellId(cellId);
          var hoverCellElement = hoverCell.element[0];
          var hoverCellElementPosition = $(hoverCellElement).position();
          var hoverCellType = hoverCell.cell_type;
          var outerInputElement = void 0;
          if (hoverCellType === 'markdown') {
            outerInputElement = $(hoverCellElement).find('.inner_cell');
          } else {
            outerInputElement = $(hoverCellElement).find('.CodeMirror-lines');
          }
          var recording = state.getManifestSingleRecording(cellId, _recordingKey4);
          var activeTakeId = recording.activeTakeId;
          //console.log('refreshGraffitiTooltips: recording=', recording, cellId, recordingKey);
          if (recording.hasMovie) {
            //console.log('Graffiti: refreshGraffitiTooltips: recording=', recording, cellId, recordingKey);
            state.setPlayableMovie('tip', cellId, _recordingKey4);
          }
          state.setHidePlayerAfterPlayback(false); // default for any recording is not to hide player
          var _tooltipCommands = graffiti.extractTooltipCommands(recording.markdown);

          if (recording.playOnClick) {
            //console.log('Graffiti: binding target for click', highlightElem);
            highlightElem.off('click').click(function (e) {
              state.clearTipTimeout();
              e.stopPropagation(); // for reasons unknown event still propogates to the codemirror editing area undeneath...

              if (state.getActivity() === 'recordingPending') {
                graffiti.toggleRecording(); // we want clicks on playOnClick to be ignored if a recording is pending.
              } else {
                graffiti.playMovieViaUserClick();
              }
              return false;
            });
          }

          if (recording.hideTooltip || recording.terminalCommand !== undefined || activity === 'recording') {
            // console.log('Graffiti: recording is set to hide tip or recording is set to run a terminal command, or recording so we do not display tips');
            return;
          }

          var existingTip = graffiti.notebookContainer.find('.graffiti-tip');
          if (e.type === 'mouseleave') {
            state.setTipTimeout(function () {
              graffiti.hideTip();
            }, 500);
          } else {
            var currentPointerPosition = state.getPointerPosition();
            // Only show tip if cursor rests on hover for a 1/2 second
            state.setTipTimeout(function () {
              //console.log('tip interval');
              var newPointerPosition = state.getPointerPosition();
              var cursorDistanceSquared = (newPointerPosition.x - currentPointerPosition.x) * (newPointerPosition.x - currentPointerPosition.x) + (newPointerPosition.y - currentPointerPosition.y) * (newPointerPosition.y - currentPointerPosition.y);

              //console.log('comparing currentPointerPosition, newPointerPosition:', currentPointerPosition,
              //newPointerPosition, cursorDistanceSquared);
              // Only show tip if cursor isn't flying over the item at high speeds
              if (cursorDistanceSquared > highlightElemMaxDimensionSquared) {
                currentPointerPosition = state.getPointerPosition();
              } else {
                var contentMarkdown = '';
                //console.log('markId:', markId, 'recordings:', hoverCell.metadata.recordings);
                var headlineMarkdown = '';
                if (_tooltipCommands !== undefined) {
                  headlineMarkdown = '<div class="headline">' + ' <div>' + _tooltipCommands.captionPic + '</div>' + ' <div>' + _tooltipCommands.caption + '</div>' + (_tooltipCommands.captionVideo !== undefined ? ' <div class="graffiti-video">' + _tooltipCommands.captionVideo + '</div>' : '') + '</div>';
                }
                contentMarkdown = utils.renderMarkdown(recording.markdown);
                // if no tooltip is defined, show a default message
                if (contentMarkdown.length === 0 && recording.hidePlayButton) {
                  contentMarkdown = utils.renderMarkdown('_' + localizer.getString('TOOLTIP_HINT') + '_');
                }
                var tooltipContents = headlineMarkdown + '<div class="parts">' + '<div class="info">' + contentMarkdown + '</div>';
                if (recording.hasMovie && !recording.hidePlayButton) {
                  graffiti.tooltipButtonLabel = _tooltipCommands !== undefined && _tooltipCommands.buttonName !== undefined ? _tooltipCommands.buttonName : 'Play Movie';
                  tooltipContents += '   <div class="movie"><button class="btn btn-default btn-small" id="graffiti-movie-play-btn">' + graffiti.tooltipButtonLabel + '</button></div>';
                }
                tooltipContents += '</div>';

                if (existingTip.length === 0) {
                  existingTip = $('<div class="graffiti-tip" id="graffiti-tip">' + tooltipContents + '</div>').prependTo(graffiti.notebookContainer);
                  existingTip.bind('mouseenter mouseleave', function (e) {
                    // console.log(e.type === 'mouseenter' ? 'entering tooltip' : 'leaving tooltip');
                    if (e.type === 'mouseenter') {
                      state.clearTipTimeout();
                    } else {
                      //console.log('hiding tip');
                      graffiti.hideTip();
                    }
                  });
                } else {
                  // Don't replace the tip if the contents are identical to what we had on the last interval.
                  var currentTipInfo = state.getDisplayedTipInfo();
                  var doUpdate = true;
                  if (!graffiti.forcedGraffitiTooltipRefresh) {
                    if (currentTipInfo !== undefined) {
                      if (currentTipInfo.cellId === cellId && currentTipInfo.recordingKey === _recordingKey4) {
                        doUpdate = false;
                      }
                    }
                  }
                  graffiti.forcedGraffitiTooltipRefresh = false;
                  if (doUpdate) {
                    //console.log('replacing tooltip contents ');
                    existingTip.find('#graffiti-movie-play-btn').unbind('click');
                    existingTip.html(tooltipContents);
                    state.setDisplayedTipInfo(cellId, _recordingKey4);
                  } else {
                    if (graffiti.tooltipButtonLabel !== undefined) {
                      $('#graffiti-movie-play-btn').html(graffiti.tooltipButtonLabel);
                    }
                  }
                  $('#graffiti-movie-play-btn').prop('disabled', false);
                }

                // Set up the call back for the play button on the tooltip that will actually play the movie.
                existingTip.find('#graffiti-movie-play-btn').unbind('click').click(function (e) {
                  state.clearTipTimeout();
                  e.stopPropagation(); // for reasons unknown event still propogates to the codemirror editing area undeneath...
                  graffiti.playMovieViaUserClick();
                  return false;
                });
                var outerInputOffset = outerInputElement.offset();
                var outerInputElementWidth = outerInputElement.width();
                var highlightElemOffset = highlightElem.offset();
                var existingTipWidth = existingTip.width();
                var existingTipHeight = existingTip.height();
                var tipTop = parseInt(highlightElemOffset.top - outerInputOffset.top) - existingTipHeight - graffiti.tipAboveFudge;
                var tipLeft = void 0,
                    anchorIsImage = false;
                if (hoverCellType === 'markdown') {
                  var anchorImage = highlightElem.find('img');
                  if (anchorImage.length > 0) {
                    var anchorElemOffset = anchorImage.offset();
                    //console.log('anchorElemOffset', anchorElemOffset);
                    tipLeft = anchorElemOffset.left + anchorImage.width() / 2 - existingTipWidth / 2;
                    tipTop = anchorElemOffset.top - outerInputOffset.top + anchorImage.height() / 2 - existingTipHeight / 2;
                    anchorIsImage = true;
                    //console.log('image tipLeft, tipTop:', tipLeft, tipTop);
                  } else {
                    var anchorElem = highlightElem.find('i');
                    var _anchorElemOffset = anchorElem.offset();
                    var posCandidate1 = outerInputElementWidth - existingTipWidth + outerInputOffset.left - graffiti.notebookContainerPadding;
                    var posCandidate2 = _anchorElemOffset.left;
                    tipLeft = parseInt(Math.min(posCandidate1, posCandidate2));
                  }
                } else {
                  tipLeft = parseInt(Math.min(outerInputElementWidth - existingTipWidth, Math.max(highlightElemOffset.left, outerInputOffset.left)));
                }

                // Place tip in the best position on the screen.
                var tipPosition = { left: tipLeft, top: tipTop };
                //console.log('outerInputOffset:', outerInputOffset, 'highlightElemOffset:', highlightElemOffset, 'tipPosition:', tipPosition);
                //console.log('1) tipPosition:', tipPosition);
                var headerRect = $('#header')[0].getBoundingClientRect();
                // If the highlight element is in the upper half of the notebook panel area, flip the tooltip to be below the highlightElem.
                var rectDifference = highlightElemRect.top - headerRect.bottom - 20;
                if (rectDifference < existingTipHeight && !anchorIsImage) {
                  // place tip below the line
                  tipPosition.top = highlightElemOffset.top - outerInputOffset.top + graffiti.cmLineHeight + graffiti.cmLineTipFudge;
                }
                //console.log('2) tipPosition:', tipPosition);
                tipPosition.top += hoverCellElementPosition.top;
                //console.log('3) tipPosition:', tipPosition);

                var positionPx = { left: tipPosition.left + 'px', top: tipPosition.top + 'px' };
                existingTip.css(positionPx);
                existingTip.show();

                // increase counter of total tips shown this session
                state.updateUsageStats({
                  type: 'tip',
                  data: {
                    cellId: cellId,
                    recordingKey: _recordingKey4
                  }
                });
              }
            }, 425); // this number is how long user has to hover before we display the tooltip
          }
        }
      },

      refreshGraffitiTooltips: function refreshGraffitiTooltips() {
        var tips = $('.graffiti-highlight');
        //console.trace('refreshGraffitiTooltips: binding mousenter/mouseleave');
        tips.unbind('mouseenter mouseleave').bind('mouseenter mouseleave', function (e) {
          graffiti.refreshGraffitiTooltipsCore(e);
        });
      },

      markSelectedCellForExecution: function markSelectedCellForExecution() {
        var selectedCell = Jupyter.notebook.get_selected_cell();
        if (selectedCell !== undefined && selectedCell.cell_type === 'code') {
          state.setExecutionSourceChoiceId(utils.getMetadataCellId(selectedCell.metadata));
          graffiti.setJupyterMenuHint(localizer.getString('CELL_EXECUTE_CHOICE'));
        }
      },

      handleExecuteCellViaGraffiti: function handleExecuteCellViaGraffiti() {
        var selectedCell = Jupyter.notebook.get_selected_cell();
        if (selectedCell.cell_type === 'code') {
          var config = utils.getCellGraffitiConfig(selectedCell);
          if (config !== undefined) {
            if (config.hasOwnProperty('executeCellViaGraffiti')) {
              var execKey = config['executeCellViaGraffiti'];
              var keyParts = execKey.split('_');
              state.setPlayableMovie('cellExecute', 'id_' + keyParts[0], 'id_' + keyParts[1]);
              graffiti.loadAndPlayMovie('cellExecute');
              return true;
            }
          }
        }
        return false;
      },

      handleKeydown: function handleKeydown(e) {
        var keyCode = e.which;
        var activity = state.getActivity();
        var stopProp = false;

        //console.log('handleKeydown keyCode:', keyCode, String.fromCharCode(keyCode));
        if (activity === 'recording' || true) {
          if (keyCode === 17) {
            // ctrl key
            graffiti.skipActivatorKeyCombo |= 1;
            return true;
          } else if (keyCode === 18) {
            // opt/alt key
            graffiti.skipActivatorKeyCombo |= 2;
            return true;
          }
          graffiti.skipActivatorKeyCombo = 0; // any other keypress during recording cancels the special skip activator key combo check
        }

        if (terminalLib.getFocusedTerminal() !== undefined) {
          // Let any focused terminal handle the event. Don't let jupyter or anybody else get it. 
          // (Graffiti will need to capture the data during recording though.)
          // console.log('Graffiti: Focused terminal so stopping propogation');
          e.stopPropagation();
          return true;
        }

        // If user hit shift-enter or ctrl-enter, in a code cell, and it is marked as "executeCellViaGraffiti" then it will
        // actually run a graffiti movie when you try to execute that cell, rather than the jupyter default (only when in 'idle' activity)
        if (activity === 'idle') {
          if (keyCode === 13) {
            if (e.ctrlKey || e.shiftKey) {
              if (graffiti.handleExecuteCellViaGraffiti()) {
                console.log('Graffiti: executedCellViaGraffiti ran, so: intercepting return-key press.');
                e.stopPropagation();
                return true;
              }
            }
          }
        }

        if ((48 <= keyCode && keyCode <= 57 || // A-Z
        65 <= keyCode && keyCode <= 90 || // 0-9
        37 <= keyCode && keyCode <= 40 || // arrow keys                
        keyCode === 32) && // space bar
        activity === 'playing') {
          // Pressing keys : A-Z, 0-9, arrows, and spacebar stop any playback in progress.
          stopProp = true;
          graffiti.togglePlayback();
        } else {
          // Check for other keypress actions
          switch (keyCode) {
            case 27:
              // escape key CANCELS playback
              stopProp = true;
              if (activity === 'playing' || activity === 'playbackPaused' || activity === 'scrubbing') {
                graffiti.cancelPlayback({ cancelAnimation: true });
              }
              break;
            case 77:
              // cmd-m key finishes a recording in progress or cancels a pending recording
              // cf http://jsbin.com/vezof/1/edit?js,output
              if (e.metaKey) {
                // may only work on Chrome
                if (e.ctrlKey) {
                  console.log('Graffiti: you pressed ctrl ⌘-m');
                } else {
                  console.log('Graffiti: you pressed ⌘-m');
                }
                stopProp = true;
                switch (activity) {
                  case 'recording':
                    if (e.ctrlKey) {} else {
                      graffiti.toggleRecording();
                    }
                    break;
                  case 'recordingPending':
                    graffiti.changeActivity('idle');
                    break;
                }
              }
              break;
            case 16:
              // shift key
              state.setShiftKeyIsDown(true);
              state.updateDrawingState([{ change: 'stickerOnGrid', data: true }]);
              //console.log('Graffiti: shiftKeyIsDown');
              break;
            // case 13: // enter key
            // case 18: // meta key
            // case 91: // option key
            //   break;
            default:
              break; // let any other keys pass through
          }
        }

        if (stopProp) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        return true;
      },

      setupBackgroundEvents: function setupBackgroundEvents() {
        // Handle rubber banding scrolling that occurs on short notebooks so cursor doesn't look wrong (possibly, only chrome?).
        console.log('Graffiti: setupBackgroundEvents');

        graffiti.sitePanel.on('scroll', function (e) {
          var notebookPanelHeight = graffiti.notebookPanel.height();
          var viewInfo = utils.collectViewInfo(state.getPointerPosition().x, state.getPointerPosition().y, graffiti.notebookPanel.height(), graffiti.sitePanel.scrollTop() - state.getScrollTop());
          state.setScrollTop(graffiti.sitePanel.scrollTop());
          state.storeViewInfo(viewInfo);
          state.storeHistoryRecord('scroll');
          if (state.getActivity() === 'playbackPaused') {
            graffiti.undimGraffitiCursor();
          }
          return true;
        });

        graffiti.sitePanel.on('mousewheel', function (e) {
          if (state.getActivity() === 'playing') {
            console.log('Graffiti: pausing playback because of mousewheel scroll.');
            graffiti.pausePlayback();
          }
        });

        $('body').keydown(function (e) {
          return graffiti.handleKeydown(e);
        });

        $('body').keyup(function (e) {
          //console.log('keyUp e.which:', e.which, 'activator', graffiti.skipActivatorKeyCombo);
          switch (e.which) {
            case 16:
              //console.log('Graffiti: shiftKeyIsUp');
              state.setShiftKeyIsDown(false);
              state.updateDrawingState([{ change: 'stickerOnGrid', data: false }]);
              break;
            case 17:
              if (graffiti.skipActivatorKeyCombo < 3) {
                graffiti.skipActivatorKeyCombo = 0;
              } else {
                graffiti.skipActivatorKeyCombo |= 4;
              }
              break;
            case 18:
              if (graffiti.skipActivatorKeyCombo < 3) {
                graffiti.skipActivatorKeyCombo = 0;
              } else {
                graffiti.skipActivatorKeyCombo |= 8;
              }
              break;
          }
          if (graffiti.skipActivatorKeyCombo === 15) {
            console.log('Graffiti: You pressed and released the special activator key combo.');
            graffiti.skipActivatorKeyCombo = 0;
          }
        });

        window.onmousemove = function (e) {
          //console.log('cursorPosition:[',e.clientX, e.clientY, ']');
          //console.log('mouse_e:', e.pageX, e.pageY);
          var previousPointerPosition = state.getPointerPosition();
          var previousPointerX = previousPointerPosition.x;
          var previousPointerY = previousPointerPosition.y;
          state.storePointerPosition(e.clientX, e.clientY); // keep track of current pointer position at all times
          var viewInfo = utils.collectViewInfo(e.clientX, e.clientY, graffiti.notebookPanel.height(), graffiti.sitePanel.scrollTop() - state.getScrollTop());
          state.setScrollTop(graffiti.sitePanel.scrollTop());
          state.storeViewInfo(viewInfo);
          state.storeHistoryRecord('pointer');

          var doDrawingDisplayUpdate = true;
          var drawingActivity = state.getDrawingStateField('drawingActivity');
          if (drawingActivity === 'sticker') {
            var stickerType = state.getDrawingPenAttribute('stickerType');
            if (stickerType === 'label') {
              // We do not want to update the label during recording because this fn is called via onmousemove.
              // We update the label directly from handleLabelInput(), above, for that special case. Otherwise, we
              // will end up dragging the label around the screen while the mousebutton is down.
              doDrawingDisplayUpdate = false;
            }
          }
          if (doDrawingDisplayUpdate) {
            graffiti.updateDrawingDisplayWhenRecording(previousPointerX, previousPointerY, e.clientX, e.clientY, viewInfo);
          }

          graffiti.updateControlPanelPosition();
          return true;
        };

        // If we were playing a recording when they hit reload, we need to cancel it, restore, and save before we continue. 
        // Needs more testing!!
        window.addEventListener('beforeunload', function (e) {
          console.log('Graffiti: before unload handler.');
          var activity = state.getActivity();
          if (activity === 'playing' || activity === 'playbackPaused' || activity == 'scrubbing') {
            graffiti.cancelPlaybackNoVisualUpdates();
          }
          udacityUser.trackUsageStats();
        });

        // To make async calls work on non-chrome browsers
        // https://stackoverflow.com/a/20322988/4953199
        window.onunload = function (e) {
          console.log('Graffiti: on unload');
          udacityUser.trackUsageStats();
        };

        // https://stackoverflow.com/questions/19469881/remove-all-event-listeners-of-specific-type
        window.addEventListener('dblclick', function (e) {
          if (state.getActivity() === 'recording') {
            var isTextCell = $(e.target).parents('.text_cell');
            if (isTextCell.length > 0) {
              console.log('Graffiti: intercepted doubleclick on markdown during recording, discarding it');
              e.stopPropagation();
              e.preventDefault();
              return true;
            }
          }
          return false;
        }, true);

        window.onblur = function (e) {
          //console.log('window lost focus, pausing any playing movie');
          graffiti.pausePlayback();
        },

        // Serialize/deserialize range objects
        // https://github.com/tildeio/range-serializer
        // https://www.npmjs.com/package/serialize-selection

        // Specially handle selection changes in rendered markdown cells and output areas during recordings
        document.addEventListener("selectionchange", function () {
          // get the selection and serialize it
          if (state.getActivity() === 'recording') {
            state.clearSelectionSerialized();
            var viewInfo = state.getViewInfo();
            var cellId = viewInfo.cellId;
            if (cellId !== undefined) {
              var hoverCell = utils.findCellByCellId(cellId);
              var parentNode = void 0;
              if (hoverCell.cell_type === 'markdown') {
                parentNode = $(hoverCell.element).find('.rendered_html');
              } else {
                parentNode = $(hoverCell.element).find('.output_subarea');
              }
              if (parentNode.length > 0) {
                var selectionSerialized = selectionSerializer.get(parentNode[0]);
                if (!selectionSerialized.empty) {
                  selectionSerialized.cellType = hoverCell.cell_type;
                  selectionSerialized.cellId = cellId;
                  // utils.shrinkAllCMSelections(); // cancel all CM selections as they will prevent replaying selection changes in other dom elements
                  state.setSelectionSerialized(selectionSerialized);
                  state.storeHistoryRecord('selections');
                }
              }
            }
          }
        });

        graffiti.handleSliderDragDebounced = _.debounce(graffiti.handleSliderDrag, 20, true);

        console.log('Graffiti: Background setup complete.');
      },

      setRecordingTakeId: function setRecordingTakeId(recordingRecord) {
        if (recordingRecord.activeTakeId === undefined || state.getMovieRecordingStarted()) {
          // if making a new take, must create a new activeTakeId
          recordingRecord.activeTakeId = utils.generateUniqueId(); // do not set a new activeTakeId if there was already a valid one set for the movie
        }
      },

      storeRecordingInfoInCell: function storeRecordingInfoInCell(isOldGraffiti) {
        var recordingRecord = void 0,
            newRecording = void 0,
            recordingCell = void 0,
            recordingCellId = void 0,
            recordingKey = void 0;
        if (isOldGraffiti === undefined) {
          isOldGraffiti = graffiti.selectedTokens.isIntersecting;
        }
        if (isOldGraffiti) {
          // Prepare to update existing recording
          recordingCell = graffiti.selectedTokens.recordingCell;
          recordingCellId = graffiti.selectedTokens.recordingCellId;
          recordingKey = graffiti.selectedTokens.recordingKey;
          recordingRecord = state.getManifestSingleRecording(recordingCellId, recordingKey);
          graffiti.previousActiveTakeId = recordingRecord.activeTakeId;
          graffiti.setRecordingTakeId(recordingRecord);
          newRecording = false;
        } else {
          // Prepare to create a new recording
          graffiti.previousActiveTakeId = undefined;
          recordingCell = Jupyter.notebook.get_selected_cell();
          recordingCellId = utils.getMetadataCellId(recordingCell.metadata);
          recordingKey = utils.generateUniqueId();
          newRecording = true;
          recordingRecord = {
            cellId: recordingCellId,
            cellType: recordingCell.cell_type,
            createDate: utils.getNow(),
            inProgress: true,
            tokens: $.extend({}, graffiti.selectedTokens.tokens),
            range: $.extend({}, graffiti.selectedTokens.range),
            allTokensString: graffiti.selectedTokens.allTokensString,
            markdown: '',
            authorId: state.getAuthorId(),
            authorType: state.getAuthorType(), // one of "creator" (eg teacher), "viewer" (eg student)
            activeTakeId: undefined, // this will be replaced with an id for the first movie recording made
            hasMovie: false
          };
          state.setSingleManifestRecording(recordingCellId, recordingKey, recordingRecord);
        }

        state.storeRecordingCellInfo({
          newRecording: newRecording,
          recordingRecord: recordingRecord,
          recordingCell: recordingCell,
          recordingCellId: recordingCellId,
          recordingKey: recordingKey,
          scrollTop: graffiti.sitePanel.scrollTop()
        });

        return recordingRecord;
      },

      clearHighlightMarkText: function clearHighlightMarkText() {
        if (graffiti.highlightMarkText !== undefined) {
          graffiti.highlightMarkText.clear();
          graffiti.highlightMarkText = undefined;
        }
      },

      highlightIntersectingGraffitiRange: function highlightIntersectingGraffitiRange() {
        graffiti.clearHighlightMarkText();
        if (state.getAccessLevel() === 'view') {
          // we never do this in view mode
          return;
        }
        var cell = graffiti.selectedTokens.recordingCell;
        if (cell !== undefined) {
          var cm = cell.code_mirror;
          var startLoc = cm.posFromIndex(graffiti.selectedTokens.range.start);
          var endLoc = cm.posFromIndex(graffiti.selectedTokens.range.end);
          graffiti.highlightMarkText = cm.markText(startLoc, endLoc, { className: 'graffiti-selected' });
        }
      },

      selectIntersectingGraffitiRange: function selectIntersectingGraffitiRange() {
        if (graffiti.selectedTokens.noTokensPresent) {
          return;
        }
        var recordingCellInfo = state.getRecordingCellInfo();
        var recordingCell = recordingCellInfo.recordingCell;
        var cm = recordingCell.code_mirror;
        var startLoc = cm.posFromIndex(graffiti.selectedTokens.range.start);
        var endLoc = cm.posFromIndex(graffiti.selectedTokens.range.end);
        cm.setSelections([{ anchor: startLoc, head: endLoc }]);
        graffiti.selectedTokens = utils.findSelectionTokens(recordingCell, graffiti.tokenRanges, state);
        graffiti.highlightIntersectingGraffitiRange();
      },

      // Edit an existing graffiti, or if we are creating a new one, set up some default values.
      // If creating a new graffiti in markdown text, jump directly to the movie recording phase.
      editGraffiti: function editGraffiti() {
        var editableText = void 0;

        graffiti.changeActivity('graffiting');
        state.setLastEditActivityTime();
        var isNewGraffiti = !graffiti.selectedTokens.isIntersecting;
        var isOldGraffiti = !isNewGraffiti;
        var recordingRecord = graffiti.storeRecordingInfoInCell(isOldGraffiti);
        var activeCellIndex = Jupyter.notebook.get_selected_index();
        var isMarkdownCell = recordingRecord.cellType === 'markdown';
        var isCodeCell = recordingRecord.cellType === 'code';

        var graffitiEditCell = Jupyter.notebook.insert_cell_above('markdown');
        var editCellIndex = utils.findCellIndexByCellId(utils.getMetadataCellId(graffitiEditCell.metadata));
        Jupyter.notebook.select(editCellIndex); // cell *must* be selected before unrender() called by set_text() below will actually unrender the cell correctly.


        if (isNewGraffiti || isCodeCell || isMarkdownCell && isOldGraffiti) {
          utils.setMetadataCellId(graffitiEditCell.metadata, utils.generateUniqueId());
          utils.refreshCellMaps();
          state.setGraffitiEditCellId(utils.getMetadataCellId(graffitiEditCell.metadata));
        }

        if (isNewGraffiti) {
          if (isMarkdownCell) {
            // Set up some reasonable options for Graffiti in markdown. Author can, of course, opt to change these any time.
            editableText = localizer.getString('BELOW_TYPE_MARKDOWN') + "%%play_on_click\n" + "%%hide_player_after_playback_complete\n" + "%%hide_play_button\n";
          } else {
            editableText = localizer.getString('BELOW_TYPE_MARKDOWN') + graffiti.selectedTokens.allTokensString;
          }
        } else {
          // Use whatever author put into this graffiti previously
          editableText = recordingRecord.markdown;
        }

        graffitiEditCell.set_text(editableText); // set_text does an unrender() call implicitly

        if (isCodeCell || isOldGraffiti) {
          // For code cell graffiti or non-new markdown graffiti, let us edit the tip contents by scrolling to the edit cell
          Jupyter.notebook.scroll_to_cell(Math.max(0, activeCellIndex), 500);
          var selectedCell = Jupyter.notebook.get_selected_cell();
          selectedCell.unselect();
          graffitiEditCell.select();
          graffitiEditCell.code_mirror.focus();
          graffitiEditCell.code_mirror.setSelection({ line: 2, ch: 0 }, { line: 10000, ch: 10000 });
        }

        if (isMarkdownCell && isNewGraffiti) {
          // Proceed directly to recording a movie, assuming we want to persist this new graffiti (no way to cancel)
          graffiti.finishGraffiti(true).then(function () {
            graffiti.setRecordingTakeId(recordingRecord);
            // Force this function to treat this as a new movie even though we've automatically created the manifest entry.
            graffiti.beginMovieRecordingProcess(true, recordingRecord);
          });
        }
      },

      finishGraffiti: function finishGraffiti(doSave) {
        var activity = state.getActivity();
        if (activity !== 'graffiting') {
          return;
        }

        var recordingCellInfo = state.getRecordingCellInfo();
        var recordingCell = recordingCellInfo.recordingCell;

        var editCellIndex = utils.findCellIndexByCellId(state.getGraffitiEditCellId());

        var editCellContents = '';
        if (editCellIndex !== undefined) {
          var editCell = utils.findCellByCellId(state.getGraffitiEditCellId());
          editCellContents = editCell.get_text();
          Jupyter.notebook.delete_cell(editCellIndex);

          // Save the graffiti text into the right cell recording.
          var recordings = state.getManifestRecordingsForCell(recordingCellInfo.recordingCellId);
          if (doSave) {
            if (recordingCellInfo.newRecording) {
              recordings[recordingCellInfo.recordingKey] = recordingCellInfo.recordingRecord;
            }
            recordings[recordingCellInfo.recordingKey].markdown = editCellContents;

            var _tooltipCommands2 = graffiti.extractTooltipCommands(editCellContents);
            var recording = recordings[recordingCellInfo.recordingKey];
            recording.autoplay = 'never';
            if (_tooltipCommands2.autoplay === 'always') {
              recording.autoplay = 'always';
            } else if (_tooltipCommands2.autoplay === 'once') {
              recording.autoplay = 'once';
              recording.playedOnce = false;
            }
            recording.playOnClick = _tooltipCommands2.playOnClick;
            recording.hideTooltip = _tooltipCommands2.hideTooltip;
            recording.hidePlayButton = _tooltipCommands2.hidePlayButton;
            recording.narratorName = _tooltipCommands2.narratorName;
            recording.narratorPicture = _tooltipCommands2.narratorPicture;
            recording.stickerImageUrl = _tooltipCommands2.stickerImageUrl;
            recording.saveToFile = _tooltipCommands2.saveToFile;
            recording.terminalCommand = _tooltipCommands2.terminalCommand;

            state.updateUsageStats({
              type: 'create',
              data: {
                createDate: recording.createDate,
                cellId: recordingCellInfo.recordingCellId,
                recordingKey: recordingCellInfo.recordingKey,
                numTakes: recording.takes === undefined ? 0 : Object.keys(recording.takes).length
              }
            });

            console.log('Graffiti: finishGraffiti: we got these stats:', state.getUsageStats());
          } else {
            // Not saving (recording cancelled by user), so make sure we remove this record from the manifest before saving.
            if (recordingCellInfo.newRecording) {
              state.removeManifestEntry(recordingCellInfo.recordingCellId, recordingCellInfo.recordingKey);
            }
          }
        }
        storage.storeManifest();

        if (recordingCell.cell_type === 'markdown' && recordingCellInfo.newRecording && doSave) {
          // If we were adding a Graffiti to a markdown cell, we need to modify the markdown cell to include 
          // our Graffiti span tag around the selection.
          var contents = recordingCell.get_text();
          var parts = [];
          parts.push(contents.substring(0, recordingCellInfo.recordingRecord.range.start));
          parts.push(contents.substring(recordingCellInfo.recordingRecord.range.start, recordingCellInfo.recordingRecord.range.end));
          parts.push(contents.substring(recordingCellInfo.recordingRecord.range.end));
          var spanOpenTag = '<span class="graffiti-highlight graffiti-' + recordingCellInfo.recordingCellId + '-' + recordingCellInfo.recordingKey + '"><i></i>'; // empty italic helps us find its anchor for tooltip
          var newContents = parts[0] + spanOpenTag + parts[1] + '</span>' + parts[2];
          //console.log('newContents:', newContents);
          recordingCell.set_text(newContents);
        }

        return new Promise(function (resolve) {
          utils.saveNotebook(function () {

            // need to reselect graffiti text that was selected in case it somehow got unselected
            //recordingCell.code_mirror.setSelections(recordingCellInfo.selections);
            graffiti.sitePanel.animate({ scrollTop: recordingCellInfo.scrollTop }, 500);
            if (doSave && recordingCellInfo.recordingRecord.cellType === 'markdown') {
              recordingCell.render();
            }
            graffiti.changeActivity('idle');
            recordingCell.code_mirror.focus();
            if (doSave) {
              graffiti.refreshGraffitiHighlights({ cell: recordingCell, clear: false });
              graffiti.forcedGraffitiTooltipRefresh = true;
            } else {
              graffiti.refreshGraffitiHighlights({ cell: recordingCell, clear: true });
            }
            graffiti.refreshGraffitiTooltipsDebounced();
            graffiti.refreshAllGraffitiSideMarkers();
            resolve();
          });
        });
      },

      removeGraffitiCore: function removeGraffitiCore(recordingCell, recordingKey) {
        var recordingCellId = utils.getMetadataCellId(recordingCell.metadata);
        if (recordingCell.cell_type === 'markdown') {
          // If this Graffiti was in a markdown cell we need to remove the span tags from the markdown source
          var contents = recordingCell.get_text();
          var spanRegex = RegExp('<span class="graffiti-highlight graffiti-' + recordingCellId + '-' + recordingKey + '"><i></i>(.*?)</span>', 'gm');
          var results = void 0,
              foundContents = [];
          while ((results = spanRegex.exec(contents)) !== null) {
            foundContents.push(results);
          };
          if (foundContents.length > 0) {
            var innerContents = foundContents[0][1];
            var sourceContents = '<span class="graffiti-highlight graffiti-' + recordingCellId + '-' + recordingKey + '"><i></i>' + innerContents + '</span>';
            var cleanedContents = contents.replace(sourceContents, innerContents);
            //console.log('cleanedContents of markdown:', cleanedContents);
            recordingCell.set_text(cleanedContents);
          }
        }

        storage.deleteMovie(recordingCellId, recordingKey);
        utils.saveNotebook(function () {
          graffiti.updateControlPanels();
        });
      },

      removeAllGraffitis: function removeAllGraffitis(graffitiDisabled) {
        var manifest = state.getManifest(); // save manifest before we wipe it out
        state.setManifest({}); // clear ALL graffiti in the manifest
        var recording = void 0,
            recordingCellId = void 0,
            recordingCell = void 0,
            recordingIds = void 0,
            recordingKeys = void 0,
            destructions = 0;
        var _iteratorNormalCompletion20 = true;
        var _didIteratorError20 = false;
        var _iteratorError20 = undefined;

        try {
          for (var _iterator20 = Object.keys(manifest)[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
            recordingCellId = _step20.value;

            console.log('Graffiti: Removing recordings from cell:', recordingCellId);
            recordingKeys = Object.keys(manifest[recordingCellId]);
            if (recordingKeys.length > 0) {
              recordingCell = utils.findCellByCellId(recordingCellId);
              var _iteratorNormalCompletion21 = true;
              var _didIteratorError21 = false;
              var _iteratorError21 = undefined;

              try {
                for (var _iterator21 = recordingKeys[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
                  recordingKey = _step21.value;

                  console.log('Graffiti: Removing recording id:', recordingKey);
                  recording = manifest[recordingCellId][recordingKey];
                  destructions++;
                  graffiti.removeGraffitiCore(recordingCell, recordingKey);
                  graffiti.refreshGraffitiHighlights({ cell: recordingCell, clear: true });
                  graffiti.refreshGraffitiSideMarkers(recordingCell);
                }
              } catch (err) {
                _didIteratorError21 = true;
                _iteratorError21 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion21 && _iterator21.return) {
                    _iterator21.return();
                  }
                } finally {
                  if (_didIteratorError21) {
                    throw _iteratorError21;
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError20 = true;
          _iteratorError20 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion20 && _iterator20.return) {
              _iterator20.return();
            }
          } finally {
            if (_didIteratorError20) {
              throw _iteratorError20;
            }
          }
        }

        storage.storeManifest();
        graffiti.highlightIntersectingGraffitiRange();
        graffiti.refreshGraffitiTooltips();
        graffiti.updateControlPanels();

        if (graffitiDisabled) {
          if (Jupyter.notebook.metadata.hasOwnProperty('graffiti')) {
            storage.deleteDataDirectory(Jupyter.notebook.metadata.graffiti.id);
            storage.removeGraffitiIds();
            graffiti.changeAccessLevel('view');
            graffiti.updateSetupButton();
          }
        }

        utils.saveNotebook(function () {

          if (destructions === 0) {
            destructions = 'all';
          }

          var title = void 0,
              body = void 0;
          if (graffitiDisabled) {
            title = 'Graffiti has been disabled on this Notebook.';
            body = 'We removed ' + destructions + ' graffitis, and you will need to Enable Graffiti again to use Graffiti in this notebook.' + 'You will also now want to remove the Graffiti data directory (jupytergraffiti_data) manually.';
          } else {
            title = 'Your notebook is now cleaned of all graffiti.';
            body = 'We removed ' + destructions + ' graffitis. Feel free to create new ones.';
          }
          dialog.modal({
            title: title,
            body: body,
            sanitize: false,
            buttons: {
              'OK': {
                click: function click(e) {
                  console.log('Graffiti: You clicked ok, you want to remove ALL graffitis');
                }
              }
            }
          });
        });
      },

      refreshAfterDeletions: function refreshAfterDeletions(recordingCell) {
        graffiti.highlightIntersectingGraffitiRange();
        graffiti.refreshGraffitiHighlights({ cell: recordingCell, clear: true });
        graffiti.refreshGraffitiSideMarkers(recordingCell);
        graffiti.refreshGraffitiTooltips();
        graffiti.updateControlPanels();
      },

      removeGraffiti: function removeGraffiti(recordingCell, recordingKey) {
        graffiti.removeGraffitiCore(recordingCell, recordingKey);
        if (state.removeManifestEntry(utils.getMetadataCellId(recordingCell.metadata), recordingKey)) {
          storage.storeManifest();
          graffiti.refreshAfterDeletions(recordingCell);
        }
      },

      removeAllGraffitisWithConfirmation: function removeAllGraffitisWithConfirmation() {
        dialog.modal({
          title: 'Are you sure you want to remove ALL graffitis from this notebook?',
          body: 'Note: this cannot be undone.',
          sanitize: false,
          buttons: {
            'OK': {
              click: function click(e) {
                console.log('Graffiti: You clicked ok, you want to remove ALL graffitis');
                graffiti.removeAllGraffitis(false);
              }
            },
            'Cancel': { click: function click(e) {
                console.log('Graffiti: you cancelled:', $(e.target).parent());
              } }
          }
        });
      },

      editSkips: function editSkips() {
        state.setEditingSkips(true);
        state.setReplacingSkips(true);
        graffiti.loadAndPlayMovie('tip');
      },

      // Confirm clearing any existing skips.
      clearAllSkipsWithConfirm: function clearAllSkipsWithConfirm() {
        var btn1 = localizer.getString('SKIPS_DIALOG_CONFIRM_1');
        var btn2 = localizer.getString('SKIPS_DIALOG_CANCEL');
        var btns = {};
        btns[btn1] = {
          click: function click(e) {
            console.log('Graffiti: You clicked ok, you want clear all skips.');
            state.clearSkipsRecords();
            graffiti.updateSkipsBar();
          }
        };
        btns[btn2] = {
          click: function click(e) {
            console.log('Graffiti: you cancelled:', $(e.target).parent());
          }
        };

        dialog.modal({
          title: localizer.getString('SKIPS_DIALOG_TITLE'),
          body: localizer.getString('SKIPS_DIALOG_BODY'),
          sanitize: false,
          buttons: btns
        });
      },

      removeUnusedTakes: function removeUnusedTakes(recordingFullId) {
        var parts = utils.parseRecordingFullId(recordingFullId);
        var recordingCell = utils.findCellByCellId(parts.recordingCellId);
        if (recordingCell !== undefined) {
          storage.removeUnusedTakes(parts.recordingCellId, parts.recordingKey);
          graffiti.refreshAfterDeletions(recordingCell);
        }
      },

      removeAllUnusedTakes: function removeAllUnusedTakes() {
        var manifest = state.getManifest(); // save manifest before we wipe it out
        var recording = void 0,
            recordingCellId = void 0,
            recordingCell = void 0,
            recordingIds = void 0,
            recordingKeys = void 0,
            deletedTakes = 0;
        var _iteratorNormalCompletion22 = true;
        var _didIteratorError22 = false;
        var _iteratorError22 = undefined;

        try {
          for (var _iterator22 = Object.keys(manifest)[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
            recordingCellId = _step22.value;

            console.log('Graffiti: Removing unused takes from cell:', recordingCellId);
            recordingKeys = Object.keys(manifest[recordingCellId]);
            if (recordingKeys.length > 0) {
              recordingCell = utils.findCellByCellId(recordingCellId);
              var _iteratorNormalCompletion23 = true;
              var _didIteratorError23 = false;
              var _iteratorError23 = undefined;

              try {
                for (var _iterator23 = recordingKeys[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
                  recordingKey = _step23.value;

                  console.log('Graffiti: Removing unused takes from recording id:', recordingKey);
                  recording = manifest[recordingCellId][recordingKey];
                  deletedTakes += storage.removeUnusedTakesCore(recordingCellId, recordingKey);
                }
              } catch (err) {
                _didIteratorError23 = true;
                _iteratorError23 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion23 && _iterator23.return) {
                    _iterator23.return();
                  }
                } finally {
                  if (_didIteratorError23) {
                    throw _iteratorError23;
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError22 = true;
          _iteratorError22 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion22 && _iterator22.return) {
              _iterator22.return();
            }
          } finally {
            if (_didIteratorError22) {
              throw _iteratorError22;
            }
          }
        }

        storage.storeManifest();
        graffiti.highlightIntersectingGraffitiRange();
        graffiti.refreshGraffitiTooltips();
        graffiti.updateControlPanels();

        utils.saveNotebook(function () {
          if (deletedTakes === 0) {
            deletedTakes = 'all';
          } else {
            storage.storeManifest();
            storage.cleanUpExecutorCell();
            utils.saveNotebook();
          }

          var title = 'Unused takes removed.';
          var body = 'We removed ' + deletedTakes + ' unused takes.';
          dialog.modal({
            title: title,
            body: body,
            sanitize: false,
            buttons: {
              'OK': {
                click: function click(e) {
                  console.log('Graffiti: You clicked ok');
                }
              }
            }
          });
        });
      },

      removeAllUnusedTakesWithConfirmation: function removeAllUnusedTakesWithConfirmation() {
        dialog.modal({
          title: 'Are you sure you want to remove ALL unused takes from this notebook?',
          body: 'Note: this cannot be undone.',
          sanitize: false,
          buttons: {
            'OK': {
              click: function click(e) {
                console.log('Graffiti: You clicked ok, you want to remove unused takes.');
                graffiti.removeAllUnusedTakes();
              }
            },
            'Cancel': { click: function click(e) {
                console.log('Graffiti: you cancelled:', $(e.target).parent());
              } }
          }
        });
      },

      removeUnusedTakesWithConfirmation: function removeUnusedTakesWithConfirmation(recordingFullId) {
        dialog.modal({
          title: 'Are you sure you want to remove unused takes from this recording?',
          body: 'Note: this cannot be undone.',
          sanitize: false,
          buttons: {
            'OK': {
              click: function click(e) {
                console.log('Graffiti: You clicked ok, you want to remove unused takes.');
                graffiti.removeUnusedTakes(recordingFullId);
              }
            },
            'Cancel': { click: function click(e) {
                console.log('Graffiti: you cancelled:', $(e.target).parent());
              } }
          }
        });
      },

      removeGraffitiWithPrompt: function removeGraffitiWithPrompt() {
        if (graffiti.selectedTokens.isIntersecting) {
          var recordingCell = graffiti.selectedTokens.recordingCell;
          var recordingCellId = utils.getMetadataCellId(recordingCell.metadata);
          var _recordingKey5 = graffiti.selectedTokens.recordingKey;
          var recording = state.getManifestSingleRecording(recordingCellId, _recordingKey5);
          var content = '(Please Note: this cannot be undone.)<br/>' + '<b>Graffiti\'d text:&nbsp;</b><span class="graffiti-text-display">' + recording.allTokensString + '</span><br/>' + '<b>Graffiti contents:</b>' + utils.renderMarkdown(recording.markdown) + '<br/>';

          var confirmModal = dialog.modal({
            title: 'Are you sure you want to remove this Graffiti?',
            body: content,
            sanitize: false,
            buttons: {
              'OK': {
                click: function click(e) {
                  console.log('Graffiti: you clicked ok, you want to remove graffiti:', $(e.target).parent());
                  graffiti.removeGraffiti(recordingCell, _recordingKey5);
                }
              },
              'Cancel': { click: function click(e) {
                  console.log('Graffiti: you cancelled:', $(e.target).parent());
                } }
            }
          });
          confirmModal.on('hidden.bs.modal', function (e) {
            console.log('Graffiti: escaped the removeGraffitiWithPrompt modal.');
          });
        }
      },

      // Remove all graffiti and remove the graffiti id's as well. Basically, return a notebook to a pre-graffiti-ized state.
      disableGraffiti: function disableGraffiti() {
        graffiti.removeAllGraffitis(true);
      },

      disableGraffitiWithConfirmation: function disableGraffitiWithConfirmation() {
        var content = 'Clicking OK will <i>remove any trace of Graffiti</i> in this notebook, setting it to a state as if you had never enabled Graffiti. ' + '<br><br><b>NOTE</b>: This <b>cannot</b> be undone.';
        var confirmModal = dialog.modal({
          title: 'Are you sure you want to disable Graffiti?',
          body: content,
          sanitize: false,
          buttons: {
            'OK': {
              click: function click(e) {
                console.log('Graffiti: you clicked ok, you want to disable graffiti:', $(e.target).parent());
                graffiti.disableGraffiti();
              }
            },
            'Cancel': { click: function click(e) {
                console.log('Graffiti: you cancelled:', $(e.target).parent());
              } }
          }
        });
      },

      updateAllGraffitiDisplays: function updateAllGraffitiDisplays() {
        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltipsDebounced();
      },

      //
      // Recording control functions
      //

      setPendingRecording: function setPendingRecording() {
        console.log('Graffiti: Setting pending recording.');
        graffiti.changeActivity('recordingPending');
        state.restoreCellStates('selections'); // reset selections to when you clicked to begin the recording
      },

      beginMovieRecordingProcess: function beginMovieRecordingProcess(isOldGraffiti, recordingRecord) {
        // Preserve the state of all cells and selections before we begin recording so we can restore when the recording is done.
        state.storeCellStates();
        graffiti.preRecordingScrollTop = state.getScrollTop();
        state.setMovieRecordingStarted(true);
        if (recordingRecord === undefined) {
          recordingRecord = graffiti.storeRecordingInfoInCell(isOldGraffiti);
        }
        if (recordingRecord.cellType === 'markdown') {
          if (!graffiti.selectedTokens.noTokensPresent) {
            graffiti.selectedTokens.recordingCell.render();
          }
        }
        graffiti.setPendingRecording();
      },

      addCMEventsToSingleCell: function addCMEventsToSingleCell(cell) {
        graffiti.CMEvents[utils.getMetadataCellId(cell.metadata)] = true;
        var cm = cell.code_mirror;
        cm.on('focus', function (cm, e) {
          //console.log('Graffiti: CM focus:' , cm, e);
          // Check to see if we jumped from another cell to this cell with the arrow keys. If we did and we're recording, we need to
          // create a focus history record because jupyter is not firing the select cell event in those cases.

          // debugging lack of focus in input text field
          //          const focusCell = utils.findCellByCodeMirror(cm);
          //          const focusCellId = utils.getMetadataCellId(focusCell.metadata);
          //          console.log('focus cellId:', focusCellId);

          var activity = state.getActivity();
          if (activity === 'recording') {
            var cellId = utils.getMetadataCellId(cell.metadata);
            if (cellId !== state.getSelectedCellId()) {
              state.saveSelectedCellId(cellId);
            }
            state.storeHistoryRecord('focus');
          } else if (activity === 'recordingPending') {
            graffiti.toggleRecording();
          }
          graffiti.updateControlPanels(cm); // this is necessary since a focus change can happen when you arrow advance from one cell to the next cell
        });

        cm.on('cursorActivity', function (cm, e) {
          //console.log('cursorActivity');
          if (state.getActivity() === 'idle') {
            graffiti.updateControlPanels(cm); // this is necessary because you can move the cursor from inside a graffiti to outside one
          }
          //console.log('graffiti.selectedTokens:', graffiti.selectedTokens);
          var affectedCell = utils.findCellByCodeMirror(cm);
          if (affectedCell === undefined) {
            utils.refreshCellMaps();
            affectedCell = utils.findCellByCodeMirror(cm);
            console.log('Graffiti: cursorActivity handler had to refreshCellMaps twice. Should never occur!');
          }
          state.storeCellIdAffectedByActivity(utils.getMetadataCellId(affectedCell.metadata));
          state.storeHistoryRecord('selections');
          graffiti.refreshGraffitiSideMarkers(affectedCell);
        });

        cm.on('change', function (cm, changeObj) {
          //console.log('change activity:', changeObj);
          var affectedCell = utils.findCellByCodeMirror(cm);
          if (affectedCell !== undefined) {
            state.storeCellIdAffectedByActivity(utils.getMetadataCellId(affectedCell.metadata));
            state.storeHistoryRecord('contents');
            if (state.getActivity() === 'idle') {
              state.setHighlightsRefreshCellId(utils.getMetadataCellId(affectedCell.metadata));
              setTimeout(graffiti.updateRefreshableCell, 250); // set up to refresh side markers shortly after changes
            }
          }
        });

        cm.on('mousedown', function (cm, e) {
          //console.log('mousedown, e:', e);
        });

        cm.on('refresh', function (cm, e) {
          //console.log('**** CM refresh event ****');
        });

        cm.on('update', function (cm, e) {
          //console.log('**** CM update event ****');
          graffiti.refreshGraffitiTooltipsDebounced();
        });

        cm.on('scroll', function (cm, e) {
          var pointerPosition = state.getPointerPosition();
          var viewInfo = utils.collectViewInfo(pointerPosition.x, pointerPosition.y, graffiti.notebookPanel.height(), graffiti.sitePanel.scrollTop() - state.getScrollTop());

          state.setScrollTop(graffiti.sitePanel.scrollTop());
          state.storeViewInfo(viewInfo);
          state.storeHistoryRecord('innerScroll');
        });
      },

      addCMEventsToCells: function addCMEventsToCells() {
        var inputCells = Jupyter.notebook.get_cells();
        var _iteratorNormalCompletion24 = true;
        var _didIteratorError24 = false;
        var _iteratorError24 = undefined;

        try {
          for (var _iterator24 = inputCells[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
            var _cell3 = _step24.value;

            // Don't rebind if already bound
            if (!graffiti.CMEvents.hasOwnProperty(utils.getMetadataCellId(_cell3.metadata))) {
              graffiti.addCMEventsToSingleCell(_cell3);
            }
          }
        } catch (err) {
          _didIteratorError24 = true;
          _iteratorError24 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion24 && _iterator24.return) {
              _iterator24.return();
            }
          } finally {
            if (_didIteratorError24) {
              throw _iteratorError24;
            }
          }
        }
      },

      // Bind all select, create, delete, execute  cell events at the notebook level
      addCMEvents: function addCMEvents() {
        graffiti.addCMEventsToCells();

        Jupyter.notebook.events.on('select.Cell', function (e, cell) {
          // console.log('cell select event fired, e, cell:',e, cell.cell);
          //console.log('select cell store selections');
          state.storeHistoryRecord('selectCell');
          graffiti.refreshGraffitiTooltipsDebounced();
          graffiti.updateControlPanels();
        });

        Jupyter.notebook.events.on('create.Cell', function (e, results) {
          //console.log('create.Cell fired');
          //console.log(results);
          var newCell = results.cell;
          var newCellIndex = results.index;
          var newCellId = void 0;
          if (utils.getMetadataCellId(newCell.metadata) === undefined) {
            // Do not assign a graffiti id if we already have one. This may happen when applyCellListToNotebook is reinserting cells from the history
            // and has set the new cell's id to the value of a historical cell's id.
            newCellId = utils.setMetadataCellId(newCell.metadata, utils.generateUniqueId());
          } else {
            newCellId = utils.getMetadataCellId(newCell.metadata);
          }
          utils.refreshCellMaps();
          graffiti.addCMEventsToSingleCell(newCell);
          state.storeCellAddition(newCellId, newCellIndex);
          state.storeHistoryRecord('contents');
        });

        Jupyter.notebook.events.on('delete.Cell', function (e, results) {
          utils.refreshCellMaps();
          var deletedCell = results.cell;
          if (deletedCell !== undefined) {
            var deletedCellId = utils.getMetadataCellId(deletedCell.metadata);
            if (deletedCellId !== undefined) {
              graffiti.removeCanvasRecordsForCell(deletedCellId);
              terminalLib.removeTerminal(deletedCellId);
            }
          }
          state.storeHistoryRecord('contents');
        });

        Jupyter.notebook.events.on('finished_execute.CodeCell', function (e, results) {
          //console.log('Graffiti: Finished execution event fired, e, results:',e, results);
          utils.refreshCellMaps();
          state.storeHistoryRecord('contents');
          graffiti.resizeCanvases();
          graffiti.redrawAllDrawingsWhenRecording(); // need to do this because resizeCanvases erases all canvases
        });

        // Because we get this event when output is sent but before it's rendered into the dom, we set up to collect
        // the output on the next tick rather than this loop.
        Jupyter.notebook.events.on('set_dirty.Notebook', function (e, results) {
          // console.log('Graffiti: set_dirty.Notebook, e, results:',e, results);
          utils.refreshCellMaps();
          graffiti.runOnceOnNextRecordingTick = function () {
            state.storeHistoryRecord('contents');
          };
        });

        Jupyter.notebook.events.on('rendered.MarkdownCell', function (e, results) {
          var activity = state.getActivity();
          if (activity === 'graffiting' && utils.getMetadataCellId(results.cell.metadata) === state.getGraffitiEditCellId()) {
            // When creating Graffitis for markdown cells, the user can also save the Graffiti by rendering the target
            // markdown cell rather than the editing cell. Some content creators get confused and do this, so we support it.
            var lastEditActivityTime = state.getLastEditActivityTime();
            if (lastEditActivityTime !== undefined && utils.getNow() - lastEditActivityTime > 250) {
              console.log('Graffiti: rendered MarkdownCell event fired and editing with long enough delay, so finishing graffiti. e, results:', e, results);
              graffiti.finishGraffiti(true);
              state.clearLastEditActivityTime();
            }
          }
          graffiti.refreshAllGraffitiHighlights();
        });

        Jupyter.notebook.events.on('shell_reply.Kernel', function (e, results) {
          // console.log('Graffiti: Kernel shell reply event fired, e, results:',e, results);
          utils.refreshCellMaps();
          var activity = state.getActivity();
          if (activity === 'idle') {
            graffiti.updateAllGraffitiDisplays();
            graffiti.updateControlPanels(); // necessary because we just finished a save
          }
        });
      },

      //
      // End a movie recording currently underway.
      //
      stopRecordingCore: function stopRecordingCore(useCallback) {
        audio.setExecuteCallback(useCallback);
        graffiti.clearCanvases('all');
        graffiti.hideDrawingScreen();
        graffiti.resetDrawingColor();
        state.storeTerminalsContentsInHistory();
        state.setSpeakingStatus(false); // if we were still speaking, record a history record that will terminate that state during playback.
        state.finalizeHistory();
        state.addSpeakingLimitsSkipRecords();
        if (useCallback) {
          state.dumpHistory();
        }
        state.clearAnimationIntervals();

        // This will use the callback defined in setAudioStorageCallback to actually persist the
        // whole recording, if useCallback (passed in to this fn) is true.
        audio.stopRecording();
        console.log('Graffiti: stopRecordingCore is refreshing.');
        state.restoreCellStates('contents');
        graffiti.updateAllGraffitiDisplays();
        graffiti.wipeAllStickerDomCanvases();
        graffiti.resetStickerCanvases();
        graffiti.deactivateAllPens();
        graffiti.removeCellsAddedByPlaybackOrRecording();
        graffiti.hideLabelInputBoxes();
        state.restoreCellStates('selections');
        state.restoreLineNumbersStates();
        graffiti.sitePanel.animate({ scrollTop: graffiti.preRecordingScrollTop }, 750);
        graffiti.selectIntersectingGraffitiRange();
        state.deleteTrackingArrays();
        state.clearDisplayedTipInfo();
        terminalLib.saveOrRestoreTerminalOutputs('restore');
        graffiti.changeActivity('idle');
      },

      cancelPendingRecording: function cancelPendingRecording() {
        var currentActivity = state.getActivity();
        console.log('Graffiti: canceling recording, current activity:', currentActivity);
        if (currentActivity === 'recordingPending') {
          graffiti.changeActivity('idle');
        }
      },

      cancelRecording: function cancelRecording() {
        var currentActivity = state.getActivity();
        console.log('Graffiti: canceling recording, current activity:', currentActivity);
        if (currentActivity === 'recording') {
          var recordingCellInfo = state.getRecordingCellInfo();
          var mustStoreManifest = false;
          if (recordingCellInfo.newRecording) {
            state.removeManifestEntry(recordingCellInfo.recordingCellId, recordingCellInfo.recordingKey);
            mustStoreManifest = true;
          }
          if (graffiti.previousActiveTakeId !== undefined) {
            storage.updateSingleManifestRecordingField(recordingCellInfo.recordingCellId, recordingCellInfo.recordingKey, 'activeTakeId', graffiti.previousActiveTakeId);
            mustStoreManifest = false; // updateSingleManifestRecordingField does manifest store for us.
          }
          if (mustStoreManifest) {
            storage.storeManifest();
          }
          graffiti.stopRecordingCore(false);
          // utils.saveNotebook( () => { console.log('Graffiti: cancelled recording.') });;
        }
      },

      toggleRecording: function toggleRecording() {
        var currentActivity = state.getActivity();
        if (currentActivity !== 'playing') {
          if (currentActivity === 'recording') {

            //
            // End movie recording.
            //

            console.log('Graffiti: Now starting movie recording');
            state.blockRecording(); // this is here because a race condition can happen right at the end of recording
            graffiti.setNotifier(localizer.getString('PLEASE_WAIT_STORING_MOVIE'));
            graffiti.showControlPanels(['graffiti-notifier']);
            graffiti.showSavingScrim();
            storage.setMovieCompleteCallback(graffiti.hideSavingScrim);
            graffiti.stopRecordingCore(true);
            state.unblockRecording();
            graffiti.clearJupyterMenuHint();
            console.log('Graffiti: Stopped recording.');
          } else {

            //
            // Start new movie recording.
            //

            var recordingCellInfo = state.getRecordingCellInfo();
            if (recordingCellInfo == undefined) {
              // Error condition, cannot start recording without an active cell
              console.log('Graffiti: Cannot begin recording, no cell chosen to store recording.');
              return;
            }
            console.log('Graffiti: Begin recording for cell id:', recordingCellInfo.recordingCellId);

            terminalLib.saveOrRestoreTerminalOutputs('save');
            state.resetPlayState();
            graffiti.changeActivity('recording');
            utils.assignCellIds();
            state.initHistory({
              storageCellId: recordingCellInfo.recordingCellId
            });
            state.clearCellAdditions();

            audio.startRecording();
            state.setScrollTop(graffiti.sitePanel.scrollTop());
            state.updateDrawingState([{ change: 'drawingModeActivated', data: false }, { change: 'drawingActivity', data: 'idle' }, { change: 'penType', data: undefined }, { change: 'opacity', data: state.getMaxDrawingOpacity() }]);
            graffiti.resetDrawingPen();
            state.disableDrawingFadeClock(); // initially, we don't fade since nothing drawn yet

            state.startAnimationInterval('recording', function () {
              //console.log('Moving recording time ahead');
              if (graffiti.runOnceOnNextRecordingTick !== undefined) {
                graffiti.runOnceOnNextRecordingTick();
                graffiti.runOnceOnNextRecordingTick = undefined;
              }
              graffiti.updateTimeDisplay(state.getTimeRecordedSoFar());
              graffiti.updateDrawingOpacity();
            }, graffiti.recordingIntervalMs);

            // Flash a red recording bullet while recording is ongoing, every second. 
            state.startAnimationInterval('recordingIndicator', function () {
              if (state.getTimeRecordedSoFar() % 2000 > 1000) {
                $('#graffiti-recording-flash-icon').css({ background: 'rgb(245,245,245)' });
              } else {
                $('#graffiti-recording-flash-icon').css({ background: 'rgb(255,0,0)' });
              }
            }, graffiti.recordingIntervalMs);

            graffiti.setJupyterMenuHint(localizer.getString('RECORDING_HINT_1'));
            console.log('Graffiti: Started recording');
          }
        }
      },

      changeActivity: function changeActivity(newActivity) {
        if (state.getActivity() === newActivity) {
          console.log('Graffiti: state is already :', newActivity, 'not changing it');
          return; // no change to activity
        }
        state.setActivity(newActivity);
        graffiti.updateControlPanels();
      },

      //
      // Movie playback code begins
      //

      applyScrollNudge: function applyScrollNudge(position, record, useTrailingVelocity) {
        //console.log('applyScrollNudge, useTrailingVelocity:', useTrailingVelocity);
        var clientHeight = document.documentElement.clientHeight;
        var topbarHeight = $('#header').height();
        //const bufferY = clientHeight / 9;
        var bufferY = clientHeight / 6;
        var minAllowedCursorY = topbarHeight + bufferY;
        var maxAverageVelocity = 0.5;
        var minBottomBufferY = 150; // approximately 1.5x the height of bottom bar in udacity classroom
        var maxAllowedCursorY = clientHeight - Math.max(bufferY, minBottomBufferY);
        var mustNudgeCheck = !useTrailingVelocity;
        var nudgeIncrements = graffiti.scrollNudgeQuickIncrements;

        // Watch trailing average of cursor. If the average over twenty samples is in a nudge zone, then nudge
        if (useTrailingVelocity) {
          nudgeIncrements = state.getActivity === 'scrubbing' ? 1.0 : graffiti.scrollNudgeSmoothIncrements;
          //const trailingAverageSize = 85;
          var trailingAverageSize = 10;
          if (graffiti.scrollNudgeAverages.length > 0) {
            if (graffiti.scrollNudgeAverages[graffiti.scrollNudgeAverages.length - 1].x === position.x && graffiti.scrollNudgeAverages[graffiti.scrollNudgeAverages.length - 1].y === position.y || graffiti.scrollNudgeAverages[graffiti.scrollNudgeAverages.length - 1].t === record.startTime) {
              return; // cursor didn't move or time didn't change, dont record velocity
            }
          }
          if (record.inTopBarArea !== undefined && record.inTopBarArea) {
            //console.log('Ignoring cursor activity recorded above the site panel');
            return; // ignore the cursor when it is above the site panel
          }
          graffiti.scrollNudgeAverages.push({ t: record.startTime, pos: { x: position.x, y: position.y } });
          if (graffiti.scrollNudgeAverages.length > trailingAverageSize) {
            graffiti.scrollNudgeAverages.shift();
            var velocities = [],
                distance = void 0,
                timeDiff = void 0;
            for (var i = 1; i < graffiti.scrollNudgeAverages.length; ++i) {
              // This is highly mathematically inefficient but maybe in this scale of things, it's ok.
              distance = Math.sqrt(Math.pow(graffiti.scrollNudgeAverages[i].pos.y - graffiti.scrollNudgeAverages[i - 1].pos.y, 2) + Math.pow(graffiti.scrollNudgeAverages[i].pos.x - graffiti.scrollNudgeAverages[i - 1].pos.x, 2));
              timeDiff = graffiti.scrollNudgeAverages[i].t - graffiti.scrollNudgeAverages[i - 1].t;
              velocities.push(distance / timeDiff);
            }
            var averageVelocity = Math.abs(utils.computeArrayAverage(velocities));
            //console.log('averageVelocity:', averageVelocity);
            mustNudgeCheck = mustNudgeCheck || averageVelocity < maxAverageVelocity;
          }
        }

        // console.log('averageVelocity:', averageVelocity, velocities, graffiti.scrollNudgeAverages);
        if (mustNudgeCheck) {
          // If we are scrubbing, do not nudge but immediately push the correct spot into view by setting the increment divider to 1 so we jump the 
          // full amount all at once.
          var nudging = false,
              nudgeAmount = void 0;
          if (position.y < minAllowedCursorY) {
            nudgeAmount = (position.y - minAllowedCursorY) / nudgeIncrements;
            nudging = true;
          } else if (position.y > maxAllowedCursorY) {
            nudgeAmount = (position.y - maxAllowedCursorY) / nudgeIncrements;
            nudging = true;
          }
          if (nudging) {
            /*
               console.log('Graffiti: nudgeAmount', nudgeAmount, 'position', position.x, position.y,
               'minAllowedCursorY',minAllowedCursorY, 'maxAllowedCursorY', maxAllowedCursorY, 
               'nudgeIncrements', nudgeIncrements, 'bufferY', bufferY, 'useTrailingVelocity', useTrailingVelocity);
             */
            graffiti.scrollNudge = {
              counter: nudgeIncrements,
              amount: nudgeAmount
            };
            //console.log('nudging:', graffiti.scrollNudge.amount);
          } else {
              //console.log('not nudging, y', position.y, 'maxY', maxAllowedCursorY);
            }
        }
      },

      applyScrollNudgeAtCell: function applyScrollNudgeAtCell(cell, record, selChange) {
        var cellId = utils.getMetadataCellId(cell.metadata);
        var cellRects = utils.getCellRects(cell);
        var selectionRecord = void 0,
            selections = void 0;
        if (record.cellsSelections !== undefined) {
          selectionRecord = record.cellsSelections[cellId];
        }
        if (selectionRecord !== undefined) {
          selections = selectionRecord.selections;
        } else {
          var code_mirror = cell.code_mirror;
          selections = code_mirror.listSelections();
        }

        if (selections.length !== 0) {
          var cellOffsetY = selections[0].head.line * (graffiti.cmLineHeight + graffiti.cmLineFudge);
          var offsetPosition = {
            x: cellRects.innerCellRect.left,
            y: cellOffsetY + cellRects.innerCellRect.top
            //console.log('applyScrollNudgeAtCell:offsetPosition:', offsetPosition, 'cellId', cellId, 'selChange', selChange);
          };graffiti.applyScrollNudge(offsetPosition, record, false);
        }
      },

      calculateMappedScrollDiff: function calculateMappedScrollDiff(record) {
        var currentNotebookPanelHeight = graffiti.notebookPanel.height();
        var mappedScrollDiff = 0;
        if (record !== undefined) {
          mappedScrollDiff = record.scrollDiff / record.notebookPanelHeight * currentNotebookPanelHeight;
        }
        return mappedScrollDiff;
      },

      doScrollNudging: function doScrollNudging(record, viewIndex) {
        var currentScrollTop = graffiti.sitePanel.scrollTop();
        var newScrollTop = currentScrollTop;
        mappedScrollDiff = graffiti.calculateMappedScrollDiff(record);
        if (graffiti.scrollNudge !== undefined) {
          //console.log('updateDisplay, nudgeAmount:', graffiti.scrollNudge.amount, 'counter:', graffiti.scrollNudge.counter);
          if (graffiti.scrollNudge !== undefined) {
            var scrollNudgeAmount = 0;
            graffiti.scrollNudge.counter--;
            if (graffiti.scrollNudge.counter > 0) {
              scrollNudgeAmount = graffiti.scrollNudge.amount;
              //console.log('Going to nudge scroll by:', scrollNudgeAmount, 'counter:', graffiti.scrollNudge.counter);
              newScrollTop = currentScrollTop + scrollNudgeAmount;
            } else {
              graffiti.scrollNudge = undefined; // stop nudging
            }
          }
        }
        // Only apply a user-recorded scroll diff if we haven't applied it already. When this function is called with no parameters, then
        // it is only doing "maintenance nudging", ie over-time nudging to keep the most important zones of interest in the viewport.
        // console.log('Now applying mappedScrollDiff:', mappedScrollDiff);
        var skipMappedScrollDiff = viewIndex !== undefined && graffiti.lastScrollViewId !== undefined && graffiti.lastScrollViewId === viewIndex;
        //console.log('skipMappedScrollDiff', skipMappedScrollDiff);
        if (!skipMappedScrollDiff) {
          newScrollTop += mappedScrollDiff;
          graffiti.lastScrollViewId = viewIndex;
        }

        graffiti.setSitePanelScrollTop(newScrollTop);
      },

      updateDrawingCore: function updateDrawingCore(record) {
        //console.log('updateDrawingCore:', record);
        record.hoverCell = utils.findCellByCellId(record.cellId);

        switch (record.drawingActivity) {
          case 'draw':
            graffiti.placeCanvas(record.cellId, record.pen.permanence);
            graffiti.setCanvasStyle(record.cellId, record.pen.type, record.pen.dash, record.pen.color, record.pen.permanence);
            // console.log('inPromptArea:', record.pen.inPromptArea, 'downInMarkdown:', record.pen.downInMarkdown );
            var positions = graffiti.processPositionsForCellTypeScaling(record, 'positions');
            graffiti.updateDrawingDisplay(record.cellId, positions.start.x, positions.start.y, positions.end.x, positions.end.y, record.pen.type, record.pen.permanence);
            break;
          case 'sticker':
            graffiti.drawStickersForCell(record.cellId, record);
            break;
          case 'fade':
            $('.graffiti-canvas-type-temporary').css({ opacity: record.opacity });
            break;
          case 'wipe':
            graffiti.clearCanvases('temporary');
            graffiti.wipeTemporaryStickerDomCanvases();
            break;
        }
      },

      updateDrawings: function updateDrawings(drawingFrameIndex) {
        if (drawingFrameIndex === undefined) {
          return; // no drawings yet at this index
        }

        // console.log('updateDrawings');
        // Need to process a range of records if that's required.
        var startIndex = drawingFrameIndex.rangeStart === undefined ? drawingFrameIndex.index : drawingFrameIndex.rangeStart;
        var endIndex = drawingFrameIndex.index;
        var index = void 0,
            record = void 0;
        for (index = startIndex; index <= endIndex; ++index) {
          record = state.getHistoryItem('drawings', index);
          graffiti.updateDrawingCore(record);
        }
      },

      updatePointer: function updatePointer(record) {
        if (record.hoverCell !== undefined) {
          var offsetPositionScaled = graffiti.processPositionsForCellTypeScaling(record, 'cursor');
          var cellRects = utils.getCellRects(record.hoverCell);
          var offsetPosition = { x: cellRects.cellRect.left + offsetPositionScaled.start.x - graffiti.halfBullseye,
            y: cellRects.cellRect.top + offsetPositionScaled.start.y - graffiti.halfBullseye
          };
          graffiti.applyScrollNudge(offsetPosition, record, true);

          var lastPosition = state.getLastRecordedCursorPosition();
          if (offsetPosition.x !== lastPosition.x || offsetPosition.y !== lastPosition.y) {
            // Show cursor whenever it's moved by user
            //console.log('Showing cursor:', offsetPosition, lastPosition);
            graffiti.undimGraffitiCursor();
            var offsetPositionPx = { left: offsetPosition.x + 'px', top: offsetPosition.y + 'px' };
            graffiti.graffitiCursorShell.css(offsetPositionPx);
            var hoverCellId = record.cellId;
            if (terminalLib.isTerminalCell(hoverCellId)) {
              graffiti.activateTerminalGraffitiCursor();
            } else {
              graffiti.activateNormalGraffitiCursor();
            }
          }
          state.setLastRecordedCursorPosition(offsetPosition);
        }
      },

      updateView: function updateView(viewIndex) {
        //console.log('updateView, viewIndex:', viewIndex);
        var record = state.getHistoryItem('view', viewIndex);
        record.hoverCell = utils.findCellByCellId(record.cellId);

        // Make sure the hoverCell shows line numbers if they were visible during recording; otherwise all registration will be off
        // by the width of the line number gutter.
        if (record.hoverCell !== undefined) {
          // make sure we were actually hovering over a cell before we try to tweak the gutter.
          if (record.hasOwnProperty('lineNumbersVisible')) {
            // some early recordings won't have this property
            var cm = record.hoverCell.code_mirror;
            var currentlyVisible = cm.options.lineNumbers;
            if (record.lineNumbersVisible != cm.options.lineNumbers) {
              record.hoverCell.toggle_line_numbers();
            }
          }
        }

        // Select whatever cell is currently selected
        if (record.selectedCellId !== undefined) {
          var selectedCellIndex = utils.findCellIndexByCellId(record.selectedCellId); // we should use a map to speed this up
          //console.log('about to select index:', selectedCellIndex)
          Jupyter.notebook.select(selectedCellIndex);
        }

        // Handle pointer updates and canvas updates, as well as cell focus changes
        if (record.subType === 'pointer') {
          //console.log('pointerUpdate is true, record:', record);
          graffiti.updatePointer(record);
        } else {
          graffiti.dimGraffitiCursor();
          if (record.selectedCell !== undefined) {
            if (record.subType === 'focus' || record.subType === 'selectCell') {
              //console.log('processing focus/selectCell, record:', record);
              var selectedCell = utils.findCellByCellId(record.selectedCellId);
              if (selectedCell !== undefined) {
                if (utils.getMetadataCellId(record.selectedCell.metadata) === utils.getMetadataCellId(record.hoverCell.metadata)) {
                  selectedCell.focus_cell();
                  if (record.subType === 'focus') {
                    var code_mirror = selectedCell.code_mirror;
                    if (!code_mirror.state.focused) {
                      code_mirror.focus();
                    }
                    code_mirror.getInputField().focus();
                  }
                }
              }
            }
          }
        }

        if (record.hoverCell !== undefined) {
          var _cm = record.hoverCell.code_mirror;
          // Update innerScroll if required
          _cm.scrollTo(record.innerScroll.left, record.innerScroll.top);
          //console.log('updateView is calling doScrollNudging');
          graffiti.doScrollNudging(record, viewIndex);
        }
      },

      updateCellSelections: function updateCellSelections(cell, cm, selections) {
        var currentScrollTop = graffiti.sitePanel.scrollTop();
        cm.setSelections(selections);
        utils.refreshCodeMirrorSelection(cell);
        graffiti.setSitePanelScrollTop(currentScrollTop);
      },

      updateSelectedCellSelections: function updateSelectedCellSelections(currentScrollTop) {
        var selectedCell = Jupyter.notebook.get_selected_cell();
        utils.refreshCodeMirrorSelection(selectedCell);
        graffiti.setSitePanelScrollTop(currentScrollTop);
      },

      updateSelections: function updateSelections(index, currentScrollTop) {
        var record = state.getHistoryItem('selections', index);
        var cellId = void 0,
            cell = void 0,
            selectionRecord = void 0,
            selections = void 0,
            code_mirror = void 0,
            currentSelections = void 0,
            active = void 0;

        // If there were text selections in rendered markdown or rendered output during this frame, restore them first if we need to.
        if (record.textSelection !== undefined) {
          var _cellId2 = record.textSelection.cellId;
          var _cell4 = utils.findCellByCellId(_cellId2);
          var referenceNode = void 0;
          if (_cell4 !== undefined) {
            var cellType = _cell4.cell_type;
            // find the right reference node so we can highlight the correct text in either a markdown cell or a code cell output area
            if (cellType === 'markdown') {
              referenceNode = $(_cell4.element).find('.rendered_html')[0];
            } else {
              referenceNode = $(_cell4.element).find('.output_subarea')[0];
            }
            var currentSelection = selectionSerializer.get(referenceNode);
            if (!_.isEqual(currentSelection.state, record.textSelection.state)) {
              if (cellType === 'markdown') {
                // console.log('Graffiti: Focusing on markdown cell');
                _cell4.focus_cell();
                // we don't need to shrink if we focus the cell
                graffiti.setSitePanelScrollTop(currentScrollTop); // restore scrollTop because changing selections messes with it
              }
              // console.log('Graffiti: Selection restoring textSelection, currentSelection:', record.textSelection, currentSelection);
              record.textSelection.referenceNode = referenceNode;
              selectionSerializer.restore(record.textSelection);
            }
          }
        } else {
          var _iteratorNormalCompletion25 = true;
          var _didIteratorError25 = false;
          var _iteratorError25 = undefined;

          try {
            for (var _iterator25 = Object.keys(record.cellsSelections)[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
              cellId = _step25.value;

              selectionRecord = record.cellsSelections[cellId];
              selections = selectionRecord.selections;
              // active = selectionRecord.active;
              cell = utils.findCellByCellId(cellId);
              if (cell !== undefined) {
                code_mirror = cell.code_mirror;
                currentSelections = utils.cleanSelectionRecords(code_mirror.listSelections());
                //console.log('cellId, selections, currentSelections, subType:', cellId, selections, currentSelections, record.subType);

                if (!_.isEqual(selections, currentSelections)) {
                  graffiti.dimGraffitiCursor();

                  graffiti.updateCellSelections(cell, code_mirror, selections);

                  //console.log('nudge check, cellId', cellId, 'code_mirror.state.focused',code_mirror.state.focused);

                  if (code_mirror.state.focused) {
                    // If we made a selections update this frame, AND we are focused in it,
                    // make sure that we keep it in view. We need to compute the
                    // offset position of the *head* of the selection where the action is.
                    // console.log('setting selections with selections:', selections);
                    graffiti.applyScrollNudgeAtCell(cell, record, true);
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError25 = true;
            _iteratorError25 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion25 && _iterator25.return) {
                _iterator25.return();
              }
            } finally {
              if (_didIteratorError25) {
                throw _iteratorError25;
              }
            }
          }
        }
      },

      // After playback finishes, delete any cells added during playback.
      removeCellsAddedByPlaybackOrRecording: function removeCellsAddedByPlaybackOrRecording() {
        var cellAdditions = state.getCellAdditions(); // all cells added during this recording
        if (cellAdditions !== undefined) {
          var deleteCellIndex = void 0;
          var _iteratorNormalCompletion26 = true;
          var _didIteratorError26 = false;
          var _iteratorError26 = undefined;

          try {
            for (var _iterator26 = cellAdditions[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
              var cellId = _step26.value;

              deleteCellIndex = utils.findCellIndexByCellId(cellId);
              if (deleteCellIndex !== undefined) {
                //console.log('Going to delete:', cellId, 'at index:', deleteCellIndex);
                Jupyter.notebook.delete_cell(deleteCellIndex);
                utils.refreshCellMaps();
              }
            }
          } catch (err) {
            _didIteratorError26 = true;
            _iteratorError26 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion26 && _iterator26.return) {
                _iterator26.return();
              }
            } finally {
              if (_didIteratorError26) {
                throw _iteratorError26;
              }
            }
          }
        }
      },

      // At any timeframe add cells that were present during recording but aren't now, and remove any that were added by playback/scrub
      // but aren't present at this timeframe.
      applyCellListToNotebook: function applyCellListToNotebook(record) {
        var cellsPresentThisFrame = record.cellsPresentThisFrame;
        var cellsPresentIds = Object.keys(cellsPresentThisFrame);
        var numCellsPresent = cellsPresentIds.length;
        var mustRefreshCellMaps = false;
        var deletableCellId = void 0;
        if (numCellsPresent > 0) {
          // First figure out which cells are extra and need to be deleted on this cell
          var deleteCellId = void 0,
              deleteCellIndex = void 0;
          var cellAdditions = state.getCellAdditions(); // all cells added during this recording
          var cellAdditionsIds = Object.values(cellAdditions);
          // Any cells that may have been added during the movie, not present in this timeframe, must be deleted.
          var deletableCellIds = _.difference(cellAdditionsIds, cellsPresentIds);
          //console.log('deletableCellIds', deletableCellIds, cellAdditions, cellsPresentIds);
          var _iteratorNormalCompletion27 = true;
          var _didIteratorError27 = false;
          var _iteratorError27 = undefined;

          try {
            for (var _iterator27 = deletableCellIds[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
              deletableCellId = _step27.value;

              // console.log('Graffiti: Trying to delete cellid:', deletableCellId);
              deleteCellIndex = utils.findCellIndexByCellId(deletableCellId);
              if (deleteCellIndex !== undefined) {
                //console.log('Going to delete:', deleteCellId, 'at index:', deleteCellIndex);
                Jupyter.notebook.delete_cell(deleteCellIndex);
              }
            }

            // Now figure out which cells are missing and need to be added in. Add them in above whatever position 
            // they were recorded in, or right after the last present cell (whichever is greater), to try to match
            // its position from the recording time. This works ok because usually content creators will add a 
            // cell after another specific cell.
          } catch (err) {
            _didIteratorError27 = true;
            _iteratorError27 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion27 && _iterator27.return) {
                _iterator27.return();
              }
            } finally {
              if (_didIteratorError27) {
                throw _iteratorError27;
              }
            }
          }

          var i = void 0,
              checkCellId = void 0,
              foundCell = void 0,
              newCell = void 0,
              cellPosition = void 0,
              previousCellPosition = void 0,
              previousPlusOne = void 0;
          for (i = 0; i < cellsPresentIds.length; ++i) {
            checkCellId = cellsPresentIds[i];
            foundCell = utils.findCellByCellId(checkCellId);
            if (foundCell === undefined) {
              cellPosition = cellsPresentThisFrame[checkCellId];
              if (i > 0) {
                previousCellPosition = utils.findCellIndexByCellId(cellsPresentIds[i - 1]);
                previousPlusOne = previousCellPosition + 1;
                if (previousPlusOne > cellPosition) {
                  cellPosition = previousPlusOne;
                }
              }
              newCell = Jupyter.notebook.insert_cell_above('code', cellPosition);
              utils.setMetadataCellId(newCell.metadata, checkCellId);
              state.storePlaybackCellAddition(checkCellId, cellPosition);
              mustRefreshCellMaps = true;
              console.log('Graffiti: Just inserted new cell, cellId:', checkCellId, 'at position', cellPosition);
              // This causes excessive scrolling and isn't really necessary if the author moves the cursor to a new cell anyway
              // graffiti.applyScrollNudgeAtCell(newCell, record, false);
            }
          }
        }
        if (mustRefreshCellMaps) {
          utils.refreshCellMaps();
        }
      },

      // set_text() causes jupyter to scroll to top of cell so we need to restore scrollTop after calling this fn.
      updateContents: function updateContents(index, currentScrollTop) {
        var contentsRecord = state.getHistoryItem('contents', index);
        var cells = Jupyter.notebook.get_cells();
        var cellId = void 0,
            contents = void 0,
            outputs = void 0,
            frameContents = void 0,
            frameOutputs = void 0,
            renderedFrameOutput = false;
        graffiti.applyCellListToNotebook(contentsRecord);
        var _iteratorNormalCompletion28 = true;
        var _didIteratorError28 = false;
        var _iteratorError28 = undefined;

        try {
          for (var _iterator28 = cells[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
            var _cell5 = _step28.value;

            if (_cell5.cell_type === 'code') {
              cellId = utils.getMetadataCellId(_cell5.metadata);
              contents = _cell5.get_text();
              if (contentsRecord.cellsContent.hasOwnProperty(cellId)) {
                frameContents = state.extractDataFromContentRecord(contentsRecord.cellsContent[cellId].contentsRecord, cellId);
                if (frameContents !== undefined && frameContents !== contents) {
                  //console.log('Setting text on cellid:', utils.getMetadataCellId(cell.metadata));
                  _cell5.set_text(frameContents);
                }
                frameOutputs = state.extractDataFromContentRecord(contentsRecord.cellsContent[cellId].outputsRecord, cellId);
                renderedFrameOutput = renderedFrameOutput || state.restoreCellOutputs(_cell5, frameOutputs);
              }
            }
          }
        } catch (err) {
          _didIteratorError28 = true;
          _iteratorError28 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion28 && _iterator28.return) {
              _iterator28.return();
            }
          } finally {
            if (_didIteratorError28) {
              throw _iteratorError28;
            }
          }
        }

        graffiti.setSitePanelScrollTop(currentScrollTop); // restore scrollTop because changing selections messes with it
        if (renderedFrameOutput) {
          graffiti.resizeCanvases();
          graffiti.redrawAllDrawings();
        }
      },

      updateTerminals: function updateTerminals(index) {
        var record = state.getHistoryItem('terminals', index);
        var termRecords = record.terminals;
        var focusedTerminal = undefined;
        if (termRecords !== undefined) {
          var terminalsContents = state.getHistoryTerminalsContents();
          for (var i = 0; i < termRecords.length; ++i) {
            terminalLib.setTerminalContents($.extend(true, termRecords[i], {
              incremental: state.getActivity() === 'playing',
              terminalsContents: terminalsContents
            }));
            if (termRecords[i].isFocused) {
              focusedTerminal = termRecords[i].id;
            }
          }
        }
        terminalLib.focusTerminal(focusedTerminal);
      },

      updateSpeaking: function updateSpeaking(index) {
        var record = state.getHistoryItem('speaking', index);
        //console.log('Processing speaking record', index, record);
        if (state.scanningIsOn()) {
          if (record.speaking) {
            console.log('Begun speaking.');
            state.setCurrentPlaySpeed('scanInactive');
            state.setSpeakingStatus(true);
          } else {
            console.log('Stopped speaking.');
            state.setCurrentPlaySpeed('scanActive');
            state.setSpeakingStatus(false);
          }
          //          console.log('playTimes:regular', state.playTimes['regular'].total,
          //                      'scanActive:',  state.playTimes['scanActive'].total, 
          //                      'scanInactive', state.playTimes['scanInactive'].total);
          audio.updateAudioPlaybackRate();
        }
      },

      updateDisplay: function updateDisplay(frameIndexes) {
        var currentScrollTop = graffiti.sitePanel.scrollTop();
        if (state.shouldUpdateDisplay('contents', frameIndexes.contents)) {
          graffiti.updateContents(frameIndexes.contents.index, currentScrollTop);
        }
        if (state.shouldUpdateDisplay('selections', frameIndexes.selections)) {
          graffiti.updateSelections(frameIndexes.selections.index, currentScrollTop);
        }
        if (state.shouldUpdateDisplay('drawings', frameIndexes.drawings)) {
          if (state.getActivity() !== 'scrubbing') {
            // console.log('calling updateDrawings from updateDisplay');
            graffiti.updateDrawings(frameIndexes.drawings);
          }
        }
        if (state.shouldUpdateDisplay('terminals', frameIndexes.terminals)) {
          graffiti.updateTerminals(frameIndexes.terminals.index);
        }
        if (state.shouldUpdateDisplay('speaking', frameIndexes.speaking)) {
          //console.log(state.history.processed);
          graffiti.updateSpeaking(frameIndexes.speaking.index);
        }
        if (state.shouldUpdateDisplay('view', frameIndexes.view)) {
          graffiti.updateView(frameIndexes.view.index);
          //console.log('updated view:', frameIndexes.view.index, 'currentScrollTop', currentScrollTop, 'new scrollTop', graffiti.sitePanel.scrollTop());
        }
      },

      // update the timer display for play or recording
      updateTimeDisplay: function updateTimeDisplay(playedSoFar) {
        var activity = state.getActivity();
        var playTimeDisplay = utils.formatTime(playedSoFar, { includeMillis: false });
        var recordingTimeDisplay = utils.formatTime(playedSoFar, { includeMillis: true });
        var durationDisplay = utils.formatTime(state.getHistoryDuration(), { includeMillis: false });
        var totalTimeDisplay = void 0;
        if (activity === 'recording' || state.getEditingSkips()) {
          totalTimeDisplay = recordingTimeDisplay;
        } else {
          totalTimeDisplay = playTimeDisplay + '/' + durationDisplay;
        }
        var recorderTimeElem = activity === 'recording' ? $('#graffiti-time-display-recording') : $('#graffiti-time-display-playback');
        recorderTimeElem.text(totalTimeDisplay);
      },

      updateSlider: function updateSlider(playedSoFar) {
        var ratio = playedSoFar / state.getHistoryDuration();
        var sliderVal = ratio * 1000;
        //console.log('updateSlider, playedSoFar:', playedSoFar, 'sliderVal:', sliderVal);
        var slider = $('#graffiti-recorder-range');
        slider.val(sliderVal);
      },

      //
      // Playback functions
      //

      // When jumping around, or if we reached the end of playback and the next playback will reset to beginning, then we may need to attempt to recalculate 
      // and apply the raw scrollTop (excluding any nudging, so it's approximate).
      applyRawCalculatedScrollTop: function applyRawCalculatedScrollTop(viewIndex) {
        var record = void 0,
            i = void 0,
            calculatedScrollTop = graffiti.prePlaybackScrolltop;
        for (i = 0; i < viewIndex; ++i) {
          record = state.getHistoryItem('view', i);
          calculatedScrollTop += graffiti.calculateMappedScrollDiff(record);
        }
        graffiti.sitePanel.scrollTop(calculatedScrollTop);
      },

      // Skip around by X seconds forward or back.
      jumpPlayback: function jumpPlayback(direction, jumpAmount) {
        var previousPlayState = state.getActivity();
        graffiti.pausePlayback();
        var timeElapsed = state.getTimePlayedSoFar();
        //console.log('jumpPlayback timeElapsed',timeElapsed);
        var t = void 0,
            frameIndexes = void 0;
        if (state.scanningIsOn()) {
          t = state.findSpeakingStartNearestTime(timeElapsed, direction, jumpAmount);
        } else {
          t = Math.max(0, Math.min(timeElapsed + jumpAmount * 1000 * direction * state.getPlayRateScalar(), state.getHistoryDuration() - 1));
        }
        // console.log('Graffiti: t:', t);
        state.resetPlayTimes(t);
        frameIndexes = state.getHistoryRecordsAtTime(t);
        state.clearSetupForReset();
        state.resetProcessedArrays();
        graffiti.wipeAllStickerDomCanvases();
        graffiti.updateDisplay(frameIndexes);
        graffiti.updateSlider(t);
        graffiti.updateTimeDisplay(t);
        graffiti.updateSkipsBar();
        graffiti.redrawAllDrawings(t);
        if (previousPlayState === 'playing') {
          graffiti.startPlayback();
        }
        graffiti.updateAllGraffitiDisplays();
        graffiti.applyRawCalculatedScrollTop(frameIndexes.view.index);
      },

      handleSliderDrag: function handleSliderDrag() {
        // Handle slider drag
        var target = $('#graffiti-recorder-range');
        var timeLocation = target.val() / 1000;
        //console.log('handleSliderDrag, slider value:', target.val());
        var t = Math.min(state.getHistoryDuration() * timeLocation, state.getHistoryDuration() - 1);
        // Now we need to set the time we are going to start with if we play from here.
        state.resetPlayTimes(t);
        state.clearSetupForReset();
        state.resetProcessedArrays();
        graffiti.undimGraffitiCursor();
        var frameIndexes = state.getHistoryRecordsAtTime(t);
        graffiti.wipeAllStickerDomCanvases();
        graffiti.updateDisplay(frameIndexes); // can replay scroll diffs, and in playback use cumulative scroll diff
        graffiti.updateTimeDisplay(t);
        graffiti.updateSkipsBar();
        graffiti.redrawAllDrawings(t);
        graffiti.applyRawCalculatedScrollTop(frameIndexes.view.index);
      },

      handleTerminalsEvents: function handleTerminalsEvents(event) {
        if (state.getActivity() === 'recording') {
          // If we are recording, we need to record latest terminal output for replay
          //console.log('Terminal output event:', event.data.portion);
          state.storeTerminalsState([event]);
          state.storeHistoryRecord('terminals');
        }
      },

      pausePlaybackNoVisualUpdates: function pausePlaybackNoVisualUpdates() {
        if (state.getActivity() === 'playing') {
          graffiti.changeActivity('playbackPaused');
          audio.pausePlayback();
          //console.log('Graffiti: pausePlaybackNoVisualUpdates');
          state.setPlayTimeEnd();
          // Make sure, if some markdown was selected, that the active code_mirror textarea reengages to get keystrokes.
          graffiti.updateSelectedCellSelections(graffiti.sitePanel.scrollTop());
          state.updateUsageStats({
            type: 'play',
            data: {
              actions: ['updateCurrentPlayTime']
            }
          });
        }
      },

      // Pause any ongoing playback
      pausePlayback: function pausePlayback() {
        if (state.getActivity() !== 'playing') return;

        graffiti.pausePlaybackNoVisualUpdates();

        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltips();
        state.clearAnimationIntervals();
        utils.saveNotebook(function () {
          console.log('Graffiti: Stopped playback.');
        });
      },

      cancelPlaybackNoVisualUpdates: function cancelPlaybackNoVisualUpdates() {
        var accessLevel = state.getAccessLevel();
        graffiti.pausePlaybackNoVisualUpdates();
        state.updateUsageStats({
          type: 'play',
          data: {
            actions: ['updateTotalPlayTime']
          }
        });
        state.resetPlayState();
        graffiti.changeActivity('idle');
        if (state.getDontRestoreCellContentsAfterPlayback()) {
          console.log('Graffiti: not restoring cell contents.');
        } else {
          graffiti.removeCellsAddedByPlaybackOrRecording();
          state.restoreCellStates('contents');
          state.restoreCellStates('selections');
          state.restoreLineNumbersStates();
        }
        state.setDontRestoreCellContentsAfterPlayback(false); // make sure by default we restore contents.
        terminalLib.saveOrRestoreTerminalOutputs('restore'); // restore any terminals affected by playback
        utils.saveNotebook();
        console.log('Graffiti: Got these stats:', state.getUsageStats());
      },

      cancelPlaybackFinish: function cancelPlaybackFinish(cancelAnimation) {
        graffiti.resetStickerCanvases();
        graffiti.cancelRapidPlay();
        graffiti.graffitiCursorShell.hide();
        graffiti.clearCanvases('all');
        graffiti.refreshAllGraffitiHighlights();
        graffiti.refreshGraffitiTooltips();
        graffiti.updateControlPanels();
        graffiti.highlightIntersectingGraffitiRange();
        graffiti.clearJupyterMenuHint();

        if (cancelAnimation) {
          graffiti.sitePanel.animate({ scrollTop: graffiti.prePlaybackScrolltop }, 750);
        }
      },

      cancelPlayback: function cancelPlayback(opts) {
        console.log('Graffiti: cancelPlayback called');
        var activity = state.getActivity();
        if (activity !== 'playing' && activity !== 'playbackPaused' && activity !== 'scrubbing') {
          return;
        }

        console.log('Graffiti: Cancelling playback');
        graffiti.cancelPlaybackNoVisualUpdates();
        state.clearAnimationIntervals();
        state.clearNarratorInfo();
        if (state.getEditingSkips()) {
          state.finalizeSkipRecords();
          var skippedMovie = state.getPlayableMovie('tip');
          storage.writeOutMovieData(skippedMovie, state.getJSONHistory()).then(function () {
            state.setEditingSkips(false);
            graffiti.cancelPlaybackFinish(opts.cancelAnimation);
          });
        } else {
          graffiti.cancelPlaybackFinish(opts.cancelAnimation);
        }
      },

      startPlayback: function startPlayback() {
        // Start playback
        var activity = state.getActivity();
        // Prevent playing while playing already. Not sure how this occurs so trapping for it here
        if (activity === 'playing') {
          console.trace('Cannot start playing because already playing.');
          return;
        }

        console.log('Graffiti: Starting playback, current activity:', activity);
        if (activity === 'idle' || activity === 'notifying') {
          // If just starting to play back, store all cells current contents so we can restore them when you cancel playback.
          // utils.saveNotebook();
          state.setScrollTop(graffiti.sitePanel.scrollTop());
          state.setCurrentPlaySpeed('regular');
          state.setSpeakingStatus(false);
          terminalLib.clearTerminalsContentsPositions();
          state.resetPlayTimes();
          graffiti.updateSlider(0);
          graffiti.prePlaybackScrolltop = state.getScrollTop();
          graffiti.lastScrollViewId = undefined;
          graffiti.lastDrawIndex = undefined;
          graffiti.lastDrawingEraseIndex = undefined;
          state.storeCellStates();
          state.clearCellOutputsSent();
          terminalLib.saveOrRestoreTerminalOutputs('save');
          graffiti.scrollNudgeAverages = [];
          graffiti.setJupyterMenuHint(localizer.getString('PRESS_ESC_TO_END_MOVIE_PLAYBACK'));
          var stickerImageCandidateUrl = state.getStickerImageCandidateUrl();
          if (stickerImageCandidateUrl !== undefined) {
            state.setStickerImageUrl(stickerImageCandidateUrl);
          } else {
            state.setStickerImageUrl(undefined);
          }
          if (state.getEditingSkips()) {
            graffiti.updateSkipsBar();
          }
        }

        if (activity === 'idle' || activity === 'notifying' || activity === 'playbackPaused') {
          graffiti.clearCanvases('all');
        }

        graffiti.clearHighlightMarkText();
        graffiti.undimGraffitiCursor();
        graffiti.changeActivity('playing');
        graffiti.lastTemporaryCanvasClearViewIndex = -1;

        if (state.getResetOnNextPlay()) {
          console.log('Graffiti: Resetting for first/re play.');
          graffiti.clearCanvases('all');
          graffiti.wipeAllStickerDomCanvases();
          state.resetPlayState();
          graffiti.removeCellsAddedByPlaybackOrRecording();
          graffiti.applyRawCalculatedScrollTop(0);
        }

        if (state.getCurrentPlaySpeed() === 'scan') {
          state.setPlayTimeBegin('regular'); // all scanning playback starts at regular playback speed initially until speaking starts and ends
        }

        state.setPlaybackStartTime(utils.getNow() - state.getTimePlayedSoFar());
        state.setPlayStartTimeToNow();

        if (!state.getMute()) {
          audio.startPlayback(state.getTimePlayedSoFar());
        }

        // Set up main playback loop
        state.startAnimationInterval('playback', function () {
          //console.log('Moving playback time ahead.');
          var playedSoFar = state.getTimePlayedSoFar();
          var endOfPlayableTime = state.getHistoryDuration();
          if (playedSoFar >= endOfPlayableTime) {
            // reached end of recording naturally, so set up for restart on next press of play button
            //console.log('end of recording reached, playedSoFar:', playedSoFar, 'duration', state.getHistoryDuration());
            state.setupForReset();
            graffiti.togglePlayback();
          } else {
            graffiti.updateSlider(playedSoFar);
            graffiti.updateTimeDisplay(playedSoFar);
            var frameIndexes = state.getHistoryRecordsAtTime(playedSoFar);
            graffiti.updateDisplay(frameIndexes);
            //console.log('play interval, now=', utils.getNow());
            //
          }
        }, graffiti.playbackIntervalMs);
      },

      togglePlayback: function togglePlayback() {
        var activity = state.getActivity();
        if (activity !== 'recording') {
          if (activity === 'playing') {
            state.clearAnimationIntervals();
            if (state.getHidePlayerAfterPlayback() && state.getSetupForReset() && !state.getEditingSkips()) {
              graffiti.cancelPlayback({ cancelAnimation: true });
            } else {
              graffiti.pausePlayback();
              //console.log('total play time:', utils.getNow() - playStartedAt);
            }
          } else {
            graffiti.startPlayback();
            playStartedAt = utils.getNow();
            //console.log('started playback at:', playStartedAt);
          }
        }
      },

      // If there is a graffiti that has the autoplayAlways attribute set to true, play it immediately.
      // Otherwise, if there is one with autoplayOnce attribute set to true and it hasn't been played previously, play it immediately.
      playAutoplayGraffiti: function playAutoplayGraffiti() {
        var manifest = state.getManifest();
        var recordingCellId = void 0,
            recordingKeys = void 0,
            recording = void 0,
            autoplayGraffiti = void 0,
            autoplayedOnce = false;
        var _iteratorNormalCompletion29 = true;
        var _didIteratorError29 = false;
        var _iteratorError29 = undefined;

        try {
          for (var _iterator29 = Object.keys(manifest)[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
            recordingCellId = _step29.value;

            recordingKeys = Object.keys(manifest[recordingCellId]);
            if (recordingKeys.length > 0) {
              var _iteratorNormalCompletion30 = true;
              var _didIteratorError30 = false;
              var _iteratorError30 = undefined;

              try {
                for (var _iterator30 = recordingKeys[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
                  recordingKey = _step30.value;

                  recording = manifest[recordingCellId][recordingKey];
                  // console.log('Graffiti autoplay rec:', recording);
                  if (recording.autoplay !== undefined) {
                    if (autoplayGraffiti === undefined) {
                      if (recording.autoplay === 'always') {
                        autoplayGraffiti = { recordingCellId: recordingCellId, recordingKey: recordingKey };
                      } else if (recording.autoplay === 'once') {
                        if (!recording.playedOnce) {
                          autoplayGraffiti = { recordingCellId: recordingCellId, recordingKey: recordingKey };
                          recording.playedOnce = true;
                          autoplayedOnce = true;
                        }
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError30 = true;
                _iteratorError30 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion30 && _iterator30.return) {
                    _iterator30.return();
                  }
                } finally {
                  if (_didIteratorError30) {
                    throw _iteratorError30;
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError29 = true;
          _iteratorError29 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion29 && _iterator29.return) {
              _iterator29.return();
            }
          } finally {
            if (_didIteratorError29) {
              throw _iteratorError29;
            }
          }
        }

        if (autoplayGraffiti !== undefined) {
          graffiti.playRecordingById(autoplayGraffiti.recordingCellId, autoplayGraffiti.recordingKey);
          if (autoplayedOnce) {
            storage.storeManifest();
          }
        }
      },

      playMovieViaUserClick: function playMovieViaUserClick() {
        console.log('Graffiti: playMovieViaUserClick starts.');
        graffiti.cancelPlayback({ cancelAnimation: false });
        var playableMovie = state.getPlayableMovie('tip');
        if (playableMovie === undefined) {
          console.log('Graffiti: no playable movie known.');
          return;
        }
        //console.log('playableMovie', playableMovie);
        if (state.getDontRestoreCellContentsAfterPlayback()) {
          // If this movie is set to NOT restore cell contents, give the user a chance to opt-out of playback.
          var dialogContent = localizer.getString('REPLACE_CONFIRM_BODY_1');
          var modalButtons = {};
          modalButtons[localizer.getString('REPLACE_CONFIRM_BODY_2')] = {
            click: function click(e) {
              console.log('Graffiti: you want to preserve cell contents after playback.');
              // Must restore playable movie values because jupyter dialog causes the tip to hide, which clears the playableMovie
              state.setPlayableMovie('tip', playableMovie.recordingCellId, playableMovie.recordingKey);
              state.setDontRestoreCellContentsAfterPlayback(false);
              graffiti.loadAndPlayMovie('tip');
            }
          };
          modalButtons[localizer.getString('REPLACE_CONFIRM_BODY_3')] = {
            click: function click(e) {
              // Must restore playable movie values because jupyter dialog causes the tip to hide, which clears the playableMovie
              state.setPlayableMovie('tip', playableMovie.recordingCellId, playableMovie.recordingKey);
              state.setDontRestoreCellContentsAfterPlayback(true);
              graffiti.loadAndPlayMovie('tip');
            }
          };
          var confirmModal = dialog.modal({
            title: localizer.getString('PLAY_CONFIRM'),
            body: dialogContent,
            sanitize: false,
            buttons: modalButtons
          });
          confirmModal.on('hidden.bs.modal', function (e) {
            console.log('Graffiti: escaped the dontRestoreCellContents modal.');
          });
        } else {
          graffiti.loadAndPlayMovie('tip');
        }
      },

      executeSaveToFileDirectives: function executeSaveToFileDirectives(recording) {
        if (recording.saveToFile !== undefined) {
          if (recording.saveToFile.length > 0) {
            var saveToFileEntry = void 0,
                fileContents = void 0,
                _cell6 = void 0;
            // Loop over all directives and save all files.
            for (var i = 0; i < recording.saveToFile.length; ++i) {
              saveToFileEntry = recording.saveToFile[i];
              _cell6 = utils.findCellByCellId(saveToFileEntry.cellId);
              if (_cell6 !== undefined) {
                fileContents = _cell6.get_text();
                storage.writeTextToFile({ path: saveToFileEntry.path,
                  contents: fileContents,
                  stripCRs: false });
              }
            }
            storage.cleanUpExecutorCell();
          }
        }
      },

      cleanupAfterLoadAndPlayDidNotPlay: function cleanupAfterLoadAndPlayDidNotPlay() {
        graffiti.clearJupyterMenuHint();
        graffiti.changeActivity('idle');
        graffiti.updateControlPanels();
        utils.saveNotebook();
      },

      loadAndPlayMovie: function loadAndPlayMovie(kind) {
        var playableMovie = state.getPlayableMovie(kind);
        if (playableMovie === undefined) {
          console.log('Graffiti: no playable movie defined.');
          return;
        }

        console.log('Graffiti: playableMovie:', playableMovie);
        var activity = state.getActivity();
        var recording = state.getManifestSingleRecording(playableMovie.recordingCellId, playableMovie.recordingKey);
        // If we are in cellExecuteChoice state, we don't want to run a movie at all, we just want to wire a button to the graffiti associated with this movie.
        var executionSourceChoiceId = state.getExecutionSourceChoiceId();
        if (executionSourceChoiceId !== undefined) {
          var targetGraffitiId = utils.composeGraffitiId(playableMovie.recordingCellId, playableMovie.recordingKey);
          var executionSourceChoiceCell = utils.findCellByCellId(executionSourceChoiceId);
          utils.setCellGraffitiConfigEntry(executionSourceChoiceCell, 'executeCellViaGraffiti', targetGraffitiId); // needs to be set by the content author
          state.clearExecutionSourceChoiceId();
          graffiti.cleanupAfterLoadAndPlayDidNotPlay();
          graffiti.setJupyterMenuHint(localizer.getString('CELL_EXECUTE_CHOICE_SET'));
        } else {
          // Execute any "save code cell contents to files" directives
          graffiti.executeSaveToFileDirectives(recording);
          if (recording.terminalCommand !== undefined) {
            var terminalCommand = recording.terminalCommand;
            terminalLib.runTerminalCommand(terminalCommand.terminalId, terminalCommand.command, true);
            if (activity !== 'recording') {
              graffiti.cleanupAfterLoadAndPlayDidNotPlay(); // clean up *unless* we are recording; then we should just let things keep going.
            }

            state.updateUsageStats({
              type: 'terminalCommand',
              data: {
                cellId: playableMovie.recordingCellId,
                recordingKey: playableMovie.recordingKey,
                command: recording.terminalCommand
              }
            });
            return; // we are done if we ran a terminal command, don't bother to load any movies for playback.
          }
        }

        // next line seems to be extraneous and buggy because we create a race condition with the control panel. however what happens if a movie cannot be loaded?
        // graffiti.cancelPlayback({cancelAnimation:false}); // cancel any ongoing movie playback b/c user is switching to a different movie

        $('#graffiti-movie-play-btn').html('<i>' + localizer.getString('LOADING') + '</i>').prop('disabled', true);
        graffiti.setJupyterMenuHint(localizer.getString('LOADING_PLEASE_WAIT'));
        storage.loadMovie(playableMovie.recordingCellId, playableMovie.recordingKey, playableMovie.activeTakeId).then(function () {
          console.log('Graffiti: Movie loaded for cellId, recordingKey:', playableMovie.recordingCellId, playableMovie.recordingKey);

          state.setNarratorInfo('name', recording.narratorName);
          state.setNarratorInfo('picture', recording.narratorPicture);
          if (playableMovie.cellType === 'markdown') {
            playableMovie.cell.render(); // always render a markdown cell first before playing a movie on a graffiti inside it
          }
          state.updateUsageStats({
            type: 'setup',
            data: {
              cellId: playableMovie.recordingCellId,
              recordingKey: playableMovie.recordingKey,
              activeTakeId: playableMovie.activeTakeId
            }
          });
          state.updateUsageStats({
            type: 'play',
            data: {
              actions: ['resetCurrentPlayTime', 'incrementPlayCount']
            }
          });
          graffiti.togglePlayback();
          graffiti.hideTip();
        }).catch(function (ex) {
          graffiti.changeActivity('idle');
          dialog.modal({
            title: localizer.getString('MOVIE_UNAVAILABLE'),
            body: localizer.getString('MOVIE_UNAVAILABLE_EXPLANATION'),
            sanitize: false,
            buttons: {
              'OK': {
                click: function click(e) {
                  console.log('Graffiti: Missing movie acknowledged.');
                }
              }
            }
          });
          console.log('Graffiti: could not load movie:', ex);
          graffiti.cleanupAfterLoadAndPlayDidNotPlay();
        });
      },

      playRecordingById: function playRecordingById(recordingCellId, recordingKey) {
        var recording = state.setPlayableMovie('api', recordingCellId, recordingKey);
        if (recording !== undefined) {
          graffiti.loadAndPlayMovie('api');
        } else {
          // Putting an error message in console for this failure mode is gentler than the dialog box put up by loadAndPlayMovie(),
          // because if we are being called by an autoplay movie that was on a delete cell, the
          // endless dialog boxes would drive the user crazy (because they could not remove the graffiti from our manifest)
          console.log('Graffiti: not playing movie ' + recordingCellId + ':' + recordingKey + ', as it was not available.');
        }
      },

      playRecordingByIdString: function playRecordingByIdString(recordingFullId) {
        var parts = utils.parseRecordingFullId(recordingFullId);
        graffiti.playRecordingById(parts.recordingCellId, parts.recordingKey);
      },

      playRecordingByIdWithPrompt: function playRecordingByIdWithPrompt(recordingFullId, promptMarkdown) {
        graffiti.changeActivity('notifying');
        var promptHtml = '<span>' + utils.renderMarkdown(promptMarkdown) + '</span>';

        graffiti.setNotifier('<div id="graffiti-notifier-prompt">' + promptHtml + '</div>', [{
          ids: ['graffiti-notifier-prompt'],
          event: 'click',
          fn: function fn(e) {
            graffiti.playRecordingByIdString(recordingFullId);
          }
        }]);
      },

      activateAudio: function activateAudio() {
        if (!state.getAudioInitialized()) {
          audio.init({
            succeed: function succeed() {
              state.setAudioInitialized();
            },
            fail: function fail() {
              dialog.modal({
                title: localizer.getString('ACCESS_MICROPHONE_PROMPT'),
                body: localizer.getString('ACCESS_MICROPHONE_ADVISORY'),
                sanitize: false,
                buttons: {
                  'OK': {}
                }
              });
            }
          });
        }
      },

      changeAccessLevel: function changeAccessLevel(level) {
        if (level === 'create') {
          graffiti.cancelPlayback({ cancelAnimation: true });
          graffiti.activateAudio(); // we need to activate audio to create the audio object, even if microphone access was previously granted.
          storage.ensureNotebookGetsGraffitiId();
          storage.ensureNotebookGetsFirstAuthorId();
          utils.assignCellIds();
          utils.saveNotebook(function () {
            graffiti.refreshAllGraffitiHighlights();
            graffiti.refreshGraffitiTooltipsDebounced();
          });
        } else {
          graffiti.outerControlPanel.fadeOut(graffiti.panelFadeTime);
        }
        state.setAccessLevel(level);
        graffiti.updateControlPanels();
      },

      toggleAccessLevel: function toggleAccessLevel(forcedLevel) {
        var buttonLabel = void 0;
        var level = forcedLevel === undefined ? state.getAccessLevel() : forcedLevel;
        if (forcedLevel !== undefined) {
          if (level === 'create') {
            buttonLabel = localizer.getString('HIDE_GRAFFITI_EDITOR');
            graffiti.changeAccessLevel('create');
          } else {
            buttonLabel = localizer.getString('SHOW_GRAFFITI_EDITOR');
            graffiti.changeAccessLevel('view');
          }
        } else {
          if (level === 'create') {
            buttonLabel = localizer.getString('SHOW_GRAFFITI_EDITOR');
            graffiti.changeAccessLevel('view');
          } else {
            buttonLabel = localizer.getString('HIDE_GRAFFITI_EDITOR');
            graffiti.changeAccessLevel('create');
          }
        }
        $('#graffiti-setup-button span:last').text(buttonLabel);
      },

      showCreatorsChooser: function showCreatorsChooser() {
        graffiti.setNotifier(localizer.getString('YOU_CAN_FILTER'));
        graffiti.showControlPanels(['graffiti-notifier', 'graffiti-creators-chooser']);
      },

      transferGraffitis: function transferGraffitis() {
        storage.transferGraffitis().then(function () {
          dialog.modal({
            title: 'Transfer Complete',
            body: 'Your Notebook\'s Graffitis have been copied over from the original notebook. ' + 'Now you can modify them (or add and remove Graffitis to this notebook),  without affecting the original notebook\'s Graffitis.',
            sanitize: false,
            buttons: {
              'OK': {
                click: function click(e) {
                  console.log('Graffiti: You clicked ok');
                }
              }
            }
          });
        });
      },

      packageGraffitis: function packageGraffitis() {
        storage.packageGraffitis().then(function (fileName) {
          dialog.modal({
            title: 'Packaging Complete',
            body: 'Your Notebook\'s Graffitis, and your notebook, have been copied into a archive file.<br><br>' + 'Now you can copy and unpack that archive file anywhere Graffiti is supported, using the terminal command: ' + '<code>tar zxf ' + fileName + '</code>',
            sanitize: false,
            buttons: {
              'OK': {
                click: function click(e) {
                  console.log('Graffiti: You clicked ok');
                }
              }
            }
          });
        });
      },

      updateSetupButton: function updateSetupButton() {
        var notebook = Jupyter.notebook;
        var sprayCanIcon = stickerLib.makeSprayCanIcon();
        var buttonLabel = void 0,
            setupForSetup = false;
        //sprayCanIcon = '<img src="/nbextensions/graffiti-dist/spray_can_icon.png">';
        var buttonContents = '<div id="graffiti-setup-button" style="display:none;" class="btn-group"><button class="btn btn-default" title="' + localizer.getString('ENABLE_GRAFFITI') + '">';

        if (!notebook.metadata.hasOwnProperty('graffiti')) {
          // This notebook has never been graffiti-ized, or it just got un-graffiti-ized
          var existingSetupButton = $('#graffiti-setup-button');
          if (existingSetupButton.length > 0) {
            existingSetupButton.remove();
          }
          buttonLabel = localizer.getString('ACTIVATE_GRAFFITI');
          setupForSetup = true;
        } else {
          // This notebook has already been graffiti-ized. Render the setup button for view mode,
          // which is the default mode to start.
          buttonLabel = localizer.getString('SHOW_GRAFFITI_EDITOR');
        }
        var setupButtonDiv = $(buttonContents + '<span>' + buttonLabel + '</div></button></span>');
        var jupyterMainToolbar = $('#maintoolbar-container');
        setupButtonDiv.appendTo(jupyterMainToolbar);
        $('#graffiti-setup-button button').prepend(sprayCanIcon);
        if (setupForSetup) {
          $('#graffiti-setup-button').click(function () {
            graffiti.firstTimeSetup();
          });
        } else {
          $('#graffiti-setup-button').click(function () {
            graffiti.toggleAccessLevel();
          });
        }
      },

      firstTimeSetup: function firstTimeSetup() {
        dialog.modal({
          title: localizer.getString('ACTIVATE_GRAFFITI_CONFIRM'),
          body: localizer.getString('ACTIVATE_GRAFFITI_ADVISORY'),
          sanitize: false,
          buttons: {
            'OK': {
              click: function click(e) {
                console.log('Graffiti: You clicked ok');
                storage.ensureNotebookGetsGraffitiId();
                storage.ensureNotebookGetsFirstAuthorId();
                utils.saveNotebook(function () {
                  utils.createApiSymlink();
                  graffiti.initInteractivity();
                  graffiti.toggleAccessLevel('view');
                  graffiti.activateAudio(); // request microphone access in case switching to 'create' mode later
                  $('#graffiti-setup-button').unbind('click').click(function () {
                    graffiti.toggleAccessLevel();
                  });
                });
              }
            },
            'Cancel': {
              click: function click(e) {
                console.log('Graffiti: Not adding Graffiti.');
              }
            }
          }
        });
      }
    };

    // Functions exposed externally to the Python API.
    return {
      init: graffiti.init,
      graffiti: graffiti, // remove me
      state: state, // remove me
      playRecordingById: function playRecordingById(recordingFullId) {
        graffiti.playRecordingByIdString(recordingFullId);
      },
      playRecordingByIdWithPrompt: function playRecordingByIdWithPrompt(recordingFullId, promptMarkdown) {
        graffiti.playRecordingByIdWithPrompt(recordingFullId, promptMarkdown);
      },
      cancelPlayback: function cancelPlayback() {
        graffiti.cancelPlayback({ cancelAnimation: false });
      },
      removeUnusedTakes: function removeUnusedTakes(recordingFullId) {
        graffiti.removeUnusedTakesWithConfirmation(recordingFullId);
      },
      removeAllUnusedTakes: function removeAllUnusedTakes() {
        graffiti.removeAllUnusedTakesWithConfirmation();
      },
      removeAllGraffiti: graffiti.removeAllGraffitisWithConfirmation,
      disableGraffiti: graffiti.disableGraffitiWithConfirmation,
      setAccessLevel: function setAccessLevel(level) {
        graffiti.toggleAccessLevel(level);
      },
      transferGraffitis: function transferGraffitis() {
        graffiti.transferGraffitis();
      },
      packageGraffitis: function packageGraffitis() {
        graffiti.packageGraffitis();
      },
      getUsageStats: function getUsageStats() {
        return state.getUsageStats();
      },
      selectionSerializer: selectionSerializer,
      controlTerminal: function controlTerminal(opts) {
        graffiti.controlTerminal(opts);
      }
      // showCreatorsChooser: graffiti.showCreatorsChooser, // demo only
    };
  }();

  return Graffiti;
});

// affected files
//      modified:   jupytergraffiti/js/graffiti.js
//	modified:   jupytergraffiti/js/loader.js
//	modified:   jupytergraffiti/js/state.js
//	modified:   jupytergraffiti/js/storage.js
//	modified:   jupytergraffiti/js/utils.js;


define('js/loader.js',[], function () {
  if (window.Graffiti !== undefined) {
    console.log('Graffiti already instantiated, not reinitializing');
    return;
  }

  require(['./graffiti.js', './utils.js', './storage.js', './udacityUser.js'], function (Graffiti, utils, storage, udacityUser) {
    console.log('Graffiti loaded:', Graffiti);
    window.Graffiti = Graffiti;
    udacityUser.setUser();
    Graffiti.init();

    Jupyter.notebook.events.on('kernel_reconnecting.Kernel', function () {
      console.log('kernel reconnecting');
    });

    Jupyter.notebook.events.on('kernel_ready.Kernel', function () {
      console.log('Graffiti: kernel ready, possible kernel restart.', e);
      if (!udacityUser.token) {
        udacityUser.setUser();
      }
      require(['./loader.js']);
      utils.saveNotebook();
    });
  });
});


// Mark Graffiti as about to load, because extension should always get precedence over python API library
// in case that is also going to be loaded by Jupyter.

window.Graffiti = null;

define('nbextensions/graffiti-dist/graffiti',['base/js/namespace', 'js/graffiti.js', 'js/utils.js', 'js/storage.js', 'js/udacityUser.js'], function (Jupyter, Graffiti, utils, storage, udacityUser) {
  function load_ipython_extension() {
    console.log('Graffiti loaded:', Graffiti);

    var initExtension = function initExtension() {
      window.Graffiti = Graffiti;
      udacityUser.setUser();
      Graffiti.init();

      Jupyter.notebook.events.on('kernel_ready.Kernel', function (e) {
        console.log('Graffiti: kernel ready, possible kernel restart.', e);
        console.log('Reloading loader.js');
        if (!udacityUser.token) {
          udacityUser.setUser();
        }
        require(['js/loader.js']);
        utils.saveNotebook();
      });
    };

    // the notebook may have fully loaded before the nbextension gets loaded
    // so the nbextension would miss the `notebook_loaded.Notebook` event
    if (Jupyter.notebook._fully_loaded) {
      console.log('Notebook is already fully loaded.');
      initExtension();
    } else {
      Jupyter.notebook.events.on('notebook_loaded.Notebook', function (e) {
        console.log('Notebook is loaded.');
        initExtension();
      });
    }
  }

  return {
    load_ipython_extension: load_ipython_extension
  };
});
